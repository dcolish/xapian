diff -ruN python.orig/docs/Makefile.am python/docs/Makefile.am
--- python.orig/docs/Makefile.am	Tue Jun 29 15:58:59 2004
+++ python/docs/Makefile.am	Thu May 20 15:55:36 2004
@@ -4,4 +4,4 @@
 SUBDIRS = examples
 
 docdatadir = $(datadir)/doc/@PACKAGE@/python
-docdata_DATA = bindings.html
+dist_docdata_DATA = bindings.html
diff -ruN python.orig/docs/bindings.html python/docs/bindings.html
--- python.orig/docs/bindings.html	Thu Jan  1 01:00:00 1970
+++ python/docs/bindings.html	Mon Jan 12 17:54:01 2004
@@ -0,0 +1,168 @@
+<html><head><title>Python bindings for Xapian</title></head>
+<body>
+<h1>Python bindings for Xapian</h1>
+
+<p>
+The Python bindings for Xapian are packaged in the <code>xapian</code> module, and
+largely follow the C++ API, with the following differences and
+additions. Python strings and lists, etc., are converted automatically
+in the bindings, so generally it should just work as expected.
+</p>
+
+<h2>Exceptions</h2>
+
+<p>
+   Exceptions are thrown as SWIG exceptions instead of Xapian
+   exceptions. This isn't done well at the moment; in future we will
+   throw wrapped Xapian exceptions. For now, it's probably easier to
+   catch all exceptions and try to take appropriate action based on
+   their associated string.
+</p>
+
+<h2><code>empty()</code> methods</h2>
+
+<p>
+   <code>empty()</code> methods are renamed to <code>is_empty()</code> in the bindings.
+</p>
+
+<h2>Iterators</h2>
+
+<p>
+   All iterators support <code>next()</code> and <code>equals()</code> methods to move through
+   and test iterators (as for all language bindings). Python-wrapped
+   iterators also support direct comparison, so something like:
+</p>
+
+<pre>
+   m=mset.begin()
+   while m!=mset.end():
+     # do something
+     m.next()
+</pre>
+
+<h2>Iterator dereferencing</h2>
+
+<p>
+   C++ iterators are often dereferenced to get information, eg
+   <code>(*it)</code>. With Python these are all mapped to named methods, as
+   follows:
+</p>
+
+<table title='Iterator deferencing methods'>
+<thead><td>Iterator</td><td>Dereferencing method</td></thead>
+<tr><td>PositionIterator</td>	<td><code>get_termpos()</code></td></tr>
+<tr><td>PostingIterator</td>	<td><code>get_docid()</code></td></tr>
+<tr><td>TermIterator</td>		<td><code>get_term()</code></td></tr>
+<tr><td>ValueIterator</td>	<td><code>get_value()</code></td></tr>
+<tr><td>MSetIterator</td>		<td><code>get_docid()</code></td></tr>
+<tr><td>ESetIterator</td>		<td><code>get_termname()</code></td></tr>
+</table>
+
+<p>
+   Other methods, such as <code>MSetIterator.get_document()</code>, are available unchanged.
+</p>
+   
+<h2>MSet</h2>
+
+<p>
+   MSet objects have some additional methods to simplify access (these
+   work using the C++ array dereferencing):
+</p>
+
+<table title='MSet additional methods'>
+<thead><td>Method name</td><td>Explanation</td></thead>
+<tr><td><code>get_hit(index)</code></td><td>returns MSetIterator at index</td></tr>
+<tr><td><code>get_document_percentage(index)</code></td><td><code>convert_to_percent(get_hit(index))</code></td></tr>
+<tr><td><code>get_document(index)</code></td><td><code>get_hit(index).get_document()</code></td></tr>
+<tr><td><code>get_document_id(index)</code></td><td><code>get_hit(index).get_docid()</code></td></tr>
+</table>
+
+<p>
+Additionally, the MSet has a property, <code>mset.items</code>, which returns a list of tuples representing the MSet; this may be more convenient than using the MSetIterator. The members of the tuple are as follows.
+</p>
+
+<table title='MSet.items member members'>
+<thead><td>Index</td><td>Contents</td></thead>
+<tr><td><code>xapian.MSET_DID</code></td><td>Document id</td></tr>
+<tr><td><code>xapian.MSET_WT</code></td><td>Weight</td></tr>
+<tr><td><code>xapian.MSET_RANK</code></td><td>Rank</td></tr>
+<tr><td><code>xapian.MSET_PERCENT</code></td><td>Percentage weight</td></tr>
+</table>
+
+<p>
+Two MSet objects are equal if they have the same number and maximum possible number of members, and if every document member of the first MSet exists at the same index in the second MSet, with the same weight.
+</p>
+
+<h2>ESet</h2>
+
+<p>
+The ESet has a property, <code>eset.items</code>, which returns a list of tuples representing the ESet; this may be more convenient than using the ESetIterator. The members of the tuple are as follows.
+</p>
+
+<table title='ESet.items member members'>
+<thead><td>Index</td><td>Contents</td></thead>
+<tr><td><code>xapian.ESET_TNAME</code></td><td>Term name</td></tr>
+<tr><td><code>xapian.ESET_WT</code></td><td>Weight</td></tr>
+</table>
+
+<h2>Xapian::Auto</h2>
+
+<p>
+   Functions in <code>Xapian::Auto</code> are mapped directly into the <code>xapian</code>
+   module (so <code>Xapian::Auto::open()</code> becomes <code>xapian.open()</code>, for
+   instance). The <code>Xapian::Auto::DB_*</code> constants are available as
+   <code>xapian.DB_*</code>.
+</p>
+
+<h2>Query</h2>
+
+<p>
+   Please note that although the source code for the bindings
+   indicates that there's another constructor to <code>xapian.Query</code> that
+   should be able to take a default query operator, a list of queries,
+   and an optional window, this doesn't actually work in Python at the
+   moment due to the way SWIG overloading works.
+</p>
+
+<h2>Enquire</h2>
+
+<p>
+   There is an additional method <code>get_matching_terms()</code> which takes an
+   MSetIterator and returns a list of terms in the current query which
+   match the document given by that iterator. This may be slightly
+   more convenient than using the TermIterator directly.
+</p>
+
+<h2>QueryParser and Stem</h2>
+
+<p>
+   The query parser and C++ wrapped stemmers are wrapped for Python as
+   <code>xapian.QueryParser</code> and <code>xapian.Stem</code>. The interfaces are identical to
+   the C++ versions.
+</p>
+
+<h2>MatchDecider</h2>
+
+<p>
+Custom MatchDeciders can be created in Python; simply subclass xapian.MatchDecider, ensure you call the super-constructor, and define a __call__ method that will do the work. The simplest example (which does nothing useful) would be as follows.
+</p>
+
+<pre>
+class mymatcher(xapian.MatchDecider):
+  def __init__(self):
+    xapian.MatchDecider.__init__(self)
+
+  def __call__(self, doc):
+    return 1
+</pre>
+
+<p>
+There are examples of the Python bindings, based on simplesearch and
+simpleindex from <code>xapian-examples</code>, in the <code>examples</code> subdirectory. There is also an example of defining a MatchDecider in Python.
+</p>
+
+<address>
+Last updated $Date$
+</address>
+</body>
+</html>
diff -ruN python.orig/docs/examples/Makefile.am python/docs/examples/Makefile.am
--- python.orig/docs/examples/Makefile.am	Tue Jun 29 15:58:59 2004
+++ python/docs/examples/Makefile.am	Thu May 20 15:55:36 2004
@@ -1,4 +1,4 @@
 ## Process this file with automake to produce Makefile.in
 
 docdatadir = $(datadir)/doc/@PACKAGE@/python/examples
-docdata_DATA = simplesearch.py simpleindex.py simpleexpand.py simplematchdecider.py
+dist_docdata_DATA = simplesearch.py simpleindex.py simpleexpand.py simplematchdecider.py
diff -ruN python.orig/docs/examples/simpleexpand.py python/docs/examples/simpleexpand.py
--- python.orig/docs/examples/simpleexpand.py	Thu Jan  1 01:00:00 1970
+++ python/docs/examples/simpleexpand.py	Thu Jan  1 22:48:39 2004
@@ -0,0 +1,97 @@
+#!/usr/bin/env python
+#
+# $Id$
+# Simple command-line query expand program
+#
+# ----START-LICENCE----
+# Copyright 2003 James Aylett
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+# USA
+# -----END-LICENCE-----
+
+import sys
+import xapian
+
+MAX_PROB_TERM_LENGTH = 64
+
+if len(sys.argv) < 3:
+    print >> sys.stderr, "usage: %s <path to database> [<search terms>] [-- <relevant docids>]" % sys.argv[0]
+    sys.exit(1)
+
+try:
+    database = xapian.open(sys.argv[1])
+
+    enquire = xapian.Enquire(database)
+    stemmer = xapian.Stem("english")
+#    subqs = []
+    topquery = None
+    index = 2
+    while index < len(sys.argv):
+        term = sys.argv[index]
+        if term=='--':
+            # passed marker, move to relevant docids
+            index += 1
+            break
+        nextquery = xapian.Query(stemmer.stem_word(term.lower()))
+        if topquery==None:
+            topquery = nextquery
+        else:
+            topquery = xapian.Query(xapian.Query.OP_OR, topquery, nextquery)
+#        subqs.append(xapian.Query(term))
+        index += 1
+#    query = xapian.Query(xapian.Query.OP_OR, subqs)
+    query = topquery
+
+    # Prepare relevant document set (RSet)
+    reldocs = xapian.RSet()
+    if index<len(sys.argv):
+        for index in xrange(index,len(sys.argv)):
+            rdid = int(sys.argv[index])
+            if rdid!=0:
+                reldocs.add_document(rdid)
+
+    matches = xapian.MSet()
+    if query!=None:
+        print "Performing query `%s' against rset `%s'" % (query.get_description(),reldocs.get_description())
+
+        enquire.set_query(query)
+        matches = enquire.get_mset(0, 10, reldocs)
+
+        print "%i results found" % matches.get_matches_estimated()
+        for match in matches:
+            print "ID %i %i%% [%s]" % (match[xapian.MSET_DID], match[xapian.MSET_PERCENT], match[xapian.MSET_DOCUMENT].get_data())
+
+    # Put the top 5 (at most) docs into the rset if rset is empty
+    if reldocs.is_empty():
+        i = matches.begin()
+        for j in xrange(1, 5):
+            reldocs.add_document(i.get_docid())
+            i.next()
+            if i == matches.end():
+                break
+
+    # Get the suggested expand terms
+    eterms = enquire.get_eset(10, reldocs)
+    print "%i suggested additional terms" % eterms.size()
+    k = eterms.begin()
+    while k!=eterms.end():
+        print "Term `%s'\t (weight %i)" % (k.get_termname(), k.get_weight())
+        k.next()
+
+except:
+    # FIXME: exception message
+    print >> sys.stderr, "Exception"
+    raise
diff -ruN python.orig/docs/examples/simpleindex.py python/docs/examples/simpleindex.py
--- python.orig/docs/examples/simpleindex.py	Thu Jan  1 01:00:00 1970
+++ python/docs/examples/simpleindex.py	Fri May 28 14:43:59 2004
@@ -0,0 +1,92 @@
+#!/usr/bin/env python
+#
+# $Id$
+# Index each paragraph in a textfile as a document
+#
+# ----START-LICENCE----
+# Copyright 2003 James Aylett
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+# USA
+# -----END-LICENCE-----
+
+import sys
+import xapian
+import string
+
+MAX_PROB_TERM_LENGTH = 64
+
+def p_alnum(c):
+    return (c in string.ascii_letters or c in string.digits)
+
+def p_notalnum(c):
+    return not p_alnum(c)
+
+def p_notplusminus(c):
+    return c != '+' and c != '-'
+
+def find_p(string, start, predicate):
+    while start<len(string) and not predicate(string[start]):
+        start += 1
+    return start
+
+if len(sys.argv) != 2:
+    print >> sys.stderr, "usage: %s <path to database>" % sys.argv[0]
+    sys.exit(1)
+
+try:
+    database = xapian.open(sys.argv[1], xapian.DB_CREATE_OR_OPEN)
+
+    stemmer = xapian.Stem("english")
+    para = ''
+    try:
+        for line in sys.stdin:
+            line = string.rstrip(line)
+            if line=='':
+                if para!='':
+                    doc = xapian.Document()
+                    doc.set_data(para)
+                    pos = 0
+                    # At each point, find the next alnum character (i), then
+                    # find the first non-alnum character after that (j). Find
+                    # the first non-plusminus character after that (k), and if
+                    # k is non-alnum (or is off the end of the para), set j=k.
+                    # The term generation string is [i,j), so len = j-i
+                    i = 0
+                    j = 0
+                    while i<len(para):
+                        i = find_p(para, j, p_alnum)
+                        j = find_p(para, i, p_notalnum)
+                        k = find_p(para, j, p_notplusminus)
+                        if k==len(para) or not p_alnum(para[k]):
+                            j = k
+                        if (j-i) <= MAX_PROB_TERM_LENGTH and j>i:
+                            term = stemmer.stem_word(string.lower(para[i:j]))
+                            doc.add_posting(term, pos)
+                            pos += 1
+                        i = j
+                    database.add_document(doc)
+                    para = ''
+            else:
+                if para!='':
+                    para += ' '
+                para += line
+    except StopIteration:
+        pass
+
+except:
+    # FIXME: exception message
+    print >> sys.stderr, "Exception"
+    raise
diff -ruN python.orig/docs/examples/simplematchdecider.py python/docs/examples/simplematchdecider.py
--- python.orig/docs/examples/simplematchdecider.py	Thu Jan  1 01:00:00 1970
+++ python/docs/examples/simplematchdecider.py	Thu Jan  1 22:48:39 2004
@@ -0,0 +1,78 @@
+#!/usr/bin/env python
+#
+# $Id$
+# Simple command-line match decider example
+#
+# ----START-LICENCE----
+# Copyright 2003 James Aylett
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+# USA
+# -----END-LICENCE-----
+
+import sys
+import xapian
+
+MAX_PROB_TERM_LENGTH = 64
+
+if len(sys.argv) < 4:
+    print >> sys.stderr, "usage: %s <path to database> <avoid-term> <search terms>" % sys.argv[0]
+    sys.exit(1)
+
+class mymatcher(xapian.MatchDecider):
+    def __init__(self, avoidterm):
+        xapian.MatchDecider.__init__(self)
+        self.avoidterm = avoidterm
+        
+    def __call__(self, doc):
+#        print "Called on document '%s'" % doc.get_description()
+        ti = doc.termlist_begin()
+        while ti!=doc.termlist_end():
+#            print "Term '%s' (we are '%s')" % (ti.get_term(), self.avoidterm)
+            if ti.get_term()==self.avoidterm:
+                return 0
+            ti.next()
+        return 1
+
+try:
+    database = xapian.open(sys.argv[1])
+
+    enquire = xapian.Enquire(database)
+    stemmer = xapian.Stem("english")
+#    subqs = []
+    topquery = None
+    for term in sys.argv[3:]:
+        nextquery = xapian.Query(stemmer.stem_word(term.lower()))
+        if topquery==None:
+            topquery = nextquery
+        else:
+            topquery = xapian.Query(xapian.Query.OP_OR, topquery, nextquery)
+#        subqs.append(xapian.Query(term))
+#    query = xapian.Query(xapian.Query.OP_OR, subqs)
+    query = topquery
+    print "Performing query `%s'" % query.get_description()
+
+    enquire.set_query(query)
+    matcher = mymatcher(sys.argv[2])
+    matches = enquire.get_mset(0, 10, None, matcher)
+
+    print "%i results found" % matches.get_matches_estimated()
+    for match in matches:
+        print "ID %i %i%% [%s]" % (match[xapian.MSET_DID], match[xapian.MSET_PERCENT], match[xapian.MSET_DOCUMENT].get_data())
+
+except:
+    # FIXME: exception message
+    print >> sys.stderr, "Exception"
+    raise
diff -ruN python.orig/docs/examples/simplesearch.py python/docs/examples/simplesearch.py
--- python.orig/docs/examples/simplesearch.py	Thu Jan  1 01:00:00 1970
+++ python/docs/examples/simplesearch.py	Thu Jan  1 22:48:39 2004
@@ -0,0 +1,62 @@
+#!/usr/bin/env python
+#
+# $Id$
+# Simple command-line search program
+#
+# ----START-LICENCE----
+# Copyright 2003 James Aylett
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of the
+# License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+# USA
+# -----END-LICENCE-----
+
+import sys
+import xapian
+
+MAX_PROB_TERM_LENGTH = 64
+
+if len(sys.argv) < 3:
+    print >> sys.stderr, "usage: %s <path to database> <search terms>" % sys.argv[0]
+    sys.exit(1)
+
+try:
+    database = xapian.open(sys.argv[1])
+
+    enquire = xapian.Enquire(database)
+    stemmer = xapian.Stem("english")
+#    subqs = []
+    topquery = None
+    for term in sys.argv[2:]:
+        nextquery = xapian.Query(stemmer.stem_word(term.lower()))
+        if topquery==None:
+            topquery = nextquery
+        else:
+            topquery = xapian.Query(xapian.Query.OP_OR, topquery, nextquery)
+#        subqs.append(xapian.Query(term))
+#    query = xapian.Query(xapian.Query.OP_OR, subqs)
+    query = topquery
+    print "Performing query `%s'" % query.get_description()
+
+    enquire.set_query(query)
+    matches = enquire.get_mset(0, 10)
+
+    print "%i results found" % matches.get_matches_estimated()
+    for match in matches:
+        print "ID %i %i%% [%s]" % (match[xapian.MSET_DID], match[xapian.MSET_PERCENT], match[xapian.MSET_DOCUMENT].get_data())
+
+except:
+    # FIXME: exception message
+    print >> sys.stderr, "Exception"
+    raise
