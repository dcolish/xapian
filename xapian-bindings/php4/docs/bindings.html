<html><head><title>PHP4 bindings for Xapian</title></head>
<body>
<h1>PHP4 bindings for Xapian</h1>

<p>
The PHP4 bindings for Xapian are packaged in the <code>xapian.so</code>
extension, and largely follow the C++ API.  This document lists the differences
and additions. PHP4 strings and arrays, etc., are converted automatically
in the bindings, so generally it should just work as expected.
</p>

<p>
The <code>examples</code> subdirectory contains examples showing how to use the
PHP4 bindings based on the simple examples from <code>xapian-examples</code>:
<a href="examples/simpleindex.php4">simpleindex.php4</a>,
<a href="examples/simplesearch.php4">simplesearch.php4</a>.
</p>

<h2>Installation</h2>

<p>
Assuming you have suitable versions of PHP4 and SWIG installed, running
configure will automatically enable the PHP4 bindings, and
<code>make install</code> will install the extension shared library in
the location reported by <code>php-config --extension-dir</code>.
</p>

<p>
Check that php.ini has a line like <code>extension_dir =
"<i>&lt;location reported by php-config --extension-dir&gt;</i>"</code>.
</p>

<p>
Then add this line to php.ini: <code>extension = xapian.so</code> (or
whatever the library is called - not all UNIX systems use <code>.so</code>
as the extension, and MS Windows uses <code>.dll</code>).
</p>

<p>
Depending how PHP is setup, you may need to restart the webserver for this
change to take effect.
</p>

<p>
Alternatively you can add the following line to the start of your PHP scripts:
<code>dl('xapian.so');</code>
</p>

<h2>Exceptions</h2>

<p>
In general, a PHP4 fatal error is triggered on a C++ exception being thrown in
the library. This is awful, and should be fixed in some useful way - the
intention is to rework the core library to not throw exceptions but this
is not at trivial job.
</p>

<h2>Object orientation</h2>

<p>
The PHP4 bindings do not currently use a PHP4 object orientated style. In order
to construct an object, use <code>$object = new_ClassName(...)</code>.  Destroy
it using <code>delete_ClassName($object)</code>. Invoke methods on an object
using <code>ClassName_method_name($object, ...)</code>.
</p>

<h2>Iterators</h2>

<p>
   All iterators support <code>next()</code> and <code>equals()</code> methods
   to move through and test iterators (as for all language bindings).
   MSetIterator and ESetIterator also support <code>prev()</code>.
</p>

<h2>Iterator dereferencing</h2>

<p>
   C++ iterators are often dereferenced to get information, eg
   <code>(*it)</code>. With PHP4 these are all mapped to named methods, as
   follows:
</p>

<table title="Iterator deferencing methods">
<thead><td>Iterator</td><td>Dereferencing method</td></thead>
<tr><td>PositionIterator</td>	<td><code>get_termpos()</code></td></tr>
<tr><td>PostingIterator</td>	<td><code>get_docid()</code></td></tr>
<tr><td>TermIterator</td>	<td><code>get_term()</code></td></tr>
<tr><td>ValueIterator</td>	<td><code>get_value()</code></td></tr>
<tr><td>MSetIterator</td>	<td><code>get_docid()</code></td></tr>
<tr><td>ESetIterator</td>	<td><code>get_termname()</code></td></tr>
</table>

<p>
   Other methods, such as <code>MSetIterator.get_document()</code>, are
   available unchanged.
</p>
   
<h2>MSet</h2>

<p>
   MSet objects have some additional methods to simplify access (these
   work using the C++ array dereferencing):
</p>

<table title="MSet additional methods">
<thead><td>Method name</td><td>Explanation</td></thead>
<tr><td><code>get_hit(index)</code></td><td>returns MSetIterator at index</td></tr>
<tr><td><code>get_document_percentage(index)</code></td><td><code>convert_to_percent(get_hit(index))</code></td></tr>
<tr><td><code>get_document(index)</code></td><td><code>get_hit(index).get_document()</code></td></tr>
<tr><td><code>get_document_id(index)</code></td><td><code>get_hit(index).get_docid()</code></td></tr>
</table>

<h2>Xapian::Auto</h2>

<p>
   Functions in <code>Xapian::Auto</code> are mapped directly (so
   <code>Xapian::Auto::open()</code> becomes <code>open()</code>, for
   instance).  The 2 argument form of <code>Auto::open()</code> which opens a writable
   database is wrapped as <code>open_writable</code>.
</p>

<h2>Xapian::Quartz::open, Xapian::InMemory::open, and Xapian::Remote::open</h2>

<ul>
<li> <code>Xapian::Quartz::open(<i>path</i>)</code> is wrapped as <code>quartz_open(<i>path</i>)</code>
<li> The 2 or 3 argument form of <code>Xapian::Quartz::open()</code> which opens a writable database
is wrapped as <code>quartz_open_writable</code>.
<li> <code>Xapian::InMemory::open()</code> is wrapped as <code>inmemory_open()</code>
<li> <code>Xapian::Remote::open()</code> is wrapped as <code>remote_open()</code> (only
the TCP version is currently wrapped, the "program" version isn't).
</ul>

<h2>Constants</h2>

<p>
   Constants are wrapped with the Xapian namespace removed, so
   <code>Xapian::DB_CREATE_OR_OPEN</code> is available as
   <code>DB_CREATE_OR_OPEN</code>, <code>Xapian::Query::OP_OR</code> is
   available as <code>Query_OP_OR</code>, and so on.
</p>

<h2>Enquire</h2>

<p>
   There is an additional method <code>get_matching_terms()</code> which takes
   an MSetIterator and returns a list of terms in the current query which
   match the document given by that iterator. This may be slightly
   more convenient than using the TermIterator directly.
</p>

<address>
Last updated $Date$
</address>
</body>
</html>
