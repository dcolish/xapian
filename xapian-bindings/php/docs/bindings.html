<html><head><title>PHP bindings for Xapian</title></head>
<body>
<h1>PHP bindings for Xapian</h1>

<p>
The PHP bindings for Xapian are packaged in the <code>xapian.so</code>
extension, and largely follow the C++ API.  This document lists the differences
and additions. PHP strings and arrays, etc., are converted automatically
in the bindings, so generally it should just work as expected.
</p>

<p>
The <code>examples</code> subdirectory contains examples showing how to use the
PHP bindings based on the simple examples from <code>xapian-examples</code>:
<a href="examples/simpleindex.php">simpleindex.php</a>,
<a href="examples/simplesearch.php">simplesearch.php</a>.
</p>

<h2>Installation</h2>

<p>
Assuming you have a suitable version of PHP installed (PHP4 or PHP5), running
configure will automatically enable the PHP bindings, and
<code>make install</code> will install the extension shared library in
the location reported by <code>php-config --extension-dir</code>.
</p>

<p>
Check that php.ini has a line like <code>extension_dir =
"<i>&lt;location reported by php-config --extension-dir&gt;</i>"</code>.
</p>

<p>
Then add this line to php.ini: <code>extension = xapian.so</code> (or
whatever the library is called - not all UNIX systems use <code>.so</code>
as the extension, and MS Windows uses <code>.dll</code>).
</p>

<p>
Depending how PHP is setup, you may need to restart the webserver for this
change to take effect.
</p>

<p>
Alternatively you can add the following line to the start of your PHP scripts:
<code>dl('xapian.so');</code>
</p>

<h2>Exceptions</h2>

<p>
In general, a PHP fatal error is triggered on a C++ exception being thrown in
the library.  We acknowledge this is awful, and needs to be fixed to work
in a more useful way - the current plan is to rework the core library to not
throw exceptions but this is not at trivial job.
</p>

<h2>Object orientation</h2>

<p>
The PHP bindings do not currently use a PHP object oriented style
(unfortunately SWIG's support for this is currently buggy for PHP4 and
unimplemented for PHP5). In order to construct an object, use
<code>$object = new_ClassName(...);</code>.  You can't explicitly destroy
an object from PHP, but <code>unset($object);</code> or <code>$object = Null;</code> will cause the destructor
to be called.
Invoke methods on an object using <code>ClassName_method_name($object, ...)</code>.
</p>

<h2>Iterators</h2>

<p>
   All iterators support <code>next()</code> and <code>equals()</code> methods
   to move through and test iterators (as for all language bindings).
   MSetIterator and ESetIterator also support <code>prev()</code>.
</p>

<h2>Iterator dereferencing</h2>

<p>
   C++ iterators are often dereferenced to get information, eg
   <code>(*it)</code>. With PHP these are all mapped to named methods, as
   follows:
</p>

<table title="Iterator deferencing methods">
<thead><td>Iterator</td><td>Dereferencing method</td></thead>
<tr><td>PositionIterator</td>	<td><code>get_termpos()</code></td></tr>
<tr><td>PostingIterator</td>	<td><code>get_docid()</code></td></tr>
<tr><td>TermIterator</td>	<td><code>get_term()</code></td></tr>
<tr><td>ValueIterator</td>	<td><code>get_value()</code></td></tr>
<tr><td>MSetIterator</td>	<td><code>get_docid()</code></td></tr>
<tr><td>ESetIterator</td>	<td><code>get_termname()</code></td></tr>
</table>

<p>
   Other methods, such as <code>MSetIterator.get_document()</code>, are
   available unchanged.
</p>
   
<h2>MSet</h2>

<p>
   MSet objects have some additional methods to simplify access (these
   work using the C++ array dereferencing):
</p>

<table title="MSet additional methods">
<thead><td>Method name</td><td>Explanation</td></thead>
<tr><td><code>get_hit(index)</code></td><td>returns MSetIterator at index</td></tr>
<tr><td><code>get_document_percentage(index)</code></td><td><code>convert_to_percent(get_hit(index))</code></td></tr>
<tr><td><code>get_document(index)</code></td><td><code>get_hit(index).get_document()</code></td></tr>
<tr><td><code>get_document_id(index)</code></td><td><code>get_hit(index).get_docid()</code></td></tr>
</table>

<h2>Database Factory Functions</h2>

<ul>
<li> <code>Xapian::Auto::open_stub(<i>file</i>)</code> is wrapped as <code>open_stub(<i>file</i>)</code>
<li> <code>Xapian::Quartz::open(...)</code> is wrapped as <code>quartz_open(...)</code>
<li> <code>Xapian::InMemory::open()</code> is wrapped as <code>inmemory_open()</code>
<li> <code>Xapian::Remote::open()</code> is wrapped as <code>remote_open()</code> (only
the TCP version is currently wrapped, the "program" version isn't).
</ul>

<h2>Constants</h2>

<p>
   Constants are wrapped with the Xapian namespace removed, so
   <code>Xapian::DB_CREATE_OR_OPEN</code> is available as
   <code>DB_CREATE_OR_OPEN</code>, <code>Xapian::Query::OP_OR</code> is
   available as <code>Query_OP_OR</code>, and so on.
</p>

<h2>Query</h2>

<p>
   In C++ there's a Xapian::Query constructor which takes a query operator and
   start/end iterators specifying a number of terms or queries, plus an optional
   parameter.  In PHP, this is wrapped to accept an array listing the terms
   and/or queries (you can specify a mixture of terms and queries if you wish)
   For example:
</p>

<pre>
   subq = new_Query(Query_OP_AND, "hello", "world");
   q = new_Query(xapian.Query.OP_AND, array(subq, "foo", new_Query("bar", 2)));
</pre>

<h2>Enquire</h2>

<p>
   There is an additional method <code>get_matching_terms()</code> which takes
   an MSetIterator and returns a list of terms in the current query which
   match the document given by that iterator.  You may find this
   more convenient than using the TermIterator directly.
</p>

<address>
Last updated $Date$
</address>
</body>
</html>
