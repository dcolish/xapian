<html><head><title>Python bindings for Xapian</title></head>
<body>
<h1>Python bindings for Xapian</h1>

<p>
The Python bindings for Xapian are packaged in the <code>xapian</code> module,
and largely follow the C++ API, with the following differences and
additions. Python strings and lists, etc., are converted automatically
in the bindings, so generally it should just work as expected.
</p>

<h2>Exceptions</h2>

<p>
   Exceptions are thrown as SWIG exceptions instead of Xapian
   exceptions. This isn't done well at the moment; in future we will
   throw wrapped Xapian exceptions. For now, it's probably easier to
   catch all exceptions and try to take appropriate action based on
   their associated string.
</p>

<h2>Iterators</h2>

<p>
   All iterators support <code>next()</code> and <code>equals()</code> methods
   to move through and test iterators (as for all language bindings).
   MSetIterator and ESetIterator also support <code>prev()</code>.
   Python-wrapped iterators also support direct comparison, so something like:
</p>

<pre>
   m=mset.begin()
   while m!=mset.end():
     # do something
     m.next()
</pre>

<h2>Iterator dereferencing</h2>

<p>
   C++ iterators are often dereferenced to get information, eg
   <code>(*it)</code>. With Python these are all mapped to named methods, as
   follows:
</p>

<table title='Iterator deferencing methods'>
<thead><td>Iterator</td><td>Dereferencing method</td></thead>
<tr><td>PositionIterator</td>	<td><code>get_termpos()</code></td></tr>
<tr><td>PostingIterator</td>	<td><code>get_docid()</code></td></tr>
<tr><td>TermIterator</td>	<td><code>get_term()</code></td></tr>
<tr><td>ValueIterator</td>	<td><code>get_value()</code></td></tr>
<tr><td>MSetIterator</td>	<td><code>get_docid()</code></td></tr>
<tr><td>ESetIterator</td>	<td><code>get_termname()</code></td></tr>
</table>

<p>
   Other methods, such as <code>MSetIterator.get_document()</code>, are
   available unchanged.
</p>
   
<h2>MSet</h2>

<p>
   MSet objects have some additional methods to simplify access (these
   work using the C++ array dereferencing):
</p>

<table title='MSet additional methods'>
<thead><td>Method name</td><td>Explanation</td></thead>
<tr><td><code>get_hit(index)</code></td><td>returns MSetIterator at index</td></tr>
<tr><td><code>get_document_percentage(index)</code></td><td><code>convert_to_percent(get_hit(index))</code></td></tr>
<tr><td><code>get_document(index)</code></td><td><code>get_hit(index).get_document()</code></td></tr>
<tr><td><code>get_document_id(index)</code></td><td><code>get_hit(index).get_docid()</code></td></tr>
</table>

<p>
Additionally, the MSet has a property, <code>mset.items</code>, which returns a list of tuples representing the MSet; this may be more convenient than using the MSetIterator. The members of the tuple are as follows.
</p>

<table title='MSet.items member members'>
<thead><td>Index</td><td>Contents</td></thead>
<tr><td><code>xapian.MSET_DID</code></td><td>Document id</td></tr>
<tr><td><code>xapian.MSET_WT</code></td><td>Weight</td></tr>
<tr><td><code>xapian.MSET_RANK</code></td><td>Rank</td></tr>
<tr><td><code>xapian.MSET_PERCENT</code></td><td>Percentage weight</td></tr>
</table>

<p>
Two MSet objects are equal if they have the same number and maximum possible number of members, and if every document member of the first MSet exists at the same index in the second MSet, with the same weight.
</p>

<h2>ESet</h2>

<p>
The ESet has a property, <code>eset.items</code>, which returns a list of tuples representing the ESet; this may be more convenient than using the ESetIterator. The members of the tuple are as follows.
</p>

<table title='ESet.items member members'>
<thead><td>Index</td><td>Contents</td></thead>
<tr><td><code>xapian.ESET_TNAME</code></td><td>Term name</td></tr>
<tr><td><code>xapian.ESET_WT</code></td><td>Weight</td></tr>
</table>

<h2>Xapian::Auto</h2>

<p>
   Functions in <code>Xapian::Auto</code> are mapped directly into the
   <code>xapian</code> module (so <code>Xapian::Auto::open()</code> becomes
   <code>xapian.open()</code>, for
   instance).
</p>

<h2>Xapian::Quartz::open, Xapian::InMemory::open, and Xapian::Remote::open</h2>

<ul>
<li> <code>Xapian::Quartz::open()</code> is wrapped as <code>quartz_open()</code>
<li> <code>Xapian::InMemory::open()</code> is wrapped as <code>inmemory_open()</code>
<li> <code>Xapian::Remote::open()</code> is wrapped as <code>remote_open()</code> (only
the TCP version is currently wrapped, the "program" version isn't).
</ul>

<h2>Query</h2>

<p>
   Please note that although the source code for the bindings
   indicates that there's another constructor to <code>xapian.Query</code> that
   should be able to take a query operator, a list of Query objects,
   and an optional window, this doesn't actually work in Python at the
   moment due to the way SWIG overloading works.  However, you can pass a
   query operator, a list of strings, and an optional window.
</p>

<h2>Enquire</h2>

<p>
   There is an additional method <code>get_matching_terms()</code> which takes
   an MSetIterator and returns a list of terms in the current query which
   match the document given by that iterator. This may be slightly
   more convenient than using the TermIterator directly.
</p>

<h2>MatchDecider</h2>

<p>
Custom MatchDeciders can be created in Python; simply subclass
xapian.MatchDecider, ensure you call the super-constructor, and define a
__call__ method that will do the work. The simplest example (which does nothing
useful) would be as follows.
</p>

<pre>
class mymatcher(xapian.MatchDecider):
  def __init__(self):
    xapian.MatchDecider.__init__(self)

  def __call__(self, doc):
    return 1
</pre>

<p>
The <code>examples</code> subdirectory contains examples showing how to use the
Python bindings based on the simple examples from <code>xapian-examples</code>:
<a href="examples/simpleindex.py">simpleindex.py</a>,
<a href="examples/simplesearch.py">simplesearch.py</a>,
<a href="examples/simpleexpand.py">simpleexpand.py</a>.
There's also 
<a href="examples/simplematchdecider.py">simplematchdecider.py</a>
which shows how to define a MatchDecider in Python.
</p>

<address>
Last updated $Date$
</address>
</body>
</html>
