\title Xapian QueryServer

\C{intro} QueryServer

\S0{whatfor} What is QueryServer for?

QueryServer is intended to provide a simple way to use Xapian from a wide
variety of scripting languages, without having to implement (or compile)
special extensions for that language.  As long as the language supports use of
UNIX sockets, a simple communication layer can be implemented without the need
to compile extension modules for the language.

QueryServer could easily be extended to work using TCP sockets, or any similar
messaging system, for platforms in which UNIX sockets are not available.

The implementation of the QueryServer aims mainly for simplicity, rather than
maximum possible performance.  However, it should be perfectly suitable for low
to medium load environments.

\C{server} Running the server

\S0{compiling} Compiling the server

QueryServer uses the same autotools setup that the rest of Xapian uses.  This means that compilation is a simple matter of running:

\c $ ./configure
\e   bbbbbbbbbbb
\c $ make
\e   bbbb
\c $ make install
\e   bbbbbbbbbbbb

You may wish to supply additional parameters to the configure statement.  In
particular the \c{\-\-prefix} parameter is useful to determine where to install
the server.

\S0{running} Invoking the server

The server is invoked with two parameters.

\b  The first parameter gives the location of a socket that the queryserver
    will use to listen for requests.  Note that this is a location in the
    filesystem: there must not be any file in the given location when the
    queryserver is started, and the queryserver will remove the socket when it
    exits.

\lcont{
    Note also that the socket may be created with global read and write
    access.  You should read the documentation of your operating system
    to determine how access to a UNIX socket is controlled.  For example,
    on Linux, permissions on the directory the socket is in may be used to
    control access to the socket, but this is not true on many BSD-derived
    systems.

    The queryserver itself performs \e{no} authentication whatsoever.
}

\b  The second parameter gives the location of a directory holding the Xapian
    databases to be searched.  No databases outside the directory, or in
    subdirectories of this directory, will be accessible via the queryserver.
    However, symbolic links inside the directory will be followed, whether
    they point elsewhere in the directory, or elsewhere on the filesystem.

For example the following command runs the queryserver, listening to the socket
/tmp/socket, and allowing access to databases stored in the directory
/var/lib/omega/data/

\c $ ./queryserver /tmp/socket /var/lib/omega/data
\e   bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb

\S1{stopping} Stopping the server

The queryserver should be stopped by sending it a \c{SIG_TERM} signal.  For
this reason, it is desirable to keep track of the process ID of the server.
Many systems provide tools to assist with this task - for example, the
\c{start\-stop\-daemon} tool on Debian systems.

\S0{howworks} How the server works

Once invoked, the server starts listening to the socket for connections from
clients.  When a client connects, the server immediately forks a new process
to deal with the request, and then continues listening for new connections.
This allows the server to deal with many requests simultaneously.

Note that there is no upper limit on the number of concurrent requests other
than any limits imposed by the operating systems on the number of child
processes of the server.  This means that the server may not deal with extreme
loads very well.  This design of server is suitable for low to medium loads
only.

Also, note that the server does not maintain a pool of open databases, and
share them between the subprocesses dealing with requests.  Instead, each new
request causes the appropriate database to be opened, used, and then closed at
the end of the request.  This is less efficient than if database connections
were to be cached in some way, but is extremely simple to implement, and does
have the small benefit that there is no need to deal with
DatabaseModifiedErrors (assuming that the database modification transactions
take longer than the maximum time taken to execute a query).

\C{clients} Clients

Currently only a PHP4 client class is available.  However, it should be a
simple task to write a client for most other scripting languages.

\S0{client-php} PHP4 client

The PHP4 client consists of a single PHP file,
\q{\cw{xapian\-queryclient.php}}, which should be included from your PHP
project.  The file defines three classes which are used to compose a query, and
retrieve the results.

\S1{client-php-enquiry} The \cw{Enquiry} class

The \c{Enquiry} class is used to build up a query, and then to send that query
to the server and retrieve the results.

\dt \c{Enquiry::Enquiry($socket)}

\dd This is the constructor.  It takes one parameter, which is the location of the socket to be used to talk to \c{xapian\-queryserver}.

\dt \c{Enquiry::setDbName($dbname)}

\dd This function sets the name of the database which the query should be
    evaluated against.  The database name may not include any \q{\cw{/}} or
    \q{\cw{..}} character sequences, since the server will reject any such
    names for security reasons.

\dt \c{Enquiry::setQuery($query)}

\dd This function sets the query which will be evaluated.  The query will be
    passed to the server verbatim, and will be parsed and evaluated by the
    server.

\dt \c{Enquiry::addFilter($prefix, $filter)}

\dd This function adds a filter to the query.  The \c{$prefix} parameter
    specifies the category of the filter, and the \c{$filter} parameter
    specifies the value that must be present in that category for the filter
    to pass.  Note that the \c{$filter} parameter is not parsed at all - in
    particular it is not split into multiple terms.  For the filter to match,
    the filter term must exist verbatim in the database.

    \lcont{
    Multiple filters may be applied to a query.  They combine such that a
    document will be returned only if it matches at least one filter in
    each category.

    For example, suppose a database was created using the prefix \q{\cw{T}} to
    store a filetype field, and \q{\cw{P}} to store a protocol field, and
    three filters were added as follows:

    \c $enquiry->addFilter("T", "mp3");
    \c $enquiry->addFilter("T", "ogg");
    \c $enquiry->addFilter("P", "http");

    The combined filter would match documents whose type field was \c{mp3} OR
    \c{ogg}, but only if the protocol field was \c{http}.

    Filters have no effect on the ordering of the results of a query.
    }

\dt \c{Enquiry::perform($firstdoc, $maxitems)}

\dd This function causes the query which has been built up in the \c{Enquiry}
    object to be sent over the socket, evaluated against the database named
    by \c{Enquiry::setDbName()}, and returns the results as a \c{Result}
    object (see \k{client-php-result}).

\S1{client-php-result} The \cw{Result} class

The \c{Result} class, returned by the Enquiry::perform() method, holds a set
of results of a query, together with some statistics about the results.

Note that due to optimisations and shortcuts performed by Xapian, the exact
number of documents matched by the query may not be known, so Xapian provides
an estimate of the number of matching documents, together with lower and upper
bounds on the number of matching documents.  The estimate will always lie
within the bounds.  If and only if the upper bound is equal to the lower bound,
the estimate may be relied on to be correct.

\dt \c{Result::firstitem}

\dd This member holds the rank of the first hit returned.

\dt \c{Result::items}

\dd This member holds the number of hits stored in the result object.

\dt \c{Result::matches_lower_bound}

\dd This member holds a lower bound on the number of documents matched by the
    query.

\dt \c{Result::matches_estimated}

\dd This member holds an estimate of the number of documents matched by the
    query.

\dt \c{Result::matches_upper_bound}

\dd This member holds an upper bound on the number of documents matched by the
    query.

\dt \c{Result::hits}

\dd This member is an array of \c{Hit} objects (see \k{client-php-hits}).
    Note that this array is keyed on the rank of the hits - so if:

    \lcont{
    \c $result\_=\_Enquire::perform(5,10)
    
    was called to generate the \c{$result} object (and there were sufficient
    matching documents), \c{$result\->hits[5]} to \c{$result\->hits[14]} would
    be valid.
    }

\S1{client-php-hits} The \cw{Hit} class

The \c{Hit} class holds an individual document resulting from a query.

\dt \c{Hit::rank}

\dd This member holds the rank of the hit.  This starts at 0: \e{ie}, the 
    top hit resulting from a query has a rank of 0.

\dt \c{Hit::percent}

\dd This member holds the percentage score of the hit.

\dt \c{Hit::data}

\dd This member is an object holding the data stored in the Xapian database
    for the hit.  The data is assumed to have been held in the format generated
    by the \c{scriptindex}, or \c{omindex} indexers associated with the
    \c{omega} Xapian application.  This format is a set of lines, one per
    field, of the form:

    \lcont{
    \c fieldname=fielddata
    \e iiiiiiiiibiiiiiiiii
    }

\S1{client-php-example} Example

The following example connects to a socket at
\q{\cw{/tmp/xapian\-queryserver\-socket}}, runs the query \q{\cw{query}} on the
database called \q{\cw{db}}, retrieves the top 10 results, and displays the
rank and percentage score of each result.  In addition, the data stored
in each document is assumed to be of the format:

\c type=<type>
\c id=<id>

and this data is parsed and displayed.

\c <?
\c include('xapian-queryclient.php');
\c 
\c $enquiry = new Enquiry('/tmp/xapian-queryserver-socket');
\c 
\c $enquiry->setDbName('db');
\c $enquiry->setQuery('query');
\c $result = $enquiry->perform(0, 10);
\c 
\c if ($result != null) {
\c 
\c   print "First item returned is of rank: " .
\c           $result->firstitem . " <br>\n";
\c   print "Number of items returned is: " .
\c           $result->items . " <br>\n";
\c   print "There were at least: " .
\c           $result->matches_lower_bound . " hits.<br>\n";
\c   print "There were approximately: " .
\c           $result->matches_estimated . " hits.<br>\n";
\c   print "There were no more than: " .
\c           $result->matches_upper_bound . " hits.<br>\n";
\c
\c   foreach ($result->hits as $hit) {
\c     print "Hit at rank " . $hit->rank .
\c           ", score " . $hit->percent . "%" .
\c           " is " . $hit->data->type . "_" . $hit->data->id .
\c           "<br>\n";
\c   }
\c }
\c ?>


\A{protocol} Communications protocol

The communications protocol is intentionally kept extremely simple.  A
conversation consists of exactly two messages, and is always initiated by the
client.

Much of the data passed over the protocol is Base64 encoded - this avoids
problems with communications channels dealing badly with certain character
codes.

\S0{protocol-request} Client request

FIXME - document.

\S0{protocol-response} Server response

FIXME - document.
