// cvsmine.C
//
// (c) 2001 Amir Michail (amir@users.sourceforge.net)

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.

//
// Usage:  cvsmine code-path package1.db package2.db ...
//
//                     => processes package.db and package.offset generated by cvsmap
//                     => builds a directory 'package' with quartz database inside
//
//  Generates package1.count package2.count ...

/***********

KWord seems easiest to test.

Some queries to try:

    *  Normal editing and formatting (fonts, colors, attributes, super/sub script, etc.)
    * Paragraph styles (alignment, spacings, indentations, default font, etc.)
    * Stylist to edit, add, remove and update paragraph styles. There are predefined ones like Standard Text, Header 1 - 3, Bullet List, Ordered List, etc.
    * Frame orientation (for DTP you can insert multiple frames and connect/disconnect some of them, which means defining a text flow)
    * Multiple columns
    * Inserting Tables
    * Inserting Pictures
    * Embedding other KOffice parts
    * In-Place formula editor
    * Letting text of one (text)frame run around another frame(s)
    * Headers/Footers
    * Endnotes
    * Numbering of chapters
    * Automatic generation of Table of Contents
    * Inserting Predefined variables (Date, Time, Page Number, etc.)
    * Inserting and defining custom variables
    * Generating serial letters
    * Autocorrection
    * Spell checking (uses ISpell)
    * Document structure viewer
    * Templates
    * Creating own Templates


************/






#warning "requires ctags from http://ctags.sourceforge.net/"
#warning "should use CVSDATA" 
#warning "should generate unique file for tags"
#warning "ctags contains inheritance information"

// ctags options
//  want classes
//  want public/protected member *functions*
//  ignore inheritance for now...

// -R (recursive)
// --c-types=cfsuAC 
// --kind-long=yes (verbose tag descriptions)
// from this, ignore all entries with access:private

#define GRANULARITY "line"
#define USE_STOP_LIST false

// /tmp is small, so we use /home/amichail/temp
#define CTAGS_FLAGS "-a -R --c-types=cfsuAC --kind-long=yes -f/home/amichail/temp/tags"


//
// Reasoning for looking at symbols in the most recent copy and
// not on a commit by commit basis in previous versions:
//
//  code symbols change over time but not the domain concepts
//  we describe them by in comments
//

// if in file mode, this is the minimum # files
// 15 is reasonable but takes a while


#define MAX_LINES 500000000
//#define MAX_LINES 500000
//#define MAX_LINES 50000000

// should be 5 for local/global
#define MIN_SUPP 3 

// should be 2.0
#define MIN_SURPRISE 0.0

#define SKIP_FUNCTIONS true


// if true, counts files.
// however, still requires line pairing of comment term, code symbol

// app count not exactly correct because files not handled
// in order of app exactly but also by order of extension
// (e.g., .h, .cc, .C, .cpp, etc.), so some apps may contribute
// 2 or 3 to the count


#include <om/om.h>
#include <fstream.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <math.h>
#include <algorithm>

#include "util.h"


/**

string extractApp( const string& s ) {

  if ( s == "" ) {
    return s;
  }

  string sub = string( s, 0, s.find("/") );
  
  // main directories same, so perhaps check subdirectory
  if ( sub == "kdenetwork" ||
       sub == "kmusic" ||
       sub == "koffice" ||
       sub == "kdebase" ||
       sub == "kdeutils" ||
       sub == "kdegraphics" ||
       sub == "kdemultimedia" ||
       sub == "kdenonbeta" ||
       sub == "kdepim" ||
       sub == "kdesdk" ||
       sub == "kdesupport" ||
       sub == "kdetoys" ||
       sub == "kdegames" ||
       sub == "kdeutils" ||
       sub == "kdelibs" || 
       sub == "kdeadmin" ) {

    string x = string( s, s.find("/")+1, s.length() );
    x = string( x, 0, x.find("/") );
    return x;
  } 

  return sub;

}

**/

void readTags( const string& fn, set<string>& S ) {
  ifstream in(fn.c_str());
  assert (in);
  string s;
  while ( getline( in, s ) ) {
    if ( s == "" || s[0] == '!' ) {
      continue;
    }
    //    cerr << "FOUND -" << s << "-" << endl;
    bool function = (s.find("\tfunction\t") != -1);
    string symbol = s.substr( 0, s.find("\t") );
    if ( symbol.find("::") != -1 ) {
      symbol = symbol.substr( symbol.find("::")+2 );
    }
    if ( function ) {
      symbol += "()";
    }
    S.insert(symbol);
    cerr << "** found symbol -" << symbol << "-" << endl;
  } 
  in.close();
}

int main(int argc, char *argv[]) {

  if(argc < 3) {
    cout << "Usage:  " << argv[0] <<
      " <code path> <path to database>" << endl;
    exit(1);
  }

  string codepath = argv[1];
  if ( codepath[codepath.length()-1] == '/' ) {
    codepath = string(codepath,0, codepath.length()-1);
  }
  cerr << "Code path:  -" << codepath << "-" << endl;

  system("rm -f /home/amichail/temp/tags"); 

  for (int i = 2; i < argc; i++ ) {

    string package = argv[i];

    int p = package.find(".db");
    if ( p == -1 ) {
      cerr << "Must include .db extension in package(s)." << endl;
      exit(1);
    }

    package = string(package, 0, p);

    cerr << "package -" << package << "-" << endl;

    string file_db = package + ".db";
    string file_offset = package +".offset";

    map<string, int> symbol_count;
    map<string, int> term_count;
    //    set<string> apps;

    int lines_read = 0;

    try {

      { // pass 1
	cerr << "PASS 1" << endl;
	Lines lines( codepath, package, file_db, file_offset, GRANULARITY, USE_STOP_LIST ); // file level granularity
	lines_read = 0;
	string prev_file = "";
	while ( lines.ReadNextLine() && lines_read < MAX_LINES ) {

	  if ( lines.currentFile() != prev_file ) {
	    // run ctags on file
	    string cmd = string("ctags ") + string(CTAGS_FLAGS) + " " + codepath+"/"+lines.currentFile();
	    //	    cerr << "** invoking " << cmd << endl;
	    system(cmd.c_str());
	    prev_file = lines.currentFile();
	  }

	  set<string> terms = lines.getCommentTerms();
	  set<string> symbols = lines.getCodeSymbols();

	  //	  string app = extractApp( lines.currentFile() );
	  //	  apps.insert(app);

	  for( set<string>::iterator i = terms.begin(); i != terms.end(); i++ ) {
	      term_count[*i]++;
	  }

	  for( set<string>::iterator i = symbols.begin(); i != symbols.end(); i++ ) {
	    symbol_count[*i]++;
	  }
	  lines_read++;
	} // while
      }





      set<string> defined_symbols;
      readTags( "/home/amichail/temp/tags", defined_symbols );







      map< pair<string, string>, int > rule_support;
      
      { // pass 2
	cerr << "PASS 2" << endl;
	Lines lines( codepath, package, file_db, file_offset, GRANULARITY, USE_STOP_LIST );
	
	lines_read = 0;

	while ( lines.ReadNextLine() && lines_read < MAX_LINES ) {

	  set<string> terms = lines.getCommentTerms();
	  set<string> symbols = lines.getCodeSymbols();
	  
	  //	  string app = extractApp( lines.currentFile() );


	  for( set<string>::iterator t = terms.begin(); t != terms.end(); t++ ) {
	    if ( term_count[*t] >= MIN_SUPP ) {
	      for ( set<string>::iterator s = symbols.begin(); s != symbols.end(); s++ ) {

		if ( defined_symbols.find(*s) == defined_symbols.end() ) {
		  continue;
		}

		if ( symbol_count[*s] >= MIN_SUPP ) {

		  rule_support[ make_pair( *t, *s ) ]++;

		}
	      }
	    }

	  }
	  lines_read++;	  
	} // while
      }

cerr << "*** lines read " << lines_read << endl;


      /////// we have term_count, symbol_count, rule_support (term=>symbol)

      string prev_term = "";
      map< double, set<string> > results;
      // print out rules
      for ( map< pair<string, string>, int >::iterator r = rule_support.begin(); r != rule_support.end(); r++ ) {
	int supp = (r->second);
	string ant = (r->first).first;
	string con = (r->first).second;

	if ( SKIP_FUNCTIONS && con.find("()") != -1 ) {
	  continue;
	}

	if ( ant != prev_term ) { 
	  // print out results in sorted order
	  cerr << "RANKED ********* " << prev_term << endl;
	  for( map<double, set<string> >::iterator i = results.begin(); i != results.end(); i++ ) {
	    set<string> S = i->second;
	    for ( set<string>::iterator s = S.begin(); s != S.end(); s++ ) {
	      cerr << "RANKED " << *s << " product = " << -(i->first) << endl;
	    }
	  }
	  prev_term = ant;
	  results.clear();
	}

	
	if ( supp >= MIN_SUPP ) {

	  double con_conf = 100.0*(double)symbol_count[con] / (double)lines_read;

	  double conf = 100.0*(double)supp / (double)term_count[ant];

	  double surprise = (conf / con_conf ) * (double)supp; // log(1.1+(double)supp);

	  if ( surprise >= MIN_SURPRISE ) {
	    cerr << ant << " => " << con << " has conf " << conf << " and support " << supp << " with con conf " << con_conf << endl;
#warning "uses product of surprise and supp"	   
	    results[-surprise].insert(ant + " => " + con);
	  }
	}
      }
      cerr << "RANKED ********* " << prev_term << endl;
      for( map<double, set<string> >::iterator i = results.begin(); i != results.end(); i++ ) {
	set<string> S = i->second;
	for ( set<string>::iterator s = S.begin(); s != S.end(); s++ ) {
	  cerr << "RANKED " << *s << " product = " << -(i->first) << endl;
	}
      }



    }
    catch(OmError & error) {
      cerr << "OMSEE Exception: " << error.get_msg() << endl;
    } 

  }
  
}
