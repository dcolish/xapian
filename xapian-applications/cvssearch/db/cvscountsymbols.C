// cvscountsymbols.C
//
// (c) 2001 Amir Michail (amir@users.sourceforge.net)

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.

//
// Usage:  cvscountsymbols code-path package1.db package2.db ...
//
//                     => processes package.db and package.offset generated by cvsmap
//                     => builds a directory 'package' with quartz database inside
//
//  Generates package1.count package2.count ...

#include <om/om.h>
#include <db_cxx.h>
#include <fstream.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <list>
#include <map>

#include "util.h"

void load_offset_file(  string& file_offset, vector<string>& files, vector<string>& offsets ) {

  cerr << "... reading " << file_offset << endl;
  
  ifstream in(file_offset.c_str());
  assert(in);

  while (!in.eof()) {
    string file;
    string offset;
    in >> file;
    if ( file == "" ) {
      break;
    }
    in >> offset;
    files.push_back( file ); 
    offsets.push_back( offset ); 
  }
  in.close();
  
}

bool blankChar(char c) {
  return ( c == ' ' || c == '\t' );
}

bool okFirstChar(char c) {
  return ((c >= 'a' && c <='z') || (c >='A' && c <= 'Z' ) || c == '_');
}

bool okSubChar(char c) {
  return (okFirstChar(c) || (c >= '0' && c <= '9' ));
}

set<string> countWords( const string& s, map<string, int>& symbol_count ) {
  set<string> symbols;

  string current = "";
  for ( string::const_iterator i = s.begin(); i != s.end(); i++ ) {
    char c = *i;
    
    if ( blankChar(c) ) {
      continue;
    }

    if ( current == "" ) {
      if ( okFirstChar(c) ) {
	current = c;
      }
    } else {
      // already started something
      if (! okSubChar(c) ) {
	if ( c == '(' ) {
	  current += "()";
	  //cerr << "... found " << current << endl;
	  symbols.insert(current);
	  current = "";
	} else {
	  // identifier ended
	  //cerr << "... found " << current << endl;
	  symbols.insert(current);
	  current = "";
	}
      } else {
	current += c;
      }
    }
  }
  if ( current != "" ) {
    //    cerr << "...found " << current << endl;
    symbols.insert(current);
  }
  return symbols;
}

void processFile( string& path, string& fn, map<string, int>& symbol_count) {
  ifstream in((path+"/"+fn).c_str());
  assert(in);
  string s;
  while( getline( in, s ) ) {
    //    cerr << "Found line -" << s << "-" << endl;
    set<string> symbols = countWords( s, symbol_count );
    for( set<string>::iterator i = symbols.begin(); i != symbols.end(); i++ ) {
      symbol_count[*i] ++;
    }
  }
  in.close();
}

int main(int argc, char *argv[]) {

  if(argc < 3) {
    cout << "Usage:  " << argv[0] <<
      " <code path> <path to database>" << endl;
    exit(1);
  }

  string codepath = argv[1];
  if ( codepath[codepath.length()-1] == '/' ) {
    codepath = string(codepath,0, codepath.length()-1);
  }
  cerr << "Code path:  -" << codepath << "-" << endl;

  for (int i = 2; i < argc; i++ ) {

  string package = argv[i];

  int p = package.find(".db");
  if ( p == -1 ) {
	cerr << "Must include .db extension in package(s)." << endl;
	exit(1);
  }

  package = string(package, 0, p);

  cerr << "package -" << package << "-" << endl;

  // remove count file if it exists already

  cerr << "... removing count file " << package << " (if it already exists)" << endl;
  system( ("rm -rf " + package + ".count").c_str() );

  string file_db = package + ".db";
  string file_offset = package +".offset";

  vector<string> files;
  vector<string> offsets;

  map<string, int> symbol_count;

  try {

    load_offset_file( file_offset, files, offsets );

    for( vector<string>::iterator f = files.begin(); f != files.end(); f++ ) {
      cerr << "File " << (*f) << endl;
      processFile( codepath, *f, symbol_count );
    }

    /////// write out symbol counts
    cerr << "...writing out results" << endl;
    Db db(0, 0);
    db.open((package+".count").c_str(), 0, DB_HASH, DB_CREATE, 0 );
    for( map<string, int>::iterator i = symbol_count.begin(); i != symbol_count.end(); i++ ) {
      string symbol = i->first;
      static char str[4096];
      sprintf(str, "%d", i->second);
      string num = str;
      Dbt key( (void*) symbol.c_str(),
               symbol.length()+1 ); // include 0 at end
      Dbt data( (void*) num.c_str(),
		num.length()+1 ); // include 0 at end
      db.put( 0, &key, &data, DB_NOOVERWRITE );           
    }
    db.close(0);
    cerr << "Done!" << endl;

  }

  catch (DbException& e ) {
    cerr << "SleepyCat Exception: " << e.what() << endl;
  }

  }
  
}
