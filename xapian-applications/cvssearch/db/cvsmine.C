// cvsmine.C
//
// (c) 2001 Amir Michail (amir@users.sourceforge.net)

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.

//
// Usage:  cvsmine code-path package1.db package2.db ...
//
//                     => processes package.db and package.offset generated by cvsmap
//                     => builds a directory 'package' with quartz database inside
//
//  Generates package1.count package2.count ...


// if in file mode, this is the minimum # files
// 15 is reasonable but takes a while

// for app, use 5
#define MIN_SUPP 5 

// should be 2.0
#define MIN_SURPRISE 0.0

// if true, counts files.
// however, still requires line pairing of comment term, code symbol

// any change in subdirectory counts as app change
#define COUNT_APPS true

#define COUNT_FUNCTION_SYMBOLS_ONLY 1


#include <om/om.h>
#include <db_cxx.h>
#include <fstream.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <list>
#include <map>

#include "util.h"


bool isSame( const string& s, const string& t ) {
  //  cerr << "isSame " << s << " and " << t << endl;
  if ( s == "" || t== "" ) {
    assert( s != t );
    return false;
  }

  string sub1 = string( s, 0, s.find("/") );
  string sub2 = string( t, 0, s.find("/") );
  
  //  cerr << "sub1 " << sub1 << endl;
  //  cerr << "sub2 " << sub2 << endl;

  if ( sub1 != sub2 ) {
    return false;
  }

  // main directories same, so perhaps check subdirectory
  if ( sub1 == "kdenetwork" ||
       sub1 == "kmusic" ||
       sub1 == "koffice" ||
       sub1 == "kdebase" ||
       sub1 == "kdeutils" ||
       sub1 == "kdegraphics" ||
       sub1 == "kdemultimedia" ||
       sub1 == "kdenonbeta" ||
       sub1 == "kdepim" ||
       sub1 == "kdesdk" ||
       sub1 == "kdesupport" ||
       sub1 == "kdetoys" ||
       sub1 == "kdegames" ||
       sub1 == "kdeutils" ||
       sub1 == "kdelibs" || 
       sub1 == "kdeadmin" ) {
    //    cerr << "special case" << endl;
    string x = string( s, s.find("/")+1, s.length() );
    x = string( x, 0, x.find("/") );
    string y = string( t, t.find("/")+1, t.length() );
    y = string( y, 0, y.find("/") );
    //    cerr << "x = " << x << endl;
    //    cerr << "y = " << y << endl;
    return x == y;
  }
  return sub1 == sub2;
}

int main(int argc, char *argv[]) {

  if(argc < 3) {
    cout << "Usage:  " << argv[0] <<
      " <code path> <path to database>" << endl;
    exit(1);
  }

  string codepath = argv[1];
  if ( codepath[codepath.length()-1] == '/' ) {
    codepath = string(codepath,0, codepath.length()-1);
  }
  cerr << "Code path:  -" << codepath << "-" << endl;

  for (int i = 2; i < argc; i++ ) {

    string package = argv[i];

    int p = package.find(".db");
    if ( p == -1 ) {
      cerr << "Must include .db extension in package(s)." << endl;
      exit(1);
    }

    package = string(package, 0, p);

    cerr << "package -" << package << "-" << endl;

    // remove count file if it exists already

    cerr << "... removing count file " << package << " (if it already exists)" << endl;
    system( ("rm -rf " + package + ".count").c_str() );

    string file_db = package + ".db";
    string file_offset = package +".offset";

    map<string, int> symbol_count;
    map<string, int> term_count;
  
    try {

      { // pass 1
	cerr << "PASS 1" << endl;
	Lines lines( codepath, file_db, file_offset );
	string prev_file = "";
	map< string, bool > counted_term;
	map< string, bool > counted_symbol;
	while ( lines.ReadNextLine() ) {
	  set<string> terms = lines.getCommentTerms();
	  set<string> symbols = lines.getCodeSymbols();

	  if ( !isSame(lines.currentFile(), prev_file ) ) {
	    //	    prev_file = lines.currentFile();
	    cerr << "*** new app " << lines.currentFile() << endl;
	    counted_term.clear();
	    counted_symbol.clear();
	  }

	  prev_file = lines.currentFile();

	  for( set<string>::iterator i = terms.begin(); i != terms.end(); i++ ) {
	    if ( !COUNT_APPS || counted_term.find(*i) == counted_term.end() ) {
	      term_count[*i]++;
	      counted_term[*i] = true;
	    }
	  }

	  for( set<string>::iterator i = symbols.begin(); i != symbols.end(); i++ ) {
#if COUNT_FUNCTION_SYMBOLS_ONLY
	    if ( i->find("()") == -1 ) {
	      continue;
	    }
#endif
	    if ( !COUNT_APPS || counted_symbol.find(*i) == counted_symbol.end() ) {
	      symbol_count[*i]++;
	      counted_symbol[*i] = true;
	    }

	  }
	}
      }

      map< pair<string, string>, int > rule_support;
      int total_lines = 0;
      int total_apps = 0;
      
      { // pass 2
	cerr << "PASS 2" << endl;
	Lines lines( codepath, file_db, file_offset );

	string prev_file = "";
	map< pair<string,string>, bool > counted_pair;

	while ( lines.ReadNextLine() ) {
	  total_lines++;

	  set<string> terms = lines.getCommentTerms();
	  set<string> symbols = lines.getCodeSymbols();
	  

	  if ( ! isSame (lines.currentFile(), prev_file) ) {
	    //	    prev_file = lines.currentFile();
	    cerr << "*** new app " << lines.currentFile() << endl;
	    total_apps++;
	    counted_pair.clear();
	  }

	  prev_file = lines.currentFile();

	  for( set<string>::iterator t = terms.begin(); t != terms.end(); t++ ) {
	    if ( term_count[*t] >= MIN_SUPP ) {
	      for ( set<string>::iterator s = symbols.begin(); s != symbols.end(); s++ ) {

#if COUNT_FUNCTION_SYMBOLS_ONLY
		if ( s->find("()") == -1 ) {
		  continue;
		}
#endif

		if ( symbol_count[*s] >= MIN_SUPP ) {

		  if ( ! COUNT_APPS || counted_pair.find( make_pair(*t,*s) ) == counted_pair.end() ) {

		    rule_support[ make_pair( *t, *s ) ] ++;
		    counted_pair[ make_pair( *t, *s ) ] = true;
		  }

		}
	      }
	    }
	  }  
	  
	}
      }

      string prev_term = "";
      map< double, set<string> > results;
      // print out rules
      for ( map< pair<string, string>, int >::iterator r = rule_support.begin(); r != rule_support.end(); r++ ) {
	int supp = r->second;
	string ant = (r->first).first;
	string con = (r->first).second;

	if ( ant != prev_term ) {
	  // print out results in sorted order
	  cerr << "********* " << prev_term << endl;
	  for( map<double, set<string> >::iterator i = results.begin(); i != results.end(); i++ ) {
	    set<string> S = i->second;
	    for ( set<string>::iterator s = S.begin(); s != S.end(); s++ ) {
	      cerr << *s << " product = " << -(i->first) << endl;
	    }
	  }
	  prev_term = ant;
	  results.clear();
	}

	
	if ( supp >= MIN_SUPP ) {

	  double conf = 100.0*(double)supp / (double)term_count[ant];
	  double con_usage;
	  if ( COUNT_APPS ) {
	    con_usage = 100.0*(double)symbol_count[con]/(double)total_apps;
	  } else {
	    con_usage = 100.0*(double)symbol_count[con]/(double)total_lines;
	  }
	  double surprise = conf / con_usage;
	  if ( surprise >= MIN_SURPRISE ) {
	    cerr << ant << " [ " << (supp*surprise) << "] " << " => " << con << " with conf " << conf << "% and support " << supp << " and surprise = " << surprise << " ** product " << (supp*surprise) << endl;
	    results[-supp*surprise].insert(ant + " => " + con);
	  }
	}


      }

      


#if 0
      /////// write out symbol counts
      cerr << "...writing out results" << endl;
      Db db(0, 0);
      db.open((package+".count").c_str(), 0, DB_HASH, DB_CREATE, 0 );
      for( map<string, int>::iterator i = symbol_count.begin(); i != symbol_count.end(); i++ ) {
	string symbol = i->first;
	static char str[4096];
	sprintf(str, "%d", i->second);
	string num = str;
	Dbt key( (void*) symbol.c_str(),
		 symbol.length()+1 ); // include 0 at end
	Dbt data( (void*) num.c_str(),
		  num.length()+1 ); // include 0 at end
	db.put( 0, &key, &data, DB_NOOVERWRITE );           
      }
      db.close(0);
      cerr << "Done!" << endl;
#endif




    }
    catch(OmError & error) {
      cerr << "OMSEE Exception: " << error.get_msg() << endl;
    } 
    catch (DbException& e ) {
      cerr << "SleepyCat Exception: " << e.what() << endl;
    }

  }
  
}
