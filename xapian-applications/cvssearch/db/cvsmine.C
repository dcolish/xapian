// cvsmine.C
//
// (c) 2001 Amir Michail (amir@users.sourceforge.net)

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.

//
// Usage:  cvsmine code-path package1.db package2.db ...
//
//                     => processes package.db and package.offset generated by cvsmap
//                     => builds a directory 'package' with quartz database inside
//
//  Generates package1.count package2.count ...


// if in file mode, this is the minimum # files
// 15 is reasonable but takes a while

// for app, use 5
#define MIN_SUPP 10

// should be 2.0
#define MIN_SURPRISE 0.0

// if true, counts files.
// however, still requires line pairing of comment term, code symbol

// any change in subdirectory counts as app change
#define COUNT_APPS true

#include <om/om.h>
#include <db_cxx.h>
#include <fstream.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <list>
#include <map>

#include "util.h"


void load_offset_file(  string& file_offset, vector<string>& files, vector<string>& offsets ) {

  cerr << "... reading " << file_offset << endl;
  
  ifstream in(file_offset.c_str());
  assert(in);

  while (!in.eof()) {
    string file;
    string offset;
    in >> file;
    if ( file == "" ) {
      break;
    }
    in >> offset;
    files.push_back( file ); 
    offsets.push_back( offset ); 
  }
  in.close();
  
}

bool blankChar(char c) {
  return ( c == ' ' || c == '\t' );
}

bool okFirstChar(char c) {
  return ((c >= 'a' && c <='z') || (c >='A' && c <= 'Z' ) || c == '_');
}

bool okSubChar(char c) {
  return (okFirstChar(c) || (c >= '0' && c <= '9' ));
}

set<string> countWords( const string& s, map<string, int>& symbol_count ) {
  set<string> symbols;

  string current = "";
  bool foundBlank = false;
  for ( string::const_iterator i = s.begin(); i != s.end(); i++ ) {
    char c = *i;
    
    if ( blankChar(c) ) {
      if ( current != "" ) {
	foundBlank = true;
      }
      continue;
    }

    if ( current == "" ) {
      if ( okFirstChar(c) ) {
	current = c;
      }
    } else {
      // already started something
      if (! okSubChar(c) ) {
	if ( c == '(' ) {
	  assert( current != "" );
	  current += "()";
	  //cerr << "... found " << current << endl;
	  symbols.insert(current);
	  current = "";
	  foundBlank = false;
	} else {
	  // identifier ended
	  //cerr << "... found " << current << endl;
	  assert( current != "" );
	  symbols.insert(current);
	  current = "";
	  foundBlank = false;
	}
      } else { // okay subsequent character
	if ( foundBlank ) {
	  assert( current != "" );
	  symbols.insert(current);
	  current = "";	  
	  foundBlank = false;
	}
	current += c;
      }
    }
  } 
  if ( current != "" ) {
    //    cerr << "...found " << current << endl;
    symbols.insert(current);
  }
  return symbols;
}

void processFile( string& path, string& fn, map<string, int>& symbol_count, map<string, set<string> >& line_symbols, const set<string>& lines ) {
  //  cerr << "Processing file " << (path+"/"+fn) << endl;
  string f = path +"/" + fn;
  ifstream in(f.c_str());
  assert(in);
  string s;
  int line_no = 0;
  while( getline( in, s ) ) {
    //    cerr << "Found line -" << s << "-" << endl;
    set<string> symbols = countWords( s, symbol_count );
    line_no++;
    for( set<string>::iterator i = symbols.begin(); i != symbols.end(); i++ ) {
      symbol_count[*i] ++;

      static char str[4096];
      sprintf(str,"%d", line_no);
      string file_and_line = fn + ":" + str;
      assert( lines.find( file_and_line ) != lines.end() );
      line_symbols[ file_and_line ].insert(*i);
    }
  }
  in.close();
}

bool isSame( const string& s, const string& t ) {
  //  cerr << "isSame " << s << " and " << t << endl;
  if ( s == "" || t== "" ) {
    assert( s != t );
    return false;
  }

  string sub1 = string( s, 0, s.find("/") );
  string sub2 = string( t, 0, s.find("/") );
  
  //  cerr << "sub1 " << sub1 << endl;
  //  cerr << "sub2 " << sub2 << endl;

  if ( sub1 != sub2 ) {
    return false;
  }

  // main directories same, so perhaps check subdirectory
  if ( sub1 == "kdenetwork" ||
       sub1 == "kmusic" ||
       sub1 == "koffice" ||
       sub1 == "kdebase" ||
       sub1 == "kdeutils" ||
       sub1 == "kdegraphics" ||
       sub1 == "kdemultimedia" ||
       sub1 == "kdenonbeta" ||
       sub1 == "kdepim" ||
       sub1 == "kdesdk" ||
       sub1 == "kdesupport" ||
       sub1 == "kdetoys" ||
       sub1 == "kdegames" ||
       sub1 == "kdeutils" ||
       sub1 == "kdelibs" || 
       sub1 == "kdeadmin" ) {
    //    cerr << "special case" << endl;
    string x = string( s, s.find("/")+1, s.length() );
    x = string( x, 0, x.find("/") );
    string y = string( t, t.find("/")+1, t.length() );
    y = string( y, 0, y.find("/") );
    //    cerr << "x = " << x << endl;
    //    cerr << "y = " << y << endl;
    return x == y;
  }
  return sub1 == sub2;
}

int main(int argc, char *argv[]) {

  if(argc < 3) {
    cout << "Usage:  " << argv[0] <<
      " <code path> <path to database>" << endl;
    exit(1);
  }

  string codepath = argv[1];
  if ( codepath[codepath.length()-1] == '/' ) {
    codepath = string(codepath,0, codepath.length()-1);
  }
  cerr << "Code path:  -" << codepath << "-" << endl;

  for (int i = 2; i < argc; i++ ) {

    string package = argv[i];

    int p = package.find(".db");
    if ( p == -1 ) {
      cerr << "Must include .db extension in package(s)." << endl;
      exit(1);
    }

    package = string(package, 0, p);

    cerr << "package -" << package << "-" << endl;

    // remove count file if it exists already

    cerr << "... removing count file " << package << " (if it already exists)" << endl;
    system( ("rm -rf " + package + ".count").c_str() );

    string file_db = package + ".db";
    string file_offset = package +".offset";

    map<string, int> symbol_count;
    map<string, int> term_count;
  
    try {

      { // pass 1
	Lines lines( codepath, file_db, file_offset );
	string prev_file = "";
	map< string, bool > counted_term;
	map< string, bool > counted_symbol;
	while ( lines.ReadNextLine() ) {
	  set<string> terms = lines.getCommentTerms();
	  set<string> symbols = lines.getCodeSymbols();

	  if ( !isSame(lines.currentFile(), prev_file ) ) {
	    //	    prev_file = lines.currentFile();
	    cerr << "*** new app " << lines.currentFile() << endl;
	    counted_term.clear();
	    counted_symbol.clear();
	  }

	  prev_file = lines.currentFile();

	  for( set<string>::iterator i = terms.begin(); i != terms.end(); i++ ) {
	    if ( !COUNT_APPS || counted_term.find(*i) == counted_term.end() ) {
	      term_count[*i]++;
	      counted_term[*i] = true;
	    }
	  }

	  for( set<string>::iterator i = symbols.begin(); i != symbols.end(); i++ ) {
	    if ( !COUNT_APPS || counted_symbol.find(*i) == counted_symbol.end() ) {
	      symbol_count[*i]++;
	      counted_symbol[*i] = true;
	    }

	  }
	}
      }

      map< pair<string, string>, int > rule_support;
      int total_lines = 0;
      int total_apps = 0;
      
      { // pass 2
	Lines lines( codepath, file_db, file_offset );

	string prev_file = "";
	map< pair<string,string>, bool > counted_pair;

	while ( lines.ReadNextLine() ) {
	  total_lines++;

	  set<string> terms = lines.getCommentTerms();
	  set<string> symbols = lines.getCodeSymbols();
	  

	  if ( ! isSame (lines.currentFile(), prev_file) ) {
	    //	    prev_file = lines.currentFile();
	    cerr << "*** new app " << lines.currentFile() << endl;
	    total_apps++;
	    counted_pair.clear();
	  }

	  prev_file = lines.currentFile();

	  for( set<string>::iterator t = terms.begin(); t != terms.end(); t++ ) {
	    if ( term_count[*t] >= MIN_SUPP ) {
	      for ( set<string>::iterator s = symbols.begin(); s != symbols.end(); s++ ) {
		if ( symbol_count[*s] >= MIN_SUPP ) {

		  if ( ! COUNT_APPS || counted_pair.find( make_pair(*t,*s) ) == counted_pair.end() ) {

		    rule_support[ make_pair( *t, *s ) ] ++;
		    counted_pair[ make_pair( *t, *s ) ] = true;
		  }

		}
	      }
	    }
	  }  
	  
	}
      }

      string prev_term = "";
      map< double, set<string> > results;
      // print out rules
      for ( map< pair<string, string>, int >::iterator r = rule_support.begin(); r != rule_support.end(); r++ ) {
	int supp = r->second;
	string ant = (r->first).first;
	string con = (r->first).second;

	if ( ant != prev_term ) {
	  // print out results in sorted order
	  cerr << "********* " << prev_term << endl;
	  for( map<double, set<string> >::iterator i = results.begin(); i != results.end(); i++ ) {
	    set<string> S = i->second;
	    for ( set<string>::iterator s = S.begin(); s != S.end(); s++ ) {
	      cerr << *s << " product = " << -(i->first) << endl;
	    }
	  }
	  prev_term = ant;
	  results.clear();
	}

	
	if ( supp >= MIN_SUPP ) {

	  double conf = 100.0*(double)supp / (double)term_count[ant];
	  double con_usage;
	  if ( COUNT_APPS ) {
	    con_usage = 100.0*(double)symbol_count[con]/(double)total_apps;
	  } else {
	    con_usage = 100.0*(double)symbol_count[con]/(double)total_lines;
	  }
	  double surprise = conf / con_usage;
	  if ( surprise >= MIN_SURPRISE ) {
	    cerr << ant << " [ " << (supp*surprise) << "] " << " => " << con << " with conf " << conf << "% and support " << supp << " and surprise = " << surprise << " ** product " << (supp*surprise) << endl;
	    results[-supp*surprise].insert(ant + " => " + con);
	  }
	}


      }

      


#if 0
      /////// write out symbol counts
      cerr << "...writing out results" << endl;
      Db db(0, 0);
      db.open((package+".count").c_str(), 0, DB_HASH, DB_CREATE, 0 );
      for( map<string, int>::iterator i = symbol_count.begin(); i != symbol_count.end(); i++ ) {
	string symbol = i->first;
	static char str[4096];
	sprintf(str, "%d", i->second);
	string num = str;
	Dbt key( (void*) symbol.c_str(),
		 symbol.length()+1 ); // include 0 at end
	Dbt data( (void*) num.c_str(),
		  num.length()+1 ); // include 0 at end
	db.put( 0, &key, &data, DB_NOOVERWRITE );           
      }
      db.close(0);
      cerr << "Done!" << endl;
#endif




    }
    catch(OmError & error) {
      cerr << "OMSEE Exception: " << error.get_msg() << endl;
    } 
    catch (DbException& e ) {
      cerr << "SleepyCat Exception: " << e.what() << endl;
    }

  }
  
}
