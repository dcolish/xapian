// cvsmine.C
//
// (c) 2001 Amir Michail (amir@users.sourceforge.net)

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.

//
// Usage:  cvsmine code-path package1.db package2.db ...
//
//                     => processes package.db and package.offset generated by cvsmap
//                     => builds a directory 'package' with quartz database inside
//
//  Generates package1.count package2.count ...



//
// Reasoning for looking at symbols in the most recent copy and
// not on a commit by commit basis in previous versions:
//
//  code symbols change over time but not the domain concepts
//  we describe them by in comments
//

// if in file mode, this is the minimum # files
// 15 is reasonable but takes a while


//#define MAX_LINES 500000
#define MAX_LINES 50000000

// for app, use 5
#define MIN_SUPP 5 

// should be 2.0
#define MIN_SURPRISE 0.0

// if true, counts files.
// however, still requires line pairing of comment term, code symbol

// any change in subdirectory counts as app change
#define COUNT_APPS true

// app count not exactly correct because files not handled
// in order of app exactly but also by order of extension
// (e.g., .h, .cc, .C, .cpp, etc.), so some apps may contribute
// 2 or 3 to the count

#define COUNT_FUNCTION_SYMBOLS_ONLY 0
#define COUNT_KDE_CLASSES_ONLY 1

#include <om/om.h>
#include <db_cxx.h>
#include <fstream.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <math.h>
#include <algorithm>

#include "util.h"

// given a path, extract the application
string extractApp( const string& s ) {

  if ( s == "" ) {
    return s;
  }

  string sub = string( s, 0, s.find("/") );
  
  // main directories same, so perhaps check subdirectory
  if ( sub == "kdenetwork" ||
       sub == "kmusic" ||
       sub == "koffice" ||
       sub == "kdebase" ||
       sub == "kdeutils" ||
       sub == "kdegraphics" ||
       sub == "kdemultimedia" ||
       sub == "kdenonbeta" ||
       sub == "kdepim" ||
       sub == "kdesdk" ||
       sub == "kdesupport" ||
       sub == "kdetoys" ||
       sub == "kdegames" ||
       sub == "kdeutils" ||
       sub == "kdelibs" || 
       sub == "kdeadmin" ) {

    string x = string( s, s.find("/")+1, s.length() );
    x = string( x, 0, x.find("/") );
    return x;
  } 

  return sub;

}


int main(int argc, char *argv[]) {

  if(argc < 3) {
    cout << "Usage:  " << argv[0] <<
      " <code path> <path to database>" << endl;
    exit(1);
  }

  string codepath = argv[1];
  if ( codepath[codepath.length()-1] == '/' ) {
    codepath = string(codepath,0, codepath.length()-1);
  }
  cerr << "Code path:  -" << codepath << "-" << endl;

  for (int i = 2; i < argc; i++ ) {

    string package = argv[i];

    int p = package.find(".db");
    if ( p == -1 ) {
      cerr << "Must include .db extension in package(s)." << endl;
      exit(1);
    }

    package = string(package, 0, p);

    cerr << "package -" << package << "-" << endl;

    // remove count file if it exists already

    cerr << "... removing count file " << package << " (if it already exists)" << endl;
    system( ("rm -rf " + package + ".count").c_str() );

    string file_db = package + ".db";
    string file_offset = package +".offset";

    map<string, set<string> > symbol_count;
    map<string, set<string> > term_count;
    set<string> apps;

    try {

      { // pass 1
	cerr << "PASS 1" << endl;
	Lines lines( codepath, file_db, file_offset );
	int lines_read = 0;
	while ( lines.ReadNextLine() && lines_read < MAX_LINES ) {

	  set<string> terms = lines.getCommentTerms();
	  set<string> symbols = lines.getCodeSymbols();

	  string app = extractApp( lines.currentFile() );
	  //	  cerr << lines.currentFile() << " => " << app << endl;

	  apps.insert(app);

	  for( set<string>::iterator i = terms.begin(); i != terms.end(); i++ ) {
	      term_count[*i].insert(app);
	  }

	  for( set<string>::iterator i = symbols.begin(); i != symbols.end(); i++ ) {
#if COUNT_FUNCTION_SYMBOLS_ONLY
	    if ( i->find("()") == -1 ) {
	      continue;
	    }
#endif

#if COUNT_KDE_CLASSES_ONLY
	    if ( i-> find("()") == -1 && (*i)[0] != 'Q' && (*i)[0] != 'K' ) {
	      continue;
	    }
#endif
	    symbol_count[*i].insert(app);

	  }
	  lines_read++;
	} // while
      }

      map< pair<string, string>, set<string> > rule_support;
      
      { // pass 2
	cerr << "PASS 2" << endl;
	Lines lines( codepath, file_db, file_offset );
	
	int lines_read = 0;

	while ( lines.ReadNextLine() && lines_read < MAX_LINES ) {

	  set<string> terms = lines.getCommentTerms();
	  set<string> symbols = lines.getCodeSymbols();
	  
	  string app = extractApp( lines.currentFile() );


	  for( set<string>::iterator t = terms.begin(); t != terms.end(); t++ ) {
	    if ( term_count[*t].size() >= MIN_SUPP ) {
	      for ( set<string>::iterator s = symbols.begin(); s != symbols.end(); s++ ) {

#if COUNT_FUNCTION_SYMBOLS_ONLY
		if ( s->find("()") == -1 ) {
		  continue;
		}
#endif
#if COUNT_KDE_CLASSES_ONLY
		if ( s-> find("()") == -1 && (*s)[0] != 'Q' && (*s)[0] != 'K' ) {
		  continue;
		}
#endif

		if ( symbol_count[*s].size() >= MIN_SUPP ) {

		  rule_support[ make_pair( *t, *s ) ].insert(app);

		}
	      }
	    }

	  }
	  lines_read++;	  
	} // while
      }



      cerr << "TOTAL APPS = " << apps.size() << endl;

      string prev_term = "";
      map< double, set<string> > results;
      // print out rules
      for ( map< pair<string, string>, set<string> >::iterator r = rule_support.begin(); r != rule_support.end(); r++ ) {
	int supp = (r->second).size();
	string ant = (r->first).first;
	string con = (r->first).second;

	if ( ant != prev_term ) {
	  // print out results in sorted order
	  cerr << "********* " << prev_term << endl;
	  for( map<double, set<string> >::iterator i = results.begin(); i != results.end(); i++ ) {
	    set<string> S = i->second;
	    for ( set<string>::iterator s = S.begin(); s != S.end(); s++ ) {
	      cerr << *s << " product = " << -(i->first) << endl;
	    }
	  }
	  prev_term = ant;
	  results.clear();
	}

	
	if ( supp >= MIN_SUPP ) {

	  double conf = 100.0*(double)supp / (double)term_count[ant].size();

	  // we divide the confidence by the % of applications that contain
	  // the consequent in *some* line but yet do not contain
	  // both ant & con at the same time in *any* line.

	  //
	  // This doesn't really work because the consequent may only
	  // occur in that one application, so the penalty would be zero!
	  // We can kind of get around this by requiring some minimum support
	  // of 5 say.  Another way is to multiply surprise by support if we can
	  // get rid of the inf thing.
	  




	  // how to compute?

	  // for each entry that we compute, we can keep a list of applications
	  // that support it
	  //
	  // given a consequent, we need to know all apps that contain that consequent
	  //
	  // we can keep track of all apps supporting both ant & con, from this,
	  // we can get a list of all apps that never contain ant & con in the same line
	  //
	  // we simply intersect thse two lists to get our count of applications
	  // that contain the consequent in some line but yet do not contain
	  // both ant & con at the same time in *any* line.
	  //
	  // So, basically we need to keep lists of applications for each symbol
	  // and for each (term, symbol) pair.
	  //
	  // How much memory does this take?  Right now we do not keep track of any lists.
	  //
	  // 
	
	  set<string> S1 = symbol_count[con]; // apps containing consequent
	  
	  // compute apps that do not contain a line with both ant & con
	  set<string> X = r->second; // apps for this rule

	  // compute apps - X
	  set<string> XP;
	  set_difference( apps.begin(), apps.end(),
			  X.begin(), X.end(),
			  inserter(XP, XP.begin()) );


	  // intersect XP with S1
	  
	  set<string> R;
	  set_intersection( XP.begin(), XP.end(),
			    S1.begin(), S1.end(),
			    inserter(R, R.begin()) );

#warning "penalty could be zero resulting in division by zero"
	  double penalty = 100.0*(double)R.size() / (double)apps.size();
	  penalty = log(1.1 + penalty); // penalty was too severe, also don't want zero
	  
	  double surprise = conf / penalty; // / con_usage;

	  // multiplying by support is important since that takes
	  // into account the importance of the relationship... perhaps
	  // should only multiply by support of consequent

	  if ( surprise >= MIN_SURPRISE ) {
	    //	    cerr << ant << " [ " << (supp*surprise) << "] " << " => " << con << " with conf " << conf << "% and support " << supp << " and surprise = " << surprise << " ** product " << (supp*surprise) << endl;
	    //	    results[-supp*surprise].insert(ant + " => " + con);
	    cerr << ant << " => " << con << " has conf " << conf << " and support " << supp << " and penalty " << penalty << " and surprise " << surprise << endl;
#warning "uses product of surprise and supp"	   
	    results[-surprise*supp].insert(ant + " => " + con);
	  }
	}


      }

      


#if 0
      /////// write out symbol counts
      cerr << "...writing out results" << endl;
      Db db(0, 0);
      db.open((package+".count").c_str(), 0, DB_HASH, DB_CREATE, 0 );
      for( map<string, int>::iterator i = symbol_count.begin(); i != symbol_count.end(); i++ ) {
	string symbol = i->first;
	static char str[4096];
	sprintf(str, "%d", i->second);
	string num = str;
	Dbt key( (void*) symbol.c_str(),
		 symbol.length()+1 ); // include 0 at end
	Dbt data( (void*) num.c_str(),
		  num.length()+1 ); // include 0 at end
	db.put( 0, &key, &data, DB_NOOVERWRITE );           
      }
      db.close(0);
      cerr << "Done!" << endl;
#endif




    }
    catch(OmError & error) {
      cerr << "OMSEE Exception: " << error.get_msg() << endl;
    } 
    catch (DbException& e ) {
      cerr << "SleepyCat Exception: " << e.what() << endl;
    }

  }
  
}
