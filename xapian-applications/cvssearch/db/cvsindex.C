/********************************************************************************
 * cvsindex.C
 * 
 * (c) 2001 Amir Michail (amir@users.sourceforge.net)
 * modified by Andrew Yao (andrewy@users.sourceforge.net)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * Usage:     cvsindex package1.cmt package2.cmt ...
 * 
 *           => processes package.cmt. and package.offset generated by cvsmap
 *           => builds a directory 'package' with quartz database inside
 * 
 * Note:     if package1.cmt is a full path name, say /home/blah/blah/package1.cmt, 
 *           then we assume /home/blah/blah/package1.offset also exists, and a 
 *           directory /home/blah/blah/package1 will be created with quartz 
 *           database inside.
 *
 * Warning:  it always deletes the directory /home/blah/blah/package1 if it 
 *           exists already.
 * 
 ********************************************************************************/

#include <om/om.h>
#include <fstream.h>
#include <stdio.h>
#include <stdlib.h>

#include "util.h"

#define FLUSH_RATE 50

void usage(char * prog_name);
const string database = "db";

int main(int argc, char *argv[]) 
{

    if(argc < 2) {
        usage(argv[0]);
    }

    for (int i = 1; i < argc; i++ ) {
        string package = argv[i];
        string package_name;
        string package_path;

        cout << "FILE " << package << endl;
        unsigned int p = package.find(".cmt");
        unsigned int q = package.find_last_of('/');

        if ( p == string::npos ) {
            cerr << "Must include .cmt extension in package(s)." << endl;
            exit(1);
        }
        // ----------------------------------------
        // no '/', so use current directory
        // ----------------------------------------
        if ( q == string::npos) {
            q = 0;
        }
        if ( q >= p )
        {
            cerr << "Cannot parse package.cmt. found a \"/\" after \".cmt\" in the filename." << endl;
            exit(1);
        }
        package_name = string(package, q, p);
        package_path = string(package, 0, p);

        package = string(package, q, p);
        cerr << "package -" << package_name << "-" << endl;

        assert( package != "." ); // safety checks
        assert( package != ".." );


        string file_cmt    = package_path + ".cmt";
        string file_offset = package_path + ".offset";
        string database_dir= package_path;

        cerr << "... removing directory " << database_dir << " (if it already exists)" << endl;
        system( ("rm -rf " + database_dir).c_str() );
        
        try {
            // ----------------------------------------
            // create database directory
            // ----------------------------------------
            system(("mkdir " + database_dir ).c_str());

            // code which accesses Omsee

            OmSettings db_parameters;
            db_parameters.set("backend", "quartz");
            db_parameters.set("quartz_dir", database_dir);
            OmWritableDatabase database(db_parameters); // open database 

            database.begin_session();

            cerr << "... reading " << file_cmt << endl;

            int files = 0;
            // ----------------------------------------
            // no stop words, line granularity
            // ----------------------------------------
            Lines lines( "", package, file_cmt, file_offset, "line", false ); 
            string prev_file = "";
            while ( lines.ReadNextLine() ) {
                if ( lines.currentFile() != prev_file ) {
                    prev_file = lines.currentFile();
                    files++;
                    if ( files % FLUSH_RATE == 0 ) {
                        cerr << "... flushing database." << endl;
                        database.flush();
                    }
                }

                list<string> words = lines.getTermList();
                string data = lines.getData();
                // ----------------------------------------
                // we want to output something like:
                // 0.453 80 15 kdebase/konqueror:1.8 1.3 1.1
                // 0.453 is the score
                // 80 is the file number
                // 15 is the line number

                // so, along with each entry, we store the 
                // following associated string:
                // 80 15:1.8 1.3 1.1
                // ----------------------------------------
                OmDocumentContents newdocument;
                int pos = 1;
                for( list<string>::iterator i = words.begin(); i != words.end(); i++ ) {
	  
                    string word = *i;
                    newdocument.add_posting(word, pos++); // term, position of term
                }
                newdocument.data = data;
                database.add_document(newdocument);
            }
      
            database.end_session();
            cerr << "Done!" << endl;
        }
        catch(OmError & error) {
            cerr << "OMSEE Exception: " << error.get_msg() << endl;
        } 
    }
}

void
usage(char * prog_name)
{
    cerr << "Usage: " << prog_name << " [Options] pkg1.cmt pkg2.cmt ..." << endl
         << endl
         << "Options:" << endl
         << "  -h                     print out this message" << endl
        ;
    
    exit(0);
}
