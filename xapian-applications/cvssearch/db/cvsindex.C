// cvsindex.C
//
// (c) 2000-2001 Amir Michail (amir@users.sourceforge.net)

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.

//
// Usage:  cvsindex package 
//
//                     => processes package.db and package.offset generated by cvsmap
//                     => builds a directory 'package' with quartz database inside
//
//  Warning:  it always deletes the directory package if it exists already.

#include <om/om.h>
#include <fstream.h>
#include <stdio.h>

static void
lowercase_term(om_termname &term)
{
  om_termname::iterator i = term.begin();
  while(i != term.end()) {
    *i = tolower(*i);
    i++;
  }
}

void split (const string & text, const string & separators, list<string> & words)
{
   int n = text.length();
   int start, stop;

   start = text.find_first_not_of(separators);
   while ((start >= 0) && (start < n)) {
     stop = text.find_first_of(separators, start);
     if ((stop < 0) || (stop > n)) {
       stop = n;
     }
     string word = text.substr(start, stop - start);
     words.push_back(word);
     start = text.find_first_not_of(separators, stop+1);
   }
}

void load_offset_file( string& file_offset, vector<string>& files, vector<string>& offsets ) {

  cerr << "... reading " << file_offset << endl;
  
  ifstream in(file_offset.c_str());
  assert(in);

  while (!in.eof()) {
    string file;
    string offset;
    in >> file;
    in >> offset;
    files.push_back( file ); 
    offsets.push_back( offset ); 
  }
  in.close();
  
}

int main(int argc, char *argv[]) {

  if(argc < 2) {
    cout << "Usage:  " << argv[0] <<
      " <path to database>" << endl;
    exit(1);
  }

  string package = argv[1];

  // remove directory first if it already exists

  assert( package != "." ); // safety checks
  assert( package != ".." );

  cerr << "... removing directory " << package << " (if it already exists)" << endl;
  system( ("rm -rf " + package).c_str() );

  string file_db = package + ".db";
  string file_offset = package +".offset";

  vector<string> files;
  vector<string> offsets;

  try {

    load_offset_file( file_offset, files, offsets );

 
    // create database directory
    system(("mkdir " + package).c_str());

    // code which accesses Omsee

    OmSettings db_parameters;
    db_parameters.set("backend", "quartz");
    db_parameters.set("quartz_dir", package);
    OmWritableDatabase database(db_parameters); // open database 


    ////////////////////////////////// cycle through each document

    cerr << "... reading " << file_db << endl;

    ifstream in(file_db.c_str());
    assert( in );

    int line_no = 0;
    string current_fn = "";
    int current_offset = 1;

    OmStem stemmer("english");

    while (!in.eof()) {
      
      line_no++;

      string line;
      if ( getline( in, line, '\n' ).eof() ) {
	if ( line == "" ) {
	  break;
	}
      }

      // break up line into words
      list<string> words;
      split( line, " .,:;!()[]<>?-\t\n\002", words ); // we get 002 sometimes if ".^B"
      
      OmDocumentContents newdocument;
      
      int pos = 1;
      
      string message; // put file:line# first

      int file_no = atoi(  words.front().c_str() );

      string fn = files[file_no-1];
      if ( fn != current_fn ) {
	int offset = atoi(offsets[file_no-1].c_str());
	assert( line_no == offset );
	current_offset = offset;
	current_fn = fn;
	cerr << "... processing " << current_fn << endl;
      }
      static char str[4096];
      sprintf(str,"%d", (line_no-current_offset+1));
      message = current_fn + ":" + str + "\n";

      int space = line.find(" ");
      message += string( line, space+2, line.length() - (space+2) );


      for( list<string>::iterator i = words.begin(); i != words.end(); i++ ) {

	// skip file # in .db file
	if ( i == words.begin() ) {
	  continue;
	}

	string word = *i;

	om_termname term = word;
	lowercase_term(term);
	term = stemmer.stem_word(term);

	newdocument.add_posting(term, pos++); // term, position of term
      }
      
      // add files to mesage
      message += "\n";

      //      cerr << endl << message;

      newdocument.data = message; // data associated with document (e.g., title, etc.)
      database.add_document(newdocument);
      
    }
    
    in.close();
    

  }
  catch(OmError & error) {
    cout << "Exception: " << error.get_msg() << endl;
  } 
  
}
