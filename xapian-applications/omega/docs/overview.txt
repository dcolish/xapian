Omega overview
==============

Omega operates on a set of databases.  Each database is created and updated
separately using either omindex or scriptindex.  You can search these databases
(or any other Xapian database with suitable contents) via a web front-end
provided by omega, a CGI application.  A search can also be done over a
more than one database at once.

The CGI program's parameters are documented in cgiparams.txt, and OmegaScript,
the language used to define its web interface, is documented in
omegascript.txt.


Term construction
=================

Documents within an omega database are stored with two types of terms:
those used for probabilistic searching (the CGI parameter 'P'), and
those used for boolean filtering (the CGI parameter 'B'). Boolean
terms start with an initial capital letter denoting the 'group' of the
term (eg: 'M' for MIME type), while probabilistic terms are all
lower-case, and are also stemmed before adding to the
database. (Currently the stemmer is the English one and cannot be
configured without editing the source code.)

The two term types are used as follows when building the query:
B(oolean) terms with the same prefix are ORed together, with all the
different prefix groups being ANDed together. This is then FILTERed
against the P(robabilistic) terms. This will look something like:

		      [ FILTER ]
		       /      \
		      /        \
		 P-terms      [     AND     ]
			       /     | ... \
                              /
			[    OR    ]
		       /      | ... \
                    B(F,1) B(F,2)...B(F,n)

Where B(F,1) is the first boolean term with prefix F, and so on.

The intent here is to allow filtering on arbitrary (and, typically,
orthogonal) characteristics of the document. For instance, by adding
boolean terms "Ttext/html", "Ttext/plain" and "P/press" you would be
filtering the probabilistic search for only documents that are both in
the "/press" site _and_ which are either of MIME type text/html or
text/plain. (See below for more information about sites.)

If there is no probabilistic query, the boolean filter is promoted to
be the query, and the weighting scheme is set to boolean.  This has
the effect of applying the boolean filter to the whole database.

In order to add more boolean prefixes, you will need to alter the
index_file() function in omindex.cc. omindex currently adds several
useful ones, detailed below.

Probabilistic terms are constructed from the title, body and keywords
of a document. (Not all document types support all three areas of
text.) Title terms are stored with position data starting at 0, body
terms starting 100 beyond title terms, and keyword terms starting 100
beyond body terms. This allows queries using positional data without
causing false matches across the different types of term.


Sites
=====

Within a database, omega supports multiple sites. These are recorded
using boolean terms (see 'Term construction', above) to allow
filtering on them.

Sites work by having all documents within them having a common base
URL. For instance, you might have two sites, one for your press area
and one for your product descriptions:

	http://example.com/press/index.html
	http://example.com/press/bigrelease.html
	http://example.com/product/bigproduct.html
	http://example.com/product/littleproduct.html

You could index all documents within http://example.com/press/ using a
site of '/press', and all within http://example.com/product/ using
'/product'.

Sites are also useful because omindex indexes documents through the
file system, not by fetching from the web server. If you don't have a
URL to file system mapping which puts all documents under one
hierarchy, you'll need to index each separate section as a site.

An obvious example of this is the way that many web servers map URLs
of the form <http://example.com/~<username>/> to a directory within
that user's home directory (such as ~<username>/pub on a Unix
system). In this case, you can index each user's home page separately,
as a site of the form '/~<username>'. You can then use boolean
filters to allow people to search only a specific home page (or a
group of them), or omit such terms to search everyone's pages.

Note that the site specified when you index is used to build the
complete URL that the results page links to. Thus while sites will
typically want to be relative to the hostname part of the URL (eg
'/site' rather than 'http://example.com/site'), you can use them
to have a single search across several different hostnames. This will
still work if you actually store each distinct hostname in a different
database.


omindex operation
=================

omindex is fairly simple to use:

----------------------------------------------------------------------
Usage: ../omindex [OPTION] --db DATABASE 
        --url BASEURL [BASEDIRECTORY] DIRECTORY

Index static website data via the filesystem.
  -d, --duplicates      set duplicate handling
                        one of `ignore', `replace', `duplicate'
  -D, --db              path to database to use
  -U, --url             base url DIRECTORY represents
  -M, --mime-type	additional MIME mapping ext:type
  -l, --no-recurse	only process the given directory
  -h, --help            display this help and exit
  -v --version          output version and exit
----------------------------------------------------------------------

You _must_ specify the database to index into (it's created if it
doesn't exist, but relevant directories must exist - this includes the
base directory for Quartz) and the base URL (which is used as the
site, and can be relative to the hostname - starts '/' - or absolute -
starts with a scheme, eg 'http://morestuffhere...').

You also need to tell omindex which directory to index. This should be
either a single directory (in which case it is taken to be the
directory base of the entire site being indexed), or as two arguments,
the first being the directory base of the site being indexed, and the
second being a relative directory within that to index.

For instance, in the example above, if you separate your products by
size, you might end up with:

	http://example.com/press/index.html
	http://example.com/press/bigrelease.html
	http://example.com/product/large/bigproduct.html
	http://example.com/product/small/littleproduct.html

If the entire website is stored in the file system under the directory
/www/example, then you would probably index the site in two
passes, one for the '/press' site and one for the '/product' site. You
might use the following commands:

$ omindex --db /www/omega --url '/press' /www/example/press
$ omindex --db /www/omega --url '/product' /www/example/product

If you add a new large product, but don't want to reindex the whole of
the product section, you could do:

$ omindex --db /www/omega --url '/product' /www/example/product large

and just the large products will be reindexed. You need to do it like that, and not as:

$ omindex --db /www/omega --url '/product/large' /www/example/product/large

because that would make the large products part of a new site,
'/product/large', which is unlikely to be what you want, as large
products would no longer come up in a search of the product
site. (Note that the --no-recurse option may come in handy if you have
sites '/product' and '/product/large', or similar.)

Currently omindex can index:

* HTML (.html, .htm, .shtml)
* PHP (.php) - our HTML parser knows to ignore PHP code
* text files (.txt, .text)
* PDF (.pdf) if pdftotext is available (comes with xpdf)
* PostScript (.ps, .eps, .ai) if pstotext is available
* OpenOffice/StarOffice documents (.sxc, .stc, .sxd, .std, .sxi, .sti, .sxm,
  .sxw, .sxg, .stw) if unzip is available
* MS Word documents (.doc) if antiword is available
* Wordperfect documents (.wpd) if wpd2text is available (comes with libwpd)
* Rich Text Format documents (.rtf) if unrtf is available

If you have additional extensions that represent one of these types, you need
to add an additional MIME mapping using the --mime-type option. For instance:

$ omindex --db /www/omega --url '/press' /www/example/press
          --mime-type 'doc:application/postscript'

The syntax of --mime-type is 'ext:type', where ext is the extension of
a file of that type (everything after the last '.'), and type is one
of:

    text/html
    text/plain
    text/rtf
    application/msword
    application/pdf
    application/postscript
    application/vnd.sun.xml.calc
    application/vnd.sun.xml.calc.template
    application/vnd.sun.xml.draw
    application/vnd.sun.xml.draw.template
    application/vnd.sun.xml.impress
    application/vnd.sun.xml.impress.template
    application/vnd.sun.xml.math
    application/vnd.sun.xml.writer
    application/vnd.sun.xml.writer.global
    application/vnd.sun.xml.writer.template
    application/vnd.wordperfect

--duplicates configures how omindex handles duplicates (detected on
URL). 'ignore' means to ignore a document if it already appears to be
in the database; 'replace' means to replace the document in the
database with a new one by indexing this file, and 'duplicate' means
to index this file as a new document, leaving the previous one in the
database as well. The last strategy is very fast, but is liable to do
strange things to your results set. In general, 'ignore' is useful for
completely static documents (eg: archive sites), while 'replace' is
the most generally useful.

--no-recurse prevents omindex from indexing any directories it finds
within the directory you give it.


Boolean terms
=============

omindex will create the following boolean terms when it indexes a
document:

T	MIME type
H	hostname of site (if supplied - this term won't exist if you
	index a site with base URL '/press', for instance)
P	path of site (ie: the rest of the site base URL)
D	date (numeric format: YYYYMMDD)
	date can also have the magical form "latest" - a document indexed
	by the term Dlatest matches any date-range without an end date.
	You can index dynamic documents which are always up to date
	with Dlatest and they'll match as expected.  (If you use sort by date,
	you'll probably also want to set the value containing the timestamp to
	a "max" value so dynamic documents match a date in the far future).
W	"weak" (approximately 10 day intervals, taken as YYYYMMD from
	the D term, and changing the last digit to a '2' if it's a '3')
M	month (numeric format: YYYYMM)
Y	year (four digits)
U	full URL of indexed document - if the resulting term would be > 240
	characters, a hashing scheme is used to prevent omindex overflowing
	the Xapian term length limit.


omega configuration
===================

Most of the omega CGI configuration is dynamic, by setting CGI
parameters. However some things must be configured using a
configuration file (either 'omega.conf' in the same directory as the
Omega CGI itself, or '/etc/omega.conf').

The format of the file is very simple: a line per option, with the
option name followed by its value, separated by a space. The current
options are 'database_dir' (the directory containing all the Omega
databases), 'template_dir' (the directory containing the Omega
templates), and 'log_dir' (the directory which the omegascript $log command
writes log files to).

If neither configuration file can be opened, defaults are used (this
is also supplied as omega.conf in the distribution):

----------------------------------------------------------------------
database_dir /var/lib/omega/data
template_dir /var/lib/omega/templates
log_dir /var/log/omega
----------------------------------------------------------------------


Document data construction
==========================

(This is only useful if you need to inject your own documents into the
database independently of omindex, such as if you are indexing
dynamically-generated documents that are served using a server-side
system such as PHP or ASP, but which you can determine the contents of
in some way, such as documents generated from reasonably static
database contents.)

The document data field stores some summary information about the
document, in the following (sample) format:

----------------------------------------------------------------------
url=<baseurl>
sample=<sample>
caption=<title>
type=<mimetype>
----------------------------------------------------------------------

Further fields may be added (although omindex doesn't currently do any
others), and may be looked up from OmegaScript using the $field{}
command.
