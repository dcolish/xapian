#! @PERL@ -w
# @configure_input@
# stemtest.pl is automatically generated from stemtest.pl.in
# *** Do not edit the generated file ***
#
# stemtest.pl.in - automatic test of the stemming functions.
#
# ----START-LICENCE----
# Copyright 1999,2000 Dialog Corporation
# 
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
# -----END-LICENCE-----

use strict;

$main::did_something = 0;
$main::retval = 0;
$main::verbose = 0;

while ($_ = shift @ARGV) {
  if ($_ =~ /^-v$/) {
      $main::verbose = 1;
  } else {
      print "Usage: $0 [-v]\n";
      exit 1;
  };
};

my ($val_succeeded, $val_failed, $val_skipped) = (0, 1, 2);

$main::testspassed = 0;
$main::testsfailed = 0;
$main::testsskipped = 0;

# we need to generate a file of random rubbish to feed to each
# of the stemming routines.
my ($randtext, $randjunk) = (".stemtest.pl_randtext", ".stemtest.pl_randjunk");
my $seed = 1;
srand $seed;
print "Generating random text... (seed $seed)\n";
&make_randomtext($randtext);
srand $seed;
print "Generating random junk... (seed $seed)\n";
&make_randomjunk($randjunk);

foreach ("dutch", "english", "french", "german", "italian", "portuguese", "spanish") {
    my $language = $_;
    my $myretval = &dicttest($language);
    if ($myretval == $val_succeeded) {
        $main::testspassed++;
    } elsif ($myretval == $val_failed) {
        $main::retval = $myretval;
	$main::testsfailed++;
    } elsif ($myretval == $val_skipped) {
        $main::testsskipped++;
    } else {
        die "Internal error";
    };

    $myretval = &randtest($language, $randtext);
    if ($myretval == $val_succeeded) {
        $main::testspassed++;
    } elsif ($myretval == $val_failed) {
        $main::retval = $myretval;
	$main::testsfailed++;
    } elsif ($myretval == $val_skipped) {
        $main::testsskipped++;
    } else {
        die "Internal error";
    };

    $myretval = &randtest($language, $randjunk);
    if ($myretval == $val_succeeded) {
        $main::testspassed++;
    } elsif ($myretval == $val_failed) {
        $main::retval = $myretval;
	$main::testsfailed++;
    } elsif ($myretval == $val_skipped) {
        $main::testsskipped++;
    } else {
        die "Internal error";
    };
};

unlink($randtext);
unlink($randjunk);

print "$0 finished: $main::testspassed tests passed, " .
      "$main::testsfailed failed" .
      ($main::testsskipped? ", $main::testsskipped skipped" : "") . ".\n";

if ($main::did_something) {
    exit $main::retval;
} else {
    exit 77;  # magic value meaning "ignore test"
};

sub dicttest {
    my $language = shift;
    my $datadir = $ENV{"srcdir"} . "/../../data/stemming/$language/data";
    my $wordcount = 0;
    my $myretval = $val_succeeded;

    print "Testing $language with fixed dictionary...";
    if (-r "$datadir/voc.txt" &&
        -r "$datadir/voc.st") {
	$main::did_something = 1;

	if ($main::verbose) {
	    print "Running \`./stemtest --$language $datadir/voc.txt'...\n";
	};
	open(STEMMER_OUTPUT, "./stemtest --$language $datadir/voc.txt|")
	    or die "Failed to run stemtest";
	open(STEMMED_ANSWERS, "<$datadir/voc.st")
	    or die "Failed to open stemmed data";
	
	while (1) {
	    my $stemmed = <STEMMER_OUTPUT>;
	    my $answer = <STEMMED_ANSWERS>;

	    # if both are undefined, then we've finished
	    if (!defined $stemmed and !defined $answer) {
	        last;
	    };

	    if (defined $stemmed and defined $answer) {
		$wordcount++;

		# we don't want those pesky newlines!
		chomp $stemmed;
		chomp $answer;

	        if ($stemmed ne $answer) {
		    $myretval = $val_failed;
		    if ($main::verbose) {
		    	print "Got $stemmed, expected $answer\n";
		    };
		    last;
		};
	    } else {
	        $myretval = $val_failed;
		if ($main::verbose) {
		    print "Got an unexpected EOF\n";
		};
		last;
	    };
		    
	};
	print "$wordcount words checked... " . ($myretval? "FAILED" : "ok") . "\n";
    } else {
        print "stemming test data not available in $datadir\n";
	print "(skipping language $language)\n";
	return $val_skipped;
    };
    return $myretval;
};

sub randtest {
    my $retval;
    my $language = shift;
    my $filename = shift;

    print "Testing $language with file $filename...";
    $retval = system("./stemtest --$language $filename > /dev/null 2>&1");
    if ($retval) {
        if ($main::verbose) {
	    print "stemtest returned $retval\n";
	};
	print " FAILED\n";
        return $val_failed;
    } else {
        print " ok.\n";
        return $val_succeeded;
    };
};

# these are inefficient, I know...
sub make_randomtext {
    my $filename = shift;
    my $count = 0;
    my @allowedchars = split(//,
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789^ \n");

    open(OUTPUT, ">$filename") or die "Failed to create random text file";

    while ($count < 2048576) {
        print OUTPUT $allowedchars[int(rand(@allowedchars))];
	$count++;
    };
    close OUTPUT;
};

sub make_randomjunk {
    my $filename = shift;
    my $count = 0;

    open(OUTPUT, ">$filename") or die "Failed to create random junk file";

    while ($count < 2048576) {
        print OUTPUT pack("C", int(rand(256)));
	$count++;
    };
    close OUTPUT;
};
