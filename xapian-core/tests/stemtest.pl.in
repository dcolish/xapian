#! @PERL@ -w
# @configure_input@
# stemtest.pl is automatically generated from stemtest.pl.in
# *** Do not edit the generated file ***
#
# stemtest.pl.in - automatic test of the stemming functions.
#
# ----START-LICENCE----
# Copyright 1999,2000 Dialog Corporation
# 
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
# -----END-LICENCE-----

use strict;

my $seed = undef;
my $junksize = 2 * 1048576;

my ($did_something, $retval, $verbose) = (0, 0, 0);
my ($val_succeeded, $val_failed, $val_skipped) = (0, 1, 2);
my ($testspassed, $testsfailed, $testsskipped) = (0, 0, 0);

while ($_ = shift @ARGV) {
  if ($_ =~ /^-v$/) {
      $verbose = 1;
  } elsif ($_ =~ /^--seed$/) {
      $seed = shift or die "Usage: $0 [-v] [--seed <seed>]";
  } else {
      print "Usage: $0 [-v]\n";
      exit 1;
  };
};

# we need to generate a file of random rubbish to feed to each
# of the stemming routines.
if (!defined $seed) {
    $seed = unpack("%32L*", `hostname`);
    print "The random seed is $seed; please report the seed when reporting a test failure.\n";
};

my ($randtext, $randjunk) = ("randtext_seed_$seed", "randjunk_seed_$seed");
srand $seed;
print "Generating random text... (seed $seed)\n";
&make_randomtext($randtext);
srand $seed;
print "Generating random junk... (seed $seed)\n";
&make_randomjunk($randjunk);

foreach ("dutch", "english", "french", "german", "italian", "portuguese", "spanish") {
    my $language = $_;
    my $myretval = &dicttest($language);
    if ($myretval == $val_succeeded) {
        $testspassed++;
    } elsif ($myretval == $val_failed) {
        $retval = $myretval;
	$testsfailed++;
    } elsif ($myretval == $val_skipped) {
        $testsskipped++;
    } else {
        die "Internal error";
    };

    $myretval = &randtest($language, $randtext);
    if ($myretval == $val_succeeded) {
        $testspassed++;
    } elsif ($myretval == $val_failed) {
        $retval = $myretval;
	$testsfailed++;
    } elsif ($myretval == $val_skipped) {
        $testsskipped++;
    } else {
        die "Internal error";
    };

    $myretval = &randtest($language, $randjunk);
    if ($myretval == $val_succeeded) {
        $testspassed++;
    } elsif ($myretval == $val_failed) {
        $retval = $myretval;
	$testsfailed++;
    } elsif ($myretval == $val_skipped) {
        $testsskipped++;
    } else {
        die "Internal error";
    };
};

# don't delete them, since we want them cached.
#unlink($randtext);
#unlink($randjunk);

print "$0 finished: $testspassed tests passed, " .
      "$testsfailed failed" .
      ($testsskipped? ", $testsskipped skipped" : "") . ".\n";

if ($did_something) {
    exit $retval;
} else {
    exit 77;  # magic value meaning "ignore test"
};

sub dicttest {
    my $language = shift;
    my $datadir = $ENV{"srcdir"} . "/../../data/stemming/$language/data";
    my $wordcount = 0;
    my $myretval = $val_succeeded;

    print "Testing $language with fixed dictionary...";
    if (-r "$datadir/voc.txt" &&
        -r "$datadir/voc.st") {
	$did_something = 1;

	if ($verbose) {
	    print "Running \`./stemtest --$language $datadir/voc.txt'...\n";
	};
	open(STEMMER_OUTPUT, "./stemtest --$language $datadir/voc.txt|")
	    or die "Failed to run stemtest";
	open(STEMMED_ANSWERS, "<$datadir/voc.st")
	    or die "Failed to open stemmed data";
	
	while (1) {
	    my $stemmed = <STEMMER_OUTPUT>;
	    my $answer = <STEMMED_ANSWERS>;

	    # if both are undefined, then we've finished
	    if (!defined $stemmed and !defined $answer) {
	        last;
	    };

	    if (defined $stemmed and defined $answer) {
		$wordcount++;

		# we don't want those pesky newlines!
		chomp $stemmed;
		chomp $answer;

	        if ($stemmed ne $answer) {
		    $myretval = $val_failed;
		    if ($verbose) {
		    	print "Got $stemmed, expected $answer\n";
		    };
		    last;
		};
	    } else {
	        $myretval = $val_failed;
		if ($verbose) {
		    print "Got an unexpected EOF\n";
		};
		last;
	    };
		    
	};
	print "$wordcount words checked... " . ($myretval? "FAILED" : "ok") . "\n";
    } else {
        print "stemming test data not available in $datadir\n";
	print "(skipping language $language)\n";
	return $val_skipped;
    };
    return $myretval;
};

sub randtest {
    my $system_retval;
    my $myretval = $val_succeeded;
    my $language = shift;
    my $filename = shift;

    my $outputfname = "stemtest.pl$$";

    print "Testing $language with file $filename...";
    $system_retval = system("./stemtest --$language $filename > $outputfname 2>&1");
    if ($system_retval) {
        if ($verbose) {
	    print "stemtest returned $system_retval\n";
	};
        $myretval = $val_failed;
    } else {
        # do some sanity checks on the result
	my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	    $atime,$mtime,$ctime,$blksize,$blocks) = stat $outputfname;
        
	if (!defined $size) {
	    $myretval = $val_failed;
	    if ($verbose) {
	        print "Unable to stat output file.\n";
	    };
	} elsif ($size >= ($junksize * 1.01)) {
	    $myretval = $val_failed;
	    if ($verbose) {
	        print "Stemmed file is significantly bigger than input ($size vs. $junksize)\n";
	    };
	} elsif ($size < ($junksize / 2)) {
	    $myretval = $val_failed;
	    if ($verbose) {
	        print "Stemmed file is smaller than half the input\n";
	    };
	};
    };

    unlink $outputfname;

    if ($myretval == $val_succeeded) {
        print " ok.\n";
    } else {
        print " FAILED\n";
    };
    return $myretval;
};

# these are inefficient, I know...
sub make_randomtext {
    my $filename = shift;
    my $count = 0;
    my @allowedchars = split(//,
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789^ \n");

    if (-r $filename) {
        print "$filename already exists, skipping generation.\n";
	return;
    };

    open(OUTPUT, ">$filename") or die "Failed to create random text file";

    while ($count < $junksize) {
        print OUTPUT $allowedchars[int(rand(@allowedchars))];
	$count++;
    };
    close OUTPUT;
};

sub make_randomjunk {
    my $filename = shift;
    my $count = 0;

    if (-r $filename) {
        print "$filename already exists, skipping generation.\n";
	return;
    };

    open(OUTPUT, ">$filename") or die "Failed to create random junk file";

    while ($count < $junksize) {
        print OUTPUT pack("C", int(rand(256)));
	$count++;
    };
    close OUTPUT;
};
