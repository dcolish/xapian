<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Xapian: Overview</TITLE>
</HEAD>
<BODY BGCOLOR="white" TEXT="black">

<H1>Overview</H1>

<P>
This document provides an introduction to the native C++ Xapian API.
This API provides programmers with the ability to search through
(potentially very large) bodies of data using probabilistic methods.
</P>

<P>
<EM>Note:</EM>
The portion of the API currently documented here covers only the part
of Xapian concerned with searching through existing databases, not that
concerned with creating them.
</P>

<P>
<EM>Note:</EM>
This document is out of date in places.
</P>

<P>
It is probably a good idea to read the
<A HREF="intro_ir.html">Introduction to Information Retrieval</A> and
<A HREF="install.html">Installing Xapian</A> before reading this document,
or at least before attempting to use the API.  You may also wish to read
the <A HREF="quickstart.html">QuickStart</A> reference, for some simple
worked examples of Xapian usage.
</P>

<P>
This document does not detail the exact calling conventions (parameters
passed, return value, exceptions thrown, etc...) for each method in the API.
For such documentation, you should refer to the automatically extracted
documentation, which is generated from detailed comments in the source code,
and should thus remain up-to-date and accurate.  This documentation is
generated using the
<EM><A HREF="http://www.doxygen.org/">Doxygen</A></EM>
application.  To save you having to generate this documentation yourself,
we include the <A HREF="apidoc/html/index.html">built version</A>
in our distributions, and also keep the
<A HREF="http://xapian.org/docs/apidoc/html/index.html">latest version</A> on our website.
</P>

<H2>Design Priciples</H2>

<P>
API objects keep a reference to other objects they rely on so the user
doesn't need to worry about whether an object is still valid or not.
</P>

<P>
Most API classes are handles - copying is like copying a pointer.  The
exception is the iterator classes, which act like STL iterators.
</P>

<H2>Errors and exceptions</H2>

<P>
Error reporting is often relegated to the back of manuals such as this.
However, it is extremely important to understand the errors which may be
caused by the operations which you are trying to perform.
</P>

<P>
This becomes particularly relevant when using a large system, with such
possibilities as databases which are being updated while you search
through them, and distributed enquiry systems.
</P>

<P>
Errors in Xapian are all reported by means of exceptions.  All exceptions
thrown by Xapian will be subclasses of
<A HREF="apidoc/html/class_Xapian::Error.html"><CODE>Xapian::Error</CODE></A>.  Note that
<CODE>Xapian::Error</CODE> is an abstract class; thus you must catch exceptions
by reference rather than by value.
</P>

<P>
There are two flavours of error, derived from <CODE>Xapian::Error</CODE>:
<UL><LI>
<A HREF="apidoc/html/class_Xapian::LogicError.html"><CODE>Xapian::LogicError</CODE></A>
- for error conditions due to programming errors, such as a misuse of the
API.  A finished application should not receive these errors (though it
would still be sensible to catch them).
</LI><LI>
<A HREF="apidoc/html/class_Xapian::RuntimeError.html"><CODE>Xapian::RuntimeError</CODE></A>
- for error conditions due to run time problems, such as failure to open
a database.  You must always be ready to cope with such errors.
</LI></UL>
</P>

<P>
Each of these flavours is further subdivided, such that any particular
error condition can be trapped by catching the appropriate exception.
If desired, a human readable explanation of the error can be retrieved
by calling
<A HREF="apidoc/html/class_Xapian::Error.html"><CODE>Xapian::Error::get_msg()</CODE></A>.
</P>

<P>
In addition, standard system errors may occur: these will be reported by
throwing appropriate exceptions.  Most notably, if the system runs out
of memory, a <CODE>std::bad_alloc()</CODE> exception will be thrown.
</P>

<H2>Terminology</H2>
<H3>Databases</H3>
<P>
These may also occasionally be called <EM>Indexes</EM>.  In Xapian (as
opposed to a database package) a database consists of little more than
indexed documents: this reflects the purpose of Xapian as an information
retrieval system, rather than an information storage system.
</P>
<P>
The exact contents of a database depend on the type (see
&quot;<A HREF="#database_types">Database Types</A>&quot; for more details
of the database types currently provided).
</P>

<H3>Queries</H3>
<P>
The information to be searched for is specified by a <EM>Query</EM>.  In
Xapian, queries are made up of a structured boolean tree, upon which
probabilistic weightings are imposed: when the search is performed, the
documents returned are filtered according to the boolean structure, and
weighted (and sorted) according to the probabilistic model of information
retrieval.
</P>

<H2>Memory handling</H2>
<P>
The user of Xapian does not usually need to worry about how Xapian performs
its memory allocation: Xapian objects can all be created and deleted as any
other C++ objects.  The convention is that whoever creates an object
is ultimately responsible for deleting it.  This becomes relevant when
passing a pointer to data to Xapian: Xapian will not assume that such
pointers remain valid across separate API calls, and it will be the
callers responsibility to delete the object pointed to, as and when
required.
</P>

<H2>The Xapian::Enquire class</H2>

<P>
The <A HREF="apidoc/html/classXapian_1_1Enquire.html"><CODE>Xapian::Enquire</CODE></A> class
is central to all searching operations.  It provides an interface for
<UL><LI>
Specifying the database, or databases, to search across.
</LI><LI>
Specifying a query to perform.
</LI><LI>
Specifying a set of documents which a user considers relevant.
</LI><LI>
Given the supplied information, returning a ranked set of documents for
the user.
</LI><LI>
Given the supplied information, suggesting a ranked set of terms to add to the
query.
</LI><LI>
Returning information about the documents which matched, such as their
associated data, and which terms from the query were found within them.
</LI></UL>
</P>
<P>
A typical enquiry session will consist of most of these operations, in
various orders.  The Xapian::Enquire class presents as few restrictions as
possible on the order in which operations should be performed.  Although
you must set the query before any operation which uses it, you can call
any of the other methods in any order.
</P>
<P>
Many operations performed by the Xapian::Enquire class are performed lazily (ie,
just before their results are needed).  This need not concern the user
except to note that, as a result, errors may not be reported as soon as
would otherwise be expected.  In particular, errors regarding opening of
the database may be reported when a query is performed (although they
may not: you should catch exceptions in both situations).
</P>

<H2>Specifying a database</H2>

<P>
When creating a Xapian::Enquire object, a database to search must be specified.
Databases are specified by creating a <A
HREF="apidoc/html/classXapian_1_1Database.html"><CODE>Xapian::Database</CODE> object</A>.
Generally, you can just construct the object, passing the pathname to the
database.  Xapian looks at the path and autodetects the database type.
</P>
<P>
In some cases (with the Remote backend, or if you want more control) you
need to use a factory function such as <CODE>Xapian::Quartz::open()</CODE>
- each backend type has one or more.  The parameters the function
takes depend on the backend type, and whether we are creating a read-only
or a writable database.
</P>
</P>
<P>
You can also create a "stub database" file which list one or more databases.
These files are recognised by the autodetection in the Database constructor
(if the pathname is file rather than a directory, it's treated as a stub
database file) or you can open them explicitly using Xapian::Auto::open_stub().
The stub database format specifies one database per line.  For example:

<BLOCKQUOTE><CODE>
remote localhost:23876<br>
quartz /var/spool/xapian/webindex<br>
</CODE></BLOCKQUOTE>

<A NAME="database_types"><H3>Database types</H3></A>
The current types understood by Xapian are:
</P>
<TABLE>
<TR><TD VALIGN="top"><B>quartz</B></TD><TD>
<P>
This is the main database type, which should be used in almost all cases.
The format allows progressive modifications, single-writer multiple-reader
access to the database, and highly efficient and scalable access to data.
</P>
<P>
You access a Quartz database using Xapian::Database and Xapian::WritableDatabase objects
constructed by the factory function <A
HREF="apidoc/html/database_8h.html"><CODE>Xapian::Quartz::open()</CODE></A>.
<!-- FIXME: hard to link direct to functions, as the name ids may change... -->
</P>
</TD></TR>
<TR><TD VALIGN="top"><B>da_flimsy</B></TD><TD>
<P>
This is a proprietary, legacy format, holding a database in a
non-updateable form (ie, the database can't be altered, it is built
from an existing database).  We support read-only access to this,
and it is only likely to be useful to those with a legacy Muscat 3.6
based system.
</P><P>
This takes one, two or three parameters.  If one parameter is supplied,
it represents the path to a directory containing the Record file in a file
called &quot;R&quot;, the Term file in a file called &quot;T&quot;, and
optionally the fast access key file in a file called &quot;keyfile&quot;
</P><P>
If two parameters are supplied, they represent the full paths to the
Record and Term file, respectively.  In this case, there is assumed to be
no keyfile.
</P><P>
If three parameters are supplied, the first two are the full paths to the
Record and Term files, respectively, and the third is the full path to
the keyfile.
</P>
</TD></TR>
<TR><TD VALIGN="top"><B>da_heavy</B></TD><TD>
This is a variant of da_flimsy, allowing access to the &quot;heavy duty&quot;
variant for larger documents.  This is the format produced by the
&quot;makeda&quot; utility, and was useful in early Xapian development before
we had designed our own disk based backend.
<BR>
It takes the same parameters as da_flimsy.
</TD></TR>
<TR><TD VALIGN="top"><B>db_flimsy</B></TD><TD>
<P>
This is another proprietary, legacy format supported by Muscat 3.6.  The
Muscat 3.6 DB format support a database in a dynamically
updateable form (ie, the database can be altered while queries are being
performed on it.)  Xapian only supports read-only access to this format.
</P><P>
This takes one or two parameters.  The first parameter is the full path to
the DB file.
</P><P>
If a second parameter is supplied, it represents the full path to the fast
access keyfile.  If a second parameter is not supplied, the keyfile will
be searched for at &lt;first_parameter&gt;_keyfile; if this doesn't exist,
no keyfile will be used.
</P><P>
It takes one parameter, which is the full path to the DB file.
</P>
</TD></TR>
<TR><TD VALIGN="top"><B>db_heavy</B></TD><TD>
This is a variant of db_flimsy, allowing access to the &quot;heavy duty&quot;
variant for larger documents.
<BR>
It takes the same parameters as db_flimsy.
</TD></TR>
<TR><TD VALIGN="top"><B>inmemory</B></TD><TD>
This type is a database held entirely in memory.
It was originally written for testing purposes only, but may
prove useful for building up temporary small databases.
<BR>
It takes no parameters at all.
</TD></TR>
</TABLE>

<H3>Multiple databases</H3>

<P>
Xapian can search across several databases as easily as searching across a
single one.  Simply call
<A HREF="apidoc/html/classXapian_1_1Database.html"><CODE>Xapian::Database::add_database()</CODE></A>
for each database that you wish to search through.
</P>
<P>
Other operations, such as setting the query, may be performed before or after
this call.  It is even possible to perform a query, add a further database,
and then perform the query again to get the results with the extra database
(although this isn't very likely to be useful in practice).
</P>

<H2>Specifying a query</H2>

<P>
Xapian implements both boolean and probabilistic searching.
There are two obvious ways in which a pure boolean query can be combined
with a pure probabilistic query:
<UL><LI>
First perform the boolean search to create a subset of the whole document
collection, and then do the probabilistic search on this subset, or
</LI><LI>
Do the probabilistic search, and then filter out the resulting documents
with a boolean query.
</LI></UL>
There is in fact a subtle difference in these two approaches. In the first,
the collection statistics for the probabilistic query will be
determined by the document subset which is obtained by running the boolean
query. In the second, the collection statistics for the probabilistic
query are determined by the whole document collection. These differences
can affect the final result.

</P>
<P>
Suppose for example the boolean query is
being used to retrieve documents in English in a database
containing English and French documents.
A word like
&quot;<EM>grand</EM>&quot;,
exists in both languages (with similar meanings), but is commoner in French
than English. In the English subset it could therefore be expected to have a higher
weight than it would get in the joint English and French
databases.

</P>
<P>
In fact Xapian, as described below, goes for the second approach, which
can be implemented very efficiently, despite the the fact that the first
is more exact.

</P>
<P>
In reality, Xapian performs the combined boolean and probabilistic searches
simultaneously.  This allows various optimisations to be performed, such
as giving up on calculating a boolean AND operation when the probabilistic
weights that could result from further documents can have no effect on the
result set.  These optimisations have been found to give a two- or
three-fold performance increase in certain cases.  The performance is
particularly good for queries containing many terms.
</P>

<H3>A query for a single term</H3>
<P>
All queries are represented by
<A HREF="apidoc/html/classXapian_1_1Query.html"><CODE>Xapian::Query</CODE></A>
objects.  The simplest possible (non-trivial) query is one which searches
for a single term.  This can be created as follows (where <CODE>tname</CODE> is the term to be searched for):
</P>
<PRE>
Xapian::Query query(tname);
</PRE>
<P>
A term in Xapian is represented simply by a string of binary characters.
Usually, when searching text, these characters will be the word which the
term represents, but during the information retrieval process Xapian
attaches no specific meaning to the term.
</P>
<P>
This constructor actually takes a couple of extra parameters, which may be
used to specify positional and frequency information for terms in the query:
<P>
<PRE>
Xapian::Query(const string &amp; tname_,
        Xapian::termcount wqf_ = 1,
        Xapian::termpos term_pos_ = 0)
</PRE>
<P>
The <CODE>wqf</CODE> (<B>W</B>ithin <B>Q</B>uery <B>F</B>requency) is
a measure of how common a term is in the query.  This is particularly useful
when generating a query from an existing document, but may also be used
as a crude way of increasing the importance of a term in a query.  Note that,
if the intention is simply to ensure that a particular term is in the query
results, you should use a boolean AND rather than set a high wqf.
</P>
<P>
The <CODE>term_pos</CODE> represents the position of the term in the query.
This is used for phrase searching, passage retrieval, and other operations
which require knowledge of the order of terms in the query (such as returning
the set of matching terms in a given document in the same order as they
occur in the query).  If such operations are not required, the default
value of 0 may be used.
</P>
<P>
Note that it may not make much sense to specify a wqf other than 1 when
supplying a term position (unless you are trying to affect the weighting,
as previously described).
</P>
<P>
Note also that the results of <CODE>Xapian::Query(tname, 2)</CODE> and
<CODE>Xapian::Query(Xapian::Query::OP_OR, Xapian::Query(tname), Xapian::Query(tname))</CODE>
are exactly equivalent.
</P>

<H3>Compound queries</H3>
<P>
Out of single term queries, compound queries can be built up. A compound
is made up from two sub-queries with a connecting operator, where each
sub-query is a compound query or a single term query. This is done using
the following constructor:
</P>
<PRE>
Xapian::Query(Xapian::Query::op op_,
        const Xapian::Query &amp; left,
        const Xapian::Query &amp; right)
</PRE>
<P>
The two most commonly used operators are <CODE>Xapian::Query::OP_AND</CODE> and
<CODE>Xapian::Query::OP_OR</CODE>, which enable us to construct boolean queries made
up from the usual AND and OR operations. But in addition to this, a
probabilistic query in its simplest form, where we have a list of terms
which give rise to weights that need to be added together, is also made up
from a set of terms joined together with <CODE>Xapian::Query::OP_OR</CODE>.
</P>
<P>
The full set of available <CODE>Xapian::Query::op</CODE> operators is:
<TABLE>
<TR><TD VALIGN="top">
Xapian::Query::OP_AND
</TD><TD>
Return documents returned by both subqueries.
</TD></TR><TR><TD VALIGN="top">
Xapian::Query::OP_OR
</TD><TD>
Return documents returned by either subquery.
</TD></TR><TR><TD VALIGN="top">
Xapian::Query::OP_AND_NOT
</TD><TD>
Return documents returned by the left subquery but not the right subquery.
</TD></TR><TR><TD VALIGN="top">
Xapian::Query::OP_FILTER
</TD><TD>
As Xapian::Query::OP_AND, but use only weights from left subquery.
</TD></TR><TR><TD VALIGN="top">
Xapian::Query::OP_AND_MAYBE
</TD><TD>
Return documents returned by the left subquery, but adding
document weights from both subqueries.
</TD></TR><TR><TD VALIGN="top">
Xapian::Query::OP_XOR
</TD><TD>
Return documents returned by one subquery only.
</TD></TR><TR><TD VALIGN="top">
Xapian::Query::OP_NEAR
</TD><TD>
Return documents where the terms are with the specified distance of each other.
</TD></TR><TR><TD VALIGN="top">
Xapian::Query::OP_PHRASE
</TD><TD>
Return documents where the terms are with the specified distance of each other
and in the given order.
</TD></TR><TR><TD VALIGN="top">
Xapian::Query::OP_WEIGHT_CUTOFF
</TD><TD>
Return only results with a weight greater than or equal to a specified cutoff
value.
</TD></TR><TR><TD VALIGN="top">
Xapian::Query::OP_ELITE_SET
</TD><TD>
Select an elite set of terms from the subqueries, and perform
a query with all those terms combined as an OR query.
</TD></TR>
</TABLE>
</P>


<H3>Understanding queries</H3>

<P>
Each term, t, in the query has a weight, w<sub>Q</sub>(t), given by

<PRE>
                     (K' + 1) f'<sub>t</sub>
             w<sub>Q</sub>(t) = ------------- w(t)
                      K'L' + f'<sub>t</sub>

</PRE>

where f'<sub>t</sub> is the wqf of t in the query, L' is the nql, or normalised query
length, and K' is a constant. And the weight w(t) is given by,


<PRE>
                   (r + h) (N - R - n + r + h)
        w(t) = log ---------------------------, where h = 1/2
                    (R - r + h) (n - r + h)
</PRE>

See the <A HREF="intro_ir.html">Introduction to Information Retrieval</A>
for a full discussion. For any particular document, D, if t indexes D, there
is a weight w<sub>D</sub>(t), which is the contribution, or partial score, of
term t to the total score for document D, and it is given by,

<PRE>
                     (K + 1) f<sub>t</sub>
             w<sub>D</sub>(t) = ---------- w<sub>Q</sub>(t)
                      KL + f<sub>t</sub>

</PRE>

</P>
<P>
A query can be thought of as a tree structure. At each node is
an <CODE>Xapian::Query::op</CODE> operator, and on the left and right branch are two other queries.
At each leaf node is a term, t, transmitting documents and scores, D and
w<sub>D</sub>(t),
up the tree.
</P>
<P>
A Xapian::Query::OP_OR node transmits documents from both branches up the tree, summing the scores
when a document is found in both the left and right branch. For example,

<PRE>
                           docs       1    8    12    16    17    18
                           scores    7.3  4.1   3.2  7.6   3.8   4.7 ...
                             |
                             |
                   Xapian::Query::OP_OR
                         /       \
                        /         \
                       /           \
                      /             \
   docs     1   12   16   17         1   8   16   18
   scores  3.1 3.2  3.1  3.8 ...    4.2 4.1 4.5  4.7 ...
</PRE>

A Xapian::Query::OP_AND node transmits only the documents found on both
branches up the tree, again summing the scores,

<PRE>
                           docs       1   16
                           scores    7.3  7.6  ...
                             |
                             |
                   Xapian::Query::OP_AND
                         /       \
                        /         \
                       /           \
                      /             \
   docs     1   12   16   17         1   8   16   18
   scores  3.1 3.2  3.1  3.8 ...    4.2 4.1 4.5  4.7 ...
</PRE>

A Xapian::Query::OP_AND_NOT node transmits up the tree the documents on the
left branch which are not on the right branch. The scores are taken from the
left branch. For example, again summing the scores,

<PRE>
                           docs       12   17
                           scores    3.2  3.8 ...
                             |
                             |
                 Xapian::Query::OP_AND_NOT
                         /       \
                        /         \
                       /           \
                      /             \
   docs     1   12   16   17         1   8   16   18
   scores  3.1 3.2  3.1  3.8 ...    4.2 4.1 4.5  4.7 ...
</PRE>

A Xapian::Query::OP_MAYBE node transmits the documents up the tree from the
left branch only, but adds in the score from the right branch for documents
which occur on both branches.  For example,

<PRE>
                           docs       1    12   16   17
                           scores    7.3  3.2  7.6  3.8 ...
                             |
                             |
                Xapian::Query::OP_AND_MAYBE
                         /       \
                        /         \
                       /           \
                      /             \
   docs     1   12   16   17         1   8   16   18
   scores  3.1 3.2  3.1  3.8 ...    4.2 4.1 4.5  4.7 ...
</PRE>

Xapian::Query::OP_FILTER is like Xapian::Query::OP_AND, but weights are only
transmitted from the left branch.  For example,

<PRE>
                           docs       1   16
                           scores    3.1  3.1  ...
                             |
                             |
                  Xapian::Query::OP_FILTER
                         /       \
                        /         \
                       /           \
                      /             \
   docs     1   12   16   17         1   8   16   18
   scores  3.1 3.2  3.1  3.8 ...    4.2 4.1 4.5  4.7 ...
</PRE>
Xapian::Query::OP_XOR is like Xapian::Query::OP_OR, but documents on both left
and right branches are not transmitted up the tree. For example,

<PRE>
                           docs       8    12    17    18
                           scores    4.1   3.2  3.8   4.7 ...
                             |
                             |
                      Xapian::Query::OP_XOR
                         /       \
                        /         \
                       /           \
                      /             \
   docs     1   12   16   17         1   8   16   18
   scores  3.1 3.2  3.1  3.8 ...    4.2 4.1 4.5  4.7 ...
</PRE>
<!--Xapian::Query::OP_XOR is used internally, but we have not found a plausible use for it in query
construction, so it will not be mentioned again.-->
</P>
<P>
A query can therefore be thought of as a process for generating an M set from
the terms at the leaf nodes of the query. Each leaf node gives rise to a
posting list of documents with scores. Each higher level node gives rise to a
similar list, and the root node of the tree contains the final set of documents
with scores (or weights), which are candidates for going into the M set. The M
set contains the documents which get the highest weights, and they are held in
the M set in weight order.
</P>
<P>
It is important to realise that within Xapian the structure of a query is
optimised for best performance, and it undergoes various transformations as the
query progresses. The precise way in which the query is built up is therefore
of little importance.
</P>

<H3>Using queries</H3>

A plain probabilistic query is created by connecting terms together with
Xapian::Query::OP_OR operators. For example,

<PRE>
    Xapian::Query query("regulation"));
    query = Xapian::Query(Xapian::Query::OP_OR, query, Xapian::Query("import"));
    query = Xapian::Query(Xapian::Query::OP_OR, query, Xapian::Query("export"));
    query = Xapian::Query(Xapian::Query::OP_OR, query, Xapian::Query("canned"));
    query = Xapian::Query(Xapian::Query::OP_OR, query, Xapian::Query("fish"));

</PRE>

This creates a probabilistic query with terms `regulation', `import', `export',
`canned' and `fish'.
<P>
In fact this style of creation is so common that there is the shortcut
construction:

<PRE>
    vector &lt;string&gt; terms;
    terms.push_back("regulation");
    terms.push_back("import");
    terms.push_back("export");
    terms.push_back("canned");
    terms.push_back("fish");

    Xapian::Query query(Xapian::Query::OP_OR, terms.begin(), terms.end());
</PRE>

Suppose now we have this Boolean query,
<PRE>
    ('EEC' - 'France') and ('1989' or '1991' or '1992') and 'Corporate Law'
</PRE>

This could be built up as bquery like this,

<PRE>
    Xapian::Query bquery1(Xapian::Query::OP_AND_NOT, "EEC", "France");

    Xapian::Query bquery2("1989");
    bquery2 = Xapian::Query(Xapian::Query::OP_OR, bquery2, "1991");
    bquery2 = Xapian::Query(Xapian::Query::OP_OR, bquery2, "1992");

    Xapian::Query bquery3("Corporate Law");

    Xapian::Query bquery(Xapian::Query::OP_AND, bquery1, Xapian::Query(Xapian::Query::OP_AND(bquery2, bquery3)));
</PRE>

and this can be attached as a filter to <code>query</code> to run the
probabilistic query with a Boolean filter,

<PRE>
    query = Xapian::Query(Xapian::Query::OP_FILTER, query, bquery);
</PRE>

<!-- This doesn't work - you need to set a boolean weight object
This is the general technique for processing boolean queries, so to run a
pure boolean query, attach it as a filter to an undefined query:

<PRE>
    bquery = Xapian::Query(Xapian::Query::OP_FILTER, Xapian::Query(), bquery);
    // bquery will now run as a pure boolean
</PRE>
-->

A common requirement in search engine functionality is to run a
probabilistic query where some terms are required to index all the
retrieved documents (`+' terms), and others are required to
index none of the retrieved documents (`-' terms). For example,

<PRE>
    regulation import export +canned +fish -japan
</PRE>

the corresponding query can be set up by,

<PRE>
    vector &lt;string&gt; plus_terms;
    vector &lt;string&gt; minus_terms;
    vector &lt;string&gt; normal_terms;

    plus_terms.push_back("canned");
    plus_terms.push_back("fish");

    minus_terms.push_back("japan");

    normal_terms.push_back("regulation");
    normal_terms.push_back("import");
    normal_terms.push_back("export");

    Xapian::Query query(Xapian::Query::OP_AND_MAYBE,
                  Xapian::Query(Xapian::Query::OP_AND, plus_terms.begin(), plus_terms.end());
                  Xapian::Query(Xapian::Query::OP_OR, normal_terms.begin(), normal_terms.end()));

    query = Xapian::Query(Xapian::Query::OP_AND_NOT,
                    query,
                    Xapian::Query(Xapian::Query::OP_OR, minus_terms.begin(), minus_terms.end()));
</PRE>

<H3>Undefined queries</H3>
<P>
Performing a match with an undefined query matches nothing, which is sometimes
useful.  However an undefined query can't be used with operators to compose
a query.
</P>

<H2>Retrieving the results of a query</H2>

<P>
The Xapian::Enquire class does not require that a method be called in order to
perform the query.  Rather, you simply ask for the results of a query,
and it will perform whatever calculations are necessary to provide the
answer:
</P>
<PRE>
Xapian::MSet <A HREF="apidoc/html/classXapian_1_1Enquire.html">Xapian::Enquire::get_mset</A>(Xapian::doccount first,
                           Xapian::doccount maxitems,
                           const Xapian::RSet * omrset = 0,
                           const Xapian::MatchDecider * mdecider = 0) const
<!-- FIXME check parameters -->
</PRE>
<P>
When asking for the results, you must specify (in <CODE>first</CODE>) the
first item in the result set to return, where the numbering starts at zero
(so a value of
zero corresponds to the first item returned being that with the highest
score, and a value of 10 corresponds to the first 10 items being ignored,
and the returned items starting at the eleventh).
</P>
<P>
You must also specify (in <CODE>maxitems</CODE>) the maximum number of
items to return.  Unless there are not enough matching items, precisely
this number of items will be returned.
If <CODE>maxitems</CODE> is zero, no items will be returned, but the usual
statistics (such as the maximum possible weight which a document could be
assigned by the query) will be calculated.  (See &quot;The Xapian::MSet&quot;
below).
</P>

<H3>The Xapian::MSet</H3>
<P>
Query results are returned in an
<A HREF="apidoc/html/classXapian_1_1MSet.html"><CODE>Xapian::MSet</CODE></A> object.
The results can be accessed using a
<A HREF="apidoc/html/classXapian_1_1MSetIterator.html"><CODE>Xapian::MSetIterator</CODE></A>
which returns the matches in descending sorted order
of relevance (so the most relevant document is first in the list).
Each <CODE>Xapian::MSet</CODE> entry comprises a document id, and the weight
calculated for that document.
</P>
<P>
An <CODE>Xapian::MSet</CODE> also contains various information about the search
result:
<TABLE>
<TR><TD VALIGN="top">
<CODE>firstitem</CODE>
</TD><TD>
The index of the first item in the result which was put into the mset.
(Corresponding to <CODE>first</CODE> in
<CODE>Xapian::Enquire::get_mset()</CODE>)
</TD></TR><TR><TD VALIGN="top">
<CODE>max_attained</CODE>
</TD><TD VALIGN="top">
The greatest weight which is attained in the full results of the search.
</TD></TR><TR><TD VALIGN="top">
<CODE>max_possible</CODE>
</TD><TD VALIGN="top">
The maximum possible weight in the mset.
</TD></TR><TR><TD VALIGN="top">
<CODE>docs_considered</CODE>
</TD><TD VALIGN="top">
The number of documents matching the query considered for the mset.
This provides a lower bound on the number of documents in the database
which have a weight greater than zero.  Note that this value may change
if the search is recalculated with different values for <CODE>first</CODE> or
<CODE>max_items<CODE>.
</TD><TR>
</TABLE>
</P>
<P>
See the <A HREF="apidoc/html/classXapian_1_1MSet.html">automatically extracted documentation</A>
for more details of these fields.
</P>
<P>
The <CODE>Xapian::MSet</CODE> also provides methods for converting the score
calculated for a given document into a percentage value, suitable for
displaying to a user.  This may be done using the
<A HREF="apidoc/html/classXapian_1_1MSet.html"><CODE>convert_to_percent()</CODE></A>
methods:
<PRE>
     int Xapian::MSet::convert_to_percent(const Xapian::MSetIterator &amp; item) const
     int Xapian::MSet::convert_to_percent(Xapian::weight wt) const
</PRE>
These methods return a value in the range 0 to 100, which will be
0 if and only if the item did not match the query at all.
</P>

<H3>Getting the document's data</H3>
<P>
Each document in the database has some data associated with it,
represented by an
<A HREF="apidoc/html/classXapian_1_1Document.html"><CODE>Xapian::Document</CODE></A> object.
There are some arbitrary numeric keys (which are not yet available,
and mainly useful in the match process) and an arbitrary lump of
data.  To get the <CODE>Xapian::Document</CODE> object, use
<A HREF="apidoc/html/classXapian_1_1Enquire.html"><CODE>Xapian::Enquire::get_doc()</CODE></A>.
The returned <CODE>Xapian::Document</CODE> is fairly cheap to copy around.
</P> <P>
This data can be used to store a summary of the document along
with a URL, for example, or anything else the application developer
would like.
</P><P>
The data can be retrieved with
<A HREF="apidoc/html/classXapian_1_1Document.html"><CODE>Xapian::Document::get_data()</CODE></A>
from the <CODE>Xapian::Document</CODE> object.  This returns
a C++ string containing the data.  It can include embedded nulls
or other special characters.
</P>

<H2>Specifying a relevance set</H2>
<P>
Xapian supports the idea of relevance feedback: that is, of allowing the user
to mark documents as being relevant to the search, and using this information
to modify the search.  This is supported by means of relevance sets, which
are simply sets of document ids which are marked as relevant.  These
are held in <A HREF="apidoc/html/classXapian_1_1RSet.html"><CODE>Xapian::RSet</CODE></A> objects,
one of which may optionally be supplied to Xapian in the
<CODE>omrset</CODE> parameter when calling
<CODE>Xapian::Enquire::get_mset()</CODE>.
</P>

<H3>Match options</H3>

<P>
There are various additional options which may be specified when
performing the query.  These are specified by calling
<A HREF="apidoc/html/classXapian_1_1Enquire.html">various methods
of the <CODE>Xapian::Enquire</CODE> object</A>.
The options are as follows.
</P>
<TABLE>
<TR><TD VALIGN="top">
<B>collapse key</B>
</TD><TD VALIGN="top">
Each document in a database may have a set of numbered keys.   The
contents of each key is a string of arbitrary length.
The <CODE>set_collapse_key</A>(Xapian::valueno collapse_key)</CODE>
method specifies a key number upon which to remove duplicates.
Only the most recently set duplicate removal key is active at any time, and the
default is to perform no duplicate removal.
</TD></TR><TR><TD VALIGN="top">
<B>percentage cutoff</B>
</TD><TD VALIGN="top">
It may occasionally be desirable to exclude any documents which have a
weight less than a given percentage value.  This may be done using
<CODE>set_cutoff(Xapian::percent percent_cutoff)</A></CODE>.
</TD></TR><TR><TD VALIGN="top">
<B>sort direction</B>
</TD><TD VALIGN="top">
Some weighting functions may frequently result in several documents being
returned with the same weight.  In this case, by default, the documents
will be returned in ascending document id order.  This can be changed
by using
<CODE>set_sort_forward()</A></CODE>
to set the sort direction.  <CODE>set_sort_forward(false)</CODE> may be
useful, for example, when it would be best to return the newest documents,
and new documents are being added to the end of the database.
</TD></TR>
</TABLE>

<H3>Match decision functors</H3>
<P>
Sometimes it may be useful to return only documents matching criteria
which can't be easily represented by queries.  This can be done using
a match decision functor.  To set such a condition, derive a class
from <CODE>Xapian::MatchDecider</CODE> and override the function operator,
<CODE>operator()(const Xapian::Document &amp;doc)</CODE>.  The operator can make
a decision based on the document values via <CODE>Xapian::Document::get_value(Xapian::valueno)</CODE>.
</p>
<p>
The functor will also have access to the document data stored in the
database (via <CODE>Xapian::Document::get_data()</CODE>), but beware that, for
most database backends, this is an expensive operation and is likely to slow
down the search considerably.
</P>

<H2>Expand - Suggesting new terms for the query</H2>
<P>
Xapian also supports the idea of calculating terms to add to the
query, based on the relevant documents supplied.  A set of such
terms, together with their weights, may be returned by:
<PRE>
Xapian::ESet Xapian::Enquire::<A HREF="apidoc/html/classXapian_1_1Enquire.html">get_eset</A>(Xapian::termcount maxitems,
                           const Xapian::RSet &amp; omrset,
			   bool exclude_query_terms = true,
			   bool use_exact_termfreq = false,
			   double k = 1.0,
			   const Xapian::ExpandDecider * edecider = 0) const;
Xapian::ESet Xapian::Enquire::<A HREF="apidoc/html/classXapian_1_1Enquire.html">get_eset</A>(Xapian::termcount maxitems,
                           const Xapian::RSet &amp; omrset,
                           const Xapian::ExpandDecider * edecider) const
</PRE>
</P>
<P>
As for <CODE>get_mset</CODE>, up to <CODE>maxitems</CODE> expand terms
will be returned, with fewer being returned if and only if no more terms
could be found.
</P>
<P>
The expand terms are returned in sorted weight order in an
<A HREF="apidoc/html/classXapian_1_1ESet.html"><CODE>Xapian::ESet</CODE></A> item.
</P>

<H3>exclude_query_terms</H3>
<P>
By default terms which are already in the query will never be returned by
<CODE>get_eset()</CODE>.  If <CODE>exclude_query_terms</CODE> is
<CODE>false</CODE>) then query terms may be returned.
</P>

<H3>use_exact_termfreq</H3>
<P>
By default, Xapian uses an approximation to the term frequency when
<CODE>get_eset()</CODE> is called when searching over multiple databases.
This approximation improves performance, and usually still returns good
results.  If you're willing to pay the performance penalty, you can
get Xapian to calculate the exact term frequencies by passing <CODE>true</CODE>
for <CODE>use_exact_termfreq</CODE>.
</P>

<H3>Expand decision functors</H3>
<P>
It is often useful to allow only certain classes of term to be returned
in the expand set.  For example, there may be special terms in the
database with various prefixes, which should be removed from the expand
set.  This is accomplished by providing a decision functor.  To do this,
derive a class from <CODE>Xapian::ExpandDecider</CODE> and override the
function operator, <CODE>operator()(const string &amp;)</CODE>.
The functor is called with each term before it is added to the set,
and it may accept (by returning <CODE>true</CODE>) or reject (by returning
<CODE>false</CODE>) the term as appropriate.
</P>

<H2>Thread safety</H2>
<P>
There's no pthread specific code in Xapian.  If you want to use the same
object concurrently from different threads, it's up to you to police access
(with a mutex or in some other way) to ensure only one method is being
executed at once.  The reason for this is to avoid adding the overhead
of locking and unlocking mutexes when they aren't required.  It also makes
the Xapian code easier to maintain, and simplifies building it.

<P>
For most applications, this is unlikely to be an issue - generally the
calls to Xapian are likely to be from a single thread.  And if they aren't,
you can just create an entirely separate Xapian::Database object in each thread
- this is no different to accessing the same database from two different
processes.
</P>

<H2>Examples</H2>
<P>
Extensively documented examples of simple usage of the Xapian API for
creating databases and then for searching through them are given in the
<A HREF="quickstart.html">QuickStart</A> tutorial.
</P>
<P>
Further examples of usage of Xapian are available in the xapian-examples package.
</P>

<!-- FOOTER $Author$ $Date$ $Id$ -->
</BODY>
</HTML>
