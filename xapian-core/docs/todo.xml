<todo>
<todoitem priority="V" difficulty="" owner="" area="Matcher" release="">

Possible optimisation:  Consider using hash_map instead of map in various
places - two possible such locations are i) doing collapsem (in
matcher/multimatch.cc) and ii) in the inmemory database.

</todoitem>
<todoitem priority=" " difficulty="" owner="Olly" area="API" release="">

Should it be possible to specify an arbitrary docid for a document (perhaps to
match numeric docids in another system?)  This is potentially useful, though
bad for compression in the backend.  Currently replace_document() fails
if the document id doesn't exist already (at least with quartz).

</todoitem>
<todoitem priority="L" difficulty="" owner="Olly" area="Quartz" release="1.0">

Shouldn't stall just because a stale db_lock exists - instead of just an
empty file, put the hostname and pid in the file (or use a symlink with the
info in the target since that can be created atomically) and check the details
- that way we can spot a stale lock from a process on the same machine.
Or touch the lock periodically to keep it?  Or use fcntl(), except that
doesn't handle locking within a process, so it needs to be combined with
another locking scheme, which I think boils down to needing thread locks
to work in a multi-threaded process...

<!-- map<pair<dev_t, inode_t>, bool> locks; lock.find(make_pair(dev, ino)); -->

Leave thread-level locking to the user?

</todoitem>
<todoitem priority="M" difficulty="5" owner="" area="Debug" release="">

Try to find some way to write a thread identifier into the debug log, while
not depending of pthreads.  Try dlsym() on pthread_self?
(pthread_t pthread_self(void)) (code in comment in todo.xml).

<!--
This works on all platforms I've tried except on MacOS X where it seems that
dlsym(NULL, ...) doesn't do what we want:

#include <dlfcn.h>
#include <pthread.h>
#ifndef RTLD_DEFAULT
#define RTLD_DEFAULT NULL
#endif
...
pthread_t
get_threadid(void)
{
    pthread_t (*pt_s)(void) = (pthread_t (*)(void))dlsym(RTLD_DEFAULT, "pthread_self");
    if (!pt_s) return (pthread_t)0;
    return pt_s();
}

Could do this inline in a header and on some platforms use:

#ifdef WE_ARE_USING_THREADS
class foo {
   foo() { Xapian::pthread_self = pthread_self; }
};

static foo bar;
#endif
-->

</todoitem>
<todoitem priority="L" difficulty="2" owner="" area="Matcher" release="">

Pass around partially created postlists and termlists as AutoPtrs?
(for exception safety)

</todoitem>
<todoitem priority="M" difficulty="5" owner="" area="Performance" release="">

Write (speed) performance test suite.

</todoitem>
<todoitem priority="M" difficulty="2" owner="" area="General" release="0.8">

Check for zero byte cleanness wherever strings are used.  There are a
number of c_str()s in the code, but I believe all in the core library
(excluding the bindings) are harmless at 2002-04-29.  There may be other zero
byte issues though.  xapian-applications/dbtools also uses c_str() where it
should probably use data() and length().

</todoitem>
<todoitem priority="M" difficulty="4" owner="" area="General" release="1.0">

Allow setting of the document length in Xapian::Document?  (Currently defined to
be the sum of the wdfs, which is perhaps the correct definition).

</todoitem>
<todoitem priority="M" difficulty="2" owner="" area="General" release="">

Make all errors return a context if appropriate.

</todoitem>
<todoitem priority="M" difficulty="5" owner="James" area="Porting" release="1.0">

Produce Microsoft Windows version, probably cross-compiling to mingw.  0.6.5
can be built with a mingw cross-compiler.  Test suite not tried.

</todoitem>
<todoitem priority="M" difficulty="3" owner="" area="Matcher" release="">

Implement collapse keys for duplicate removal - which only fire if the
two documents have the same weight.

</todoitem>
<todoitem priority="M" difficulty="3" owner="" area="Matcher" release="">

Check that negative term weights don't mess up matcher's optimisations - if
they do we need to either disallow negative term weights, or fix/disable the
optimisations for the case of negative term weights.

</todoitem>
<todoitem priority="M" difficulty="3" owner="" area="Documentation" release="">

Patch doxygen, so that todo items in the body of methods get displayed.

</todoitem>
<todoitem priority="M" difficulty="3" owner="" area="Exceptions" release="">

Make exceptions work with shared libs on solaris / find an alternative. (gcc
+ Solaris =&gt; DISABLE_SHARED)

</todoitem>
<todoitem priority="M" difficulty="2" owner="" area="Xapian::Query" release="1.0">

Move all serialisation of Xapian::Query into Xapian::Query (out of
socketcommon.cc and localmatch): modification of omquery requires
changes in 3 separate parts of the code, at present.

</todoitem>
<todoitem priority="M" difficulty="5" owner="Olly" area="Documentation" release="1.0">

Ensure that API documentation covers entirety of API (i.e. that all methods and
classes in the API have documentation comments) -- see doxygen generated file
docs/doxygen_api_warnings for a list of undocumented methods.  Then read
through generated API docs, and rewrite doc comments to improve clarity and
make them more coherent.

</todoitem>
<todoitem priority="M" difficulty="4" owner="" area="Matcher" release="">

Create a synonym postlist, which represents a set of postlists merged together,
such that each document that occurs in any of the sublists occurs in the list,
the term frequency is the number of documents that one or more of the terms
occurs in, and the term weight corresponds.

Will need approximation schemes for determining the term frequency.

</todoitem>
<todoitem priority="M" difficulty="5" owner="" area="Documentation" release="">

Document backend API (database, postlist, termlist, document, etc) in same
way as enquire API.  Eventually we want backends to be "user"-definable in
the same way weighting objects are.

</todoitem>
<todoitem priority="M" difficulty="4" owner="" area="Matcher" release="">

Allow negative relevance judgements?  Will need to check that this doesn't
cause assumptions to be violated. (eg, unsigned integers going negative.)

</todoitem>
<todoitem priority="M" difficulty="3" owner="" area="Databases" release="1.0">

Change all internal references to net/network backend to remote backend (in
step with external naming)

</todoitem>
<todoitem priority="V" difficulty="5" owner="" area="DA backend" release="">

Autodetect heavy-duty vs flimsy (3 byte vs 2 byte)

</todoitem>
<todoitem priority="M" difficulty="4" owner="" area="Matcher" release="">

Treat FILTER and AND as equivalent from the point of view of building
optimal AND trees.  Also add a variant on FilterPostList where the left
branch is boolean and the right probabilistic.  Resist urge to call
it RETFIL.

</todoitem>
<todoitem priority="L" difficulty="3" owner="" area="Quartz" release="">

Clean up interaction of AllTermsIterator for quartz with QuartzPostList.
Need QuartzPostListTermsIterator class?  (But with a snappier name. ;-) )

</todoitem>
<todoitem priority="M" difficulty="3" owner="" area="Quartz" release="0.8">

Make quartz database autoflush when enough changes have been performed based
on the memory used up as a proportion of that available, rather than simply
when a count of changes is reached.  Remove hardcoded count of 1000 changes.

</todoitem>
<todoitem priority="M" difficulty="3" owner="Olly" area="API" release="0.8">

Provide fake term (empty termname) which indexes all documents, thus providing
a clean way to iterate through them.  This would be used for a real "NOT"
operator.  Olly has a patch which mostly implements this for the InMemory
backend.

</todoitem>
<todoitem priority="L" difficulty="4" owner="" area="API" release="">

Provide explicit support for range searches, such as
"RangePostList" - combine a sequence of adjacent terms...

</todoitem>
<todoitem priority="L" difficulty="5" owner="" area="Matcher" release="">

OP_ELITE_SET should never select groups of terms which don't match any
documents.  (Currently, will exclude those for which termfreq_max() is 0,
but this may still result in a bad choice)

</todoitem>
<todoitem priority="L" difficulty="4" owner="" area="Matcher" release="">

OP_ELITE_SET should probably reduce the querysize by the number of terms
removed.  When making a contribution to querysize, could just use the lesser
of the number of terms, and elite_set_size.

</todoitem>
<todoitem priority="L" difficulty="3" owner="" area="Documentation" release="1.0">

Add notes about catching exceptions throughout userman, particularly in
examples (eg, search engine example)

</todoitem>
<todoitem priority="L" difficulty="5" owner="" area="General" release="">

Audit for exception safety.

</todoitem>
<todoitem priority="L" difficulty="3" owner="" area="API" release="">

Re-implement Xapian::BatchEnquire, and add back into the system.

</todoitem>
<todoitem priority="L" difficulty="5" owner="" area="Positional" release="">

Passage retrieval.

</todoitem>
<todoitem priority="L" difficulty="5" owner="" area="Matcher" release="">

Clustering algorithms.

</todoitem>
<todoitem priority="L" difficulty="4" owner="" area="General" release="">

Allow user written backends?  Be good to allow them to register themselves
automatically at runtime (or linktime perhaps) to replace current conditional
compilation scheme.  Do this using sub-classing and factory classes?  A bit
like the weighting schemes.

</todoitem>
<todoitem priority="V" difficulty="3" owner="" area="Backends" release="">

Split database definition files into database/postlist/termlist files.

</todoitem>
<todoitem priority="V" difficulty="4" owner="" area="General" release="">

A few classes get copied a lot (notably OmExpandBits) - look into doing
copy-on-write for them.  Or perhaps to pass them around more carefully.

</todoitem>
<todoitem priority="D" difficulty="3" owner="" area="Exceptions" release="">

Add error handlers to (at least) Xapian::Database.  Implement more carefully in
MergePostlist.

</todoitem>
<todoitem priority="D" difficulty="3" owner="" area="Decision functors" release="">

Return a sensible value for Xapian::MSet::matches_lower_bound when a decision
functor is present.  This has to be the number of documents that the decision
functor tested and approved, as we know there are at least that many and
can't know if there are more.  matches_upper_bound can be reduced by the
number of documents that the functor rejected, and matches_estimated
can be adjusted somehow - perhaps look at the reject rate of the functor?
Partly done I believe.

</todoitem>
<todoitem priority="D" difficulty="3" owner="" area="API" release="">

Do allow boolean subqueries in Xapian::Query constructors, where
it makes sense (or note in documentation to use FILTER).

</todoitem>
<todoitem priority="D" difficulty="5" owner="" area="Matcher" release="">

Boolean filters result in collection statistics being for the wrong set of
documents (should be appropriate subset).  Hard (impossible?) to implement
efficiently.

</todoitem>
<todoitem priority="M" difficulty="2" owner="" area="Quartz" release="1.0">

Ensure that quartz databases don't have a problem if there is no positional
information entry available for a term / document combination.

</todoitem>
<todoitem priority="L" difficulty="3" owner="" area="Matcher" release="">

Add synonym postlists.  Need to be able to take underlying postlists which
aren't necessarily just postlists for single terms, and to be able to
estimate termfrequency of combined postlists.

</todoitem>
<todoitem priority="L" difficulty="5" owner="" area="Postlists" release="">

Add get_termfreq_exact() methods, for calculating the exact termfreq.  This
will be particularly useful when trying to do evaluations to check up on the
approximations being made.

Also, add get_termfreq_better_est() methods, which give an approximation to the
exact termfreq based on the first N items in the postlist.

This may require adding a reset() method, to move a postlist's position back to the beginning.

</todoitem>
<todoitem priority="L" difficulty="3" owner="" area="Postlists" release="">

Add OP_FILTER_TERM_WITH_EXACT_WEIGHT query operator (with better name), which
will perform a restriction of the LHS term based on the RHS query, but use the
exact termfrequency for the combined term to calculate the weight.  This will
share some techniques from implementing synonym postlists.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

"make install" on omega should install CGI binary somewhere more helpful
(improved somewhat - now goes in /usr/lib/omega/bin/omega; RPMs install
it in cgi-bin directory).

</todoitem>
<todoitem priority=" " difficulty="" owner="Olly" area="" release="1.0">

.deb built, control files via autoconf

</todoitem>
<todoitem priority=" " difficulty="" owner="Sam/James" area="Bindings" release="">

Language bindings: Python, PHP and Java (C would be good too).
All can be done using SWIG, and it's probably easier to do so
even though some languages may have better tools
available just because it's less overall work.  We have contributed XS
bindings for Perl, so we may as well keep using those while they're
supported for us.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="Bindings" release="">

Check for swig version.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="Bindings" release="">

Namespace for Java bindings should be org/xapian rather than com/muscat/om.

</todoitem>
<todoitem priority="L" difficulty="5" owner="" area="Bindings" release="">

Ensure that (Java in particular) bindings throw correct exception types.

</todoitem>
<todoitem priority="M" difficulty="" owner="James" area="" release="0.8">

indexgraph -> extra (needs to build as a support library?)  [James
expressed an interest in this as dbtools needs it]

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="omega" release="">

Should Omega have a make static target?  Or just document configure runes?

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="omega" release="">

Need some more stuff in
omindex (--add-term, --add-field) IMHO. Also could do with more
fields as standard, and probably support for subsite as key for
collapse.

</todoitem>
<todoitem priority=" " difficulty="" owner="Sam" area="" release="">

Replace Omega with a simpler PHP or Python-based
system, once the bindings are in place?  Python would be good
because we could use it for omindex as well, and I suspect the code
would be much cleaner, easier to work with, and generally
understandable. For something that should be halfway between a
reasonably large-scale application for Xapian and a complex
example, this can only be a good thing. This probably needs a
query parser library, although it raises questions of consistency
of term generation (word breaks and stemming) across the index
and query tools ... we may want the query parser to have a callback
to deal with that, which can be done in the bindings although it's
a little fiddly in some languages I believe.

</todoitem>
<todoitem priority="M" difficulty="" owner="Olly" area="" release="0.8">

Fix up examples and make sure they are actually instructive.  Add a comment
to each describing what it demonstrates.
I've made a start.  delve is a reasonable example.  msearch probably needs
simplifying to just do a probabilistic search, or to use
Xapian::QueryParser.

</todoitem>
<todoitem priority=" " difficulty="" owner="James" area="" release="*">

Update the PLATFORMS file

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

We talked about use of local vs global databases, and decided it
would be useful to support Unix sockets for local machine databases
so the library can select() on all databases in complex cases. This
is probably something we can leave for a while, and probably
doesn't need to be automatic - so the local process can be fired
by the application, not the library - but at some point should be
thought through and documented properly.  A longer term project.

</todoitem>
<todoitem priority=" " difficulty="" owner="James" area="" release="">

xapian.org: schema pages (not crucial, but would be nice)

</todoitem>
<todoitem priority=" " difficulty="" owner="James" area="" release="*">

make sure the non-autogenerated docs are kept up-to-date

</todoitem>
<todoitem priority=" " difficulty="" owner="James" area="" release="">

Get nightly snapshot builds set up again

</todoitem>
<todoitem priority=" " difficulty="" owner="Olly" area="" release="">

Look at getting the btree code to use pread and pwrite or similar calls 
where available (e.g. on Linux and Solaris).  These combine a seek and
read or write into a single syscall, which halves the syscall overhead and
can make an observable difference to performance.

</todoitem>
<todoitem priority=" " difficulty="" owner="Olly" area="" release="">

Think about using hashing instead of a btree for the backend?  Long term
project.

</todoitem>
<todoitem priority=" " difficulty="" owner="Olly" area="" release="">

Move "min_hits" into matcher?

</todoitem>
<todoitem priority=" " difficulty="" owner="Olly" area="" release="">

Look at reworking StatsGatherer mechanism to be simpler and clearer.

</todoitem>
<todoitem priority=" " difficulty="" owner="Olly" area="" release="">

Find paper about "illusion of control" that boolean operators give.  It's
makes some good points which ought to be more widely aired.

</todoitem>
<todoitem priority=" " difficulty="" owner="Olly" area="" release="">

Sort out some sort of framework for stopwording (Xapian::Stopper class?)  Should
it use static lists (compiled in, perhaps using gperf) or dynamically load
lists?  Stopword lists should be fine tunable in general, so probably the
latter...

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Weight functor decreasing with age to model improved relevance of newer docs.
Prototype is in the code, but a theoretical model to back up the idea would
be good to have.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Quartz compression using a bitstream.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Ability to run a postlist backwards - it's chunked, so this is feasible
(some encodings can even be decoded backwards).  This is useful as we
can add articles in date order and search backwards to do "sort by date".

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="omega" release="">

Allow other date formats in START and END of daterange.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="omega" release="">

Enhance $def: $def{NAME, [min, max, eval, ensure, cache], ...} ?

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Use AC_ARG_VAR in configure if there are any precious env vars not saved by
default.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="remote backend" release="">

sort_bands vs. remote backend doesn't currently work.  Can we get it to?

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Rejig Xapian::ExpandDecider?

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

match bias functors: adjust weights back for display? cutoff?
no weighting? params for bias? abuse term wdf instead of keys?

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Stopwording?  Improve?  Support in Xapian itself?

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="tests" release="">

Make test suite more uniform in structure.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Code size and performance profiling.  Track over time.

Code size is important.  The embedded market and palmtops are a
potential area of application, but we need to be as lean as possible for that.
Better modularisation would help - so you can link retrieval bits, indexer
bits, general bits (such as stemmers), etc separately, and they don't pull
each other in unnecessarily.  Not a problem with shared libs, but static
linking on small devices it is.

Performance: try to base it on real world situations. 

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Near/phrase implementation is hard to follow, and so it's hard to be confident
it's correct.  Perhaps reimplement.  Or write a naive implementation and
compare the results of the two on a large test set.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="1.0">

Tidy up internal class naming.  All internal classes should be in a namespace
too...

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="omega" release="">

omega - $field -> $fields; add new $field to just return first?

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="delve" release="">

delve: show_docdata: different layout for showing several docs

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Change expand to use inverse min heap, rather than nth element,
just like matcher was changed a while ago.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="" release="">

Build test harness to check consistency by composing random queries
and checking the results.  Already sanity check mset size and sorting.
Add checks for %age cutoffs from 0 - 100%, bool filters.

</todoitem>
<todoitem priority=" " difficulty="" owner="" area="omega" release="">

Round the estimated number of matches according to the min and max values.
E.g. if min is 170123, est is 177789 and max is 182342 round est to 180000.
I.e. round it to a multiple of the largest power of 10 which keeps it between
min and max.

</todoitem>
<todoitem priority="" difficulty="" owner="" area="" release="">

Try to reduce unnecessary inclusion of headers - sometimes just saying
"class Xapian::Foo;" is enough.  Look at using iosfwd instead of iostream
where applicable (TC++PL 3ed 8.2.7).

</todoitem>
<todoitem priority="" difficulty="" owner="" area="tests" release="">

Move testsuite to under tests?  Or maybe it'll be used elsewhere...

</todoitem>
<todoitem priority="" difficulty="" owner="" area="tests" release="">

Sort out tests of test harness again.

</todoitem>
<todoitem priority="" difficulty="" owner="" area="matcher" release="">

msetitems are getting heavyweight, and we copy them a lot - restore msetitem to
pair&lt;docid, weight&gt; or just docid and use map&lt;docid, OTHERINFO&gt;?
Or keep pointers to MSetItem so sorting only copies pointers...

</todoitem>
</todo>
