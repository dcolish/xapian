Contents
========

1. A brief guide to running tests
2. A Brief Guide To Writing Tests That's Probably Slightly Wrong
3. Secret Info about the Quartz Backend Test

A Brief Guide to Running Tests
------------------------------

After a successful "make", try "make check"


A Brief Guide To Writing Tests That's Probably Slightly Wrong
-------------------------------------------------------------

Almost all tests live in tests/. (The btree and Quartz backend stuff
has its own tests for internal consistency, which live in
backends/quartz/. I'll ignore them, but read more in the next section)

The tests mostly use a standard test rig, in testsuite/, which wraps
each test, reports results, and generally packages things up nicely. I
think it checks for memory leaks, uncaught exceptions, and so on as
well. There are some tests written in Perl and bash, which I'll ignore
also.

Look at indextest.cc, which is fairly simple. It breaks into three
bits: the tests themselves, at the top, a table of tests at the
bottom, and a tiny main which basically just sets the test rig in
motion. It uses the table to figure out what the tests are called, and
what function to call to run them.

I suspect that the most important test system for most people will be
the apitests. This also uses the test rig, but instead of letting it
do the job with a table, it runs each test itself. There are some
hideous macros going on there. The main() and other bits are in
apitest.cc, and tests themselves are in various other C++ files
starting api_. Each one of these will have its own tables for various
different groups of tests (eg: api_db.cc, which performs tests on the
API that require a database backend, has basic tests, a few
specialised groups that only contain one or two tests, tests that
require a writeable database, tests that require a local database, and
finally tests that require a remote database.

To add a new api test, figure out what the test will be dependent on
and put it in the appropriate place (eg: if adding a test for a bug
that occurs while writing to a database, you want a writeable
database, so you add a test to api_db.cc and reference it in the
writabledb_tests table.

Currently, there's api_nodb.cc (no db required, largely testing query
construction and boundary conditions), api_posdb.cc (db with
positional information required) and api_db.cc (everything else, with
lots of subgroups of tests). It's easiest to base a test on an
existing one.

You'll notice in apitest.cc that it runs all appropriate test groups
against each backend that is being built. We don't build any of the
Muscat 3.6 compatibility stuff any more, so we're basically talking
about inmemory, quartz and remote as backends. If you need to create a
new test group with different requirements to any current ones, put it
in the appropriate api_ file (or create a new one, and add it into
Makefile.am) and remember to add the group to all pertinent backends
in apitest.cc.

Incidentally, when fixing bugs, it's often better to write the test
before fixing the bug. Firstly, it's easier to assure yourself that
the bug is (a) genuine, and (b) fixed, because you see the test go
from fail to pass, and secondly you're more likely to write the test
carefully, because once you've fixed something there's often a feeling
that you should commit it for the good of the world, which tends to
distract you :-)

Secret Info About the Quartz Backend Test
-----------------------------------------

If you'll be testing the btree's ability, those tests are in
backends/quartz/btreetest.cc, or for quartz itself try quartztest.cc.  
(Tests are a bit scattered; low-level tests of parts of the system are
generally in the source directories, while high-level leves are in tests/.
To complicate matters, tests of the stemmers and the indexgraph stuff are
actually in tests/ not in the right place.)

Okay. Basically, most of it you can ignore, because the framework is
done for you. You are responsible for doing two things:

1.	writing a minimal test or tests for the feature
2.	adding that test to the list of tests to be run

2. is simple. There's a test_desc array in each file that comprises a
set of tests (I'll come to that in a minute), and you just add another 
entry. The entry is an array consisting of a name for the test and a
pointer to the function that is the test. Easy.

Look at the bottom of btreetest.cc for the test_desc array. Now look
up about 20 lines for the one and only test (which is why this is a
good example :-). You need to write a function which will return true
or false depending on whether it failed or not.

In addition, there are a bunch of macros you want to use. Things like
TEST_EQUAL are all in testsuite/testsuite.h. They're pretty simple to
use.

Anything else, just ask. And I may have got some bits wrong, but you
should be able to figure it out from the code. :)

