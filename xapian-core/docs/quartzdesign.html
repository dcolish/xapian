<HTML>
<HEAD>
<TITLE>The Quartz Database Backend</TITLE>
</HEAD>
<BODY BGCOLOR="white">

<h1><center>The Quartz database backend</center></h1>

<h2>Status</h2>

WARNING: This document describes a piece of code which is still in
development.  As such, some of the descriptions within it will be
inconsistent with the code to be found in our releases and CVS
repository.  In such cases, the code is out of date if written before
this document (ie, before 20th October), and this document is out of
date if the code was written after this document.  If you find such
inconsistencies, especially this document being out of date, please
alert us to the problem using the Om Discuss mailing list, at
&lt;om-discuss@lists.muscat.com&gt;.
<p>
Once the Quartz backend is stable, this comment should go away.

<h2>Why Quartz?</h2>

<em>
What is this thing called Quartz?  How does it fit in with the OpenMuscat
library?</em>
<p>
OpenMuscat can access information stored in various different formats,
some of which are legacy formats which can be read by OpenMuscat but not
written to (for example, the Muscat3.6 formats &quot;DA&quot; and
&quot;DB&quot;), some of which are essentially testing formats (such as the
InMemory format), and some which are experimental formats (such as the
Sleepycat format, which is fully featured by doesn't scale).
Each of these formats is comprised by a set of classes providing an interface
to a Database object and several other related objects (PostList, TermList,
etc...).

<p>
Quartz is simply the name of a backend which is currently being developed,
which draws from all our past experience to satisfy the following criteria:
<ul>
<li>
  Fast and scalable searches.
</li>
<li>
  May be updated (ie, database doesn't have to be built from scratch in order
  to make a single change).
</li>
<li>
  May be modified whilst searches are in progress.
</li>
<li>
  Provides atomic updates in the face of interruption at any point.
</li>
<li>
  Provides a single-writer, multiple-reader environment.
</li>
</ul>

<p>
Different backends can be optionally compiled into the OpenMuscat library
(by specifying appropriate options to the configure script).  At the moment,
Quartz is not compiled by default since it is incomplete, but eventually it
will become a standard backend, included in all builds (unless explicitly
disabled).  In fact, once complete it may well become the only backend which
will be built by default.

<p>
<em>
Why do we call it Quartz - where does the name come from?
</em>
<p>Well, we had to call it something, and Quartz was
simply the first name we came up with which we thought we could live with...

<h2>Tables</h2>

A Quartz database consists of several tables, each of which stores a
different type of information: for example, one table stores the user-defined
data associated with each document, and another table stores the posting
lists (the lists of documents which particular terms occur in).
<p>
These tables consist of a set of key-tag pairs, which I shall often
refer to these as <em>items</em> or <em>entries</em>.  Items may
be accessed randomly by specifying a key and reading the item
pointed to, or in sorted order by creating a cursor pointing to a
particular item.  The sort order is a lexicographical ordering based
on the contents of the keys.  Only one instance of a key may exist in
a single table - inserting a second item with the same key as an existing
item will overwrite the existing item.
<p>
Positioning of cursors may be performed even when a
full key isn't known, by attempting to access an item which doesn't
exist: the cursor will then be set to point to the first item with a
key before that requested.
<p>
The QuartzTable class defines the standard interface to tables.  This
has two subclasses - the QuartzDiskTable and QuartzBufferedTable 
interface.  The former provides direct access to the table as stored
on disk, and the latter provides access via a large buffer in order to
use the memory as a write cache and greatly speed the process of
indexing.

<h2>The contents of the tables</h2>

We shall worry about the implementation of the tables later, but first
we shall look at what is stored within each table.
<p>
There are six tables comprising a quartz database.
<ul>
<li>
</li><li>
</li><li>
</li><li>
</li><li>
</li><li>
</li>
</ul>

<h2>Btree implementation</h2>

The tables are currently all planned to be implemented as B-trees.
<p>
(The code currently uses a temporary hack to implement tables by reading the
contents of an unstructured file into memory, modifying it, and writing it all
back again.  Martin is working on a B-tree manager, which is complete apart
from some API issues and will be added into the CVS repository within the next
couple of weeks.)
<p>
In some situations, the use of a different structure would be appropriate - in
particular for the lexicon where key ordering is irrelevant, and a hashing
scheme would likely provide more memory and time efficient access.  This
will be investigated once the initial version is fully functional.
<p>
A B-tree is a fairly standard structure for storing this kind of data, so I
will not describe it in detail - see a reference book on database design and
algorithms for that.  The essential points are that it is a block-based
multiply branching tree structure, storing keys in the internal blocks and
key-tag pairs in the leaf blocks.
<p>
Our implementation is fairly standard, except for its revision scheme,
which allows modifications to be applied atomically whilst other processes
are reading the database.  This scheme involves copying each block in the
tree which is involved in a modification, rather than modifying it in
place, so that a complete new tree structure is built up whilst the old
structure is unmodified (although this new structure will typically share a
large number of blocks with the old structure).  The modifications can then
be atomically applied by writing the new root block and making it active.
<p>
After a modification is applied successfully, the old version of the
table is still fully intact, and can be accessed.  The old version only
becomes invalid when a second modification is attempted (and it becomes
invalid whether or not that second modification succeeds).
<p>
There is no need for a process which is writing the database to know
whether any processes are reading previous versions of the database.  As long
as only one update is performed before the reader closes (or reopens) the
database, no problem will occur.  If more than one update occurs whilst
the table is still open, the reader will notice that the database has been
changed whilst it has been reading it by comparing a revision number stored
at the start of each block with the revision number it was expecting.  An
appropriate action can then be taken (for example, to reopen the database
and repeat the operation).
<p>
An alternative approach would be to obtain a read-lock on the revision
being accessed.  A write would then have to wait until no read-locks
existed on the old revision before modifying the database.

<h2>Buffered tables</h2>

If each change to a table (ie, modification of a key-tag pair) was
immediately written to disk, there would be two problems.

<ol>
<li>
The system would be very slow.  If a disk read and then a write was
required each time an item was changed, the indexing process would
spend most of its time waiting for the disk's write head to seek to
the appropriate block.  By buffering up a large set of changes, and
then writing them all out in a sorted order, seeking is minimised.
</li>
<li>
Operations which involve modifying more than one key-tag pair would not
be atomic.  For example, when adding a document to a database the record
table has three items updated - one containing the data stored in the
document, one which stores the next document ID to allocate, and one which
stores the sum of all the document lengths in the database.  These three
items must be updated at the same time, so that a consistent state is always
seen by other processes, and a consistent state remains if the system
is terminated unexpectedly.
</li>
</ol>

<p>
As a result, the QuartzBufferedTable object is available.  This simply
stores a set of modified entries in memory, applying them to disk only
when the apply method is called.
<p>
In fact, a QuartzBufferedTable object has to have two handles open on
the table - one for reading and one for writing.  This is simply
because the interface for writing a table is more limited than that
for reading a table (in particular, cursor operations are not
available).
<p>
(Note: the current temporary implementation of quartz tables doesn't
use two handles.  It doesn't implement Cursor operations yet either.)

<h2>Applying changes to all the tables simultaneously</h2>

This is all wonderful: we have tables storing arbitrary bits of useful
data, we can update bits of them as we like, and we can then call a
method and have all the modifications applied to the table atomically.
Unfortunately, we need more than that - we need to be able to apply
modifications as a single atomic transaction across multiple tables, so
that the tables are always accessed in a mutually consistent state.
<p>
The revisioning scheme described earlier comes to the rescue!  By carefully
making sure that we open all the tables at the same revision, and by ensuring
that at least one such consistent revision always exists, we can extend the
scope of atomicity to cover all the tables.  In detail:

<ul>
<li>
When opening a database, we open each table in a specified order: lets call
the tables <em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>, <em>E</em>,
<em>F</em>, and say we open them in alphabetical order.
</li><li>
When opening a database, after opening the first table, <em>A</em>, at the
newest available revision, we read its revision number.  We then open all
the other tables at the same revision number.
</li><li>
When writing changes to a database, we write the tables in reverse order.
</li>
</ul>

This scheme guarantees that modifications are atomic across all the tables
- essentially we have made the modification get committed only when the
final table is committed.

<h2>Items to be added to this document</h2>

<ul>
<li>
Describe that postlists must be stored in sorted order, for boolean queries, so cannot store in reverse wdf order for efficiency.  A possible workaround is to
store the postlists in two or more chunks, ordered by wdf, and to access them
in this order.
</li>
<li>
An better explanation of why there will always be a consistent set of table
versions using the scheme described above.
</li>
<li>
Describe thread locking system.
</li>
</ul>

<h2>Endnote</h2>

The system as described could, no doubt, be improved in several ways.
If you can think of such ways then suggest it to us,
so we can have a discussion of the improvment to see whether it would
help: if it would we will add it to the design (and eventually the
code) - if not, we'll add a discussion about it to this document.

<!-- FOOTER $Author$ $Date$ $Id$ -->
</BODY>
</HTML>
