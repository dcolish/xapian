<HTML>
<HEAD>
<TITLE>The Quartz Database Backend</TITLE>
</HEAD>
<BODY BGCOLOR="white">

<h1><center>The Quartz database backend</center></h1>

<h2>Status</h2>

WARNING: This document describes a piece of code which is still in
development.  As such, some of the descriptions within it will be
inconsistent with the code to be found in our releases and CVS
repository.  In such cases, the code is out of date if written before
this document (ie, before 20th October), and this document is out of
date if the code was written after this document.  If you find such
inconsistencies, especially this document being out of date, please
alert us to the problem using the Om Discuss mailing list, at
&lt;om-discuss@lists.muscat.com&gt;.
<p>
Once the Quartz backend is stable, this comment should go away.

<h2>Why Quartz?</h2>

<em>
What is this thing called Quartz?  How does it fit in with the OpenMuscat
library?</em>
<p>
OpenMuscat can access information stored in various different formats,
some of which are legacy formats which can be read by OpenMuscat but not
written to (for example, the Muscat3.6 formats &quot;DA&quot; and
&quot;DB&quot;), some of which are essentially testing formats (such as the
InMemory format), and some which are experimental formats (such as the
Sleepycat format, which is fully featured by doesn't scale).
Each of these formats is comprised by a set of classes providing an interface
to a Database object and several other related objects (PostList, TermList,
etc...).

<p>
Quartz is simply the name of a backend which is currently being developed,
which draws from all our past experience to satisfy the following criteria:
<ul>
<li>
  Fast and scalable searches.
</li>
<li>
  May be updated (ie, database doesn't have to be built from scratch in order
  to make a single change).
</li>
<li>
  May be modified whilst searches are in progress.
</li>
<li>
  Provides atomic updates in the face of interruption at any point.
</li>
<li>
  Provides a single-writer, multiple-reader environment.
</li>
</ul>

<p>
Different backends can be optionally compiled into the OpenMuscat library
(by specifying appropriate options to the configure script).  At the moment,
Quartz is not compiled by default since it is incomplete, but eventually it
will become a standard backend, included in all builds (unless explicitly
disabled).  In fact, once complete it may well become the only backend which
will be built by default.

<p>
<em>
Why do we call it Quartz - where does the name come from?
</em>
<p>Well, we had to call it something, and Quartz was
simply the first name we came up with which we thought we could live with...

<h2>Overview</h2>

A Quartz database consists of several tables, each of which stores a
different type of information: for example, one table stores the user-defined
data associated with each document, and another table stores the posting
lists (the lists of documents which particular terms occur in).
<p>
These tables consist of a set of key-tag pairs, which I shall often
refer to these as <em>items</em> or <em>entries</em>.  Items may
be accessed randomly by specifying a key and reading the item
pointed to, or in sorted order by creating a cursor pointing to a
particular item.  The sort order is a lexicographical ordering based
on the contents of the keys.
<p>
Positioning of cursors may be performed even when a
full key isn't known, by attempting to access an item which doesn't
exist: the cursor will then be set to point to the first item with a
key before that requested.
<p>
The QuartzTable class defines the standard interface to tables.  This
has two subclasses - the QuartzDiskTable and QuartzBufferedTable 
interface.  The former provides direct access to the table as stored
on disk, and the latter provides access via a large buffer in order to
use the memory as a write cache and greatly speed the process of
indexing.
<p>
The tables are currently all (planned to be) implemented 
In some situations, the use of a different

<h2>The contents of the tables</h2>

We shall worry about the implementation of the tables shortly, but first
we shall look at what is stored within each table.
<p>
There are six tables comprising a quartz database.
<ul>
<li>
</li><li>
</li><li>
</li><li>
</li><li>
</li><li>
</li>
</ul>

<h2>Btree implementation</h2>

Fairly standard implementation, but for the revision scheme.
Describe how modifications are applied atomically.

<h2>Buffered tables</h2>

If each change to a table (ie, modification of a key-tag pair) was
immediately written to disk, there would be two problems.

<ol>
<li>
The system would be very slow...  If a disk read and then a write was
required each time an item was changed, the indexing process would
spend most of its time waiting for the disk's write head to seek to
the appropriate block.  By buffering up a large set of changes, and
then writing them all out in a sorted order, seeking is minimised.
</li>
<li>
Operations which involve modifying more than one key-tag pair would not
be atomic.  For example, when adding a document to a database the record
table has three items updated - one containing the data stored in the
document, one which stores the next document ID to allocate, and one which
stores the sum of all the document lengths in the database.  These three
items must be updated at the same time, so that a consistent state is always
seen by other processes, and a consistent state remains if the system
is terminated unexpectedly.
</li>
</ol>

<p>
As a result, the QuartzBufferedTable object is available.  This simply
stores a set of modified entries in memory, applying them to disk only
when the apply method is called.
<p>
In fact, a QuartzBufferedTable object has to have two handles open on
the table - one for reading and one for writing.  This is simply
because the interface for writing a table is more limited than that
for reading a table (in particular, cursor operations are not
available).  The 

<h2>Applying changes to all the tables simultaneously</h2>

This is all wonderful: we have tables storing arbitrary bits of useful
data, we can update bits of them as we like, and we can then call a
method and have all the modifications applied to the table atomically.
Unfortunately, we need more than that - we need to be able to apply
modifications to multiple tables atomically, so that the tables are
always accessed in a mutually consistent state.

<p>
The revisioning scheme described earlier comes to the rescue!  By carefully
making sure that we open all the tables at the same revision, and by ensuring
that at least one such consistent revision always exists, we can extend the
scope of atomicity to cover all the tables.  In detail:

<ul>
<li></li>
</ul>

<h2>Items to be added to this document</h2>

<ul>
<li>
Describe that postlists must be stored in sorted order, for boolean queries, so cannot store in reverse wdf order for efficiency.  A possible workaround is to
store the postlists in two or more chunks, ordered by wdf, and to access them
in this order.
</li>
<li>
Describe thread locking system.
</li>
</ul>

<h2>Endnote</h2>

The system as described could, no doubt, be improved in several ways.
If you can think of such ways then suggest it to us,
so we can have a discussion of the improvment to see whether it would
help: if it would we will add it to the design (and eventually the
code) - if not, we'll add a discussion about it to this document.

<!-- FOOTER $Author$ $Date$ $Id$ -->
</BODY>
</HTML>
