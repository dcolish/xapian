<HTML>
<HEAD>
<TITLE>The Quartz Database Backend</TITLE>
</HEAD>
<BODY BGCOLOR="white" TEXT="black">

<h1><center>The Quartz database backend</center></h1>

<h2>Status</h2>

WARNING: This document describes a piece of code which is still in
development.  As such, some of the descriptions within it will be
inconsistent with the code to be found in our releases and CVS
repository.  In such cases, the code is out of date if written before
this document (ie, before 2000-10-20), and this document is out of
date if the code was written after this document.  If you find such
inconsistencies, especially this document being out of date, please
alert us to the problem using the discussion mailing list, at
&lt;xapian-discuss@lists.sourceforge.net&gt;.

<P>(Document at least partially updated 2002-10-13, and subsequently...)

<h2>Why Quartz?</h2>

<em>
What is this thing called Quartz?  How does it fit in with the Xapian
library?</em>
<p>
Xapian can access information stored in various different formats.
For example, there are the legacy formats which can be read by Xapian but not
written to (at present, the Muscat 3.6 formats &quot;DA&quot; and
&quot;DB&quot;), and the InMemory format which is held in memory.

<p>
Each of these formats is comprised by a set of classes providing an interface
to a Database object and several other related objects (PostList, TermList,
etc...).

<p>
Quartz is simply the name of only currently supported disk-based backend
which allows databases to be dynamically updated.  The design of Quartz
draws on all our past experience to satisfy the following criteria:
<ul>
<li>
  Fast and scalable searches.
</li>
<li>
  May be updated (ie, database doesn't have to be built from scratch in order
  to make a single change).
</li>
<li>
  May be modified whilst searches are in progress.
</li>
<li>
  Provides atomic updates in the face of interruption at any point.
</li>
<li>
  Provides a single-writer, multiple-reader environment.
</li>
</ul>

<p>
Different backends can be optionally compiled into the Xapian library
(by specifying appropriate options to the configure script).  Quartz
is compiled by default.

<p>
<em>
Why do we call it Quartz - where does the name come from?
</em>
<p>Well, we had to call it something, and Quartz was
simply the first name we came up with which we thought we could live with...

<h2>Tables</h2>

A Quartz database consists of several tables, each of which stores a
different type of information: for example, one table stores the user-defined
data associated with each document, and another table stores the posting
lists (the lists of documents which particular terms occur in).
<p>
These tables consist of a set of key-tag pairs, which I shall often
refer to these as <em>items</em> or <em>entries</em>.  Items may
be accessed randomly by specifying a key and reading the item
pointed to, or in sorted order by creating a cursor pointing to a
particular item.  The sort order is a lexicographical ordering based
on the contents of the keys.  Only one instance of a key may exist in
a single table - inserting a second item with the same key as an existing
item will overwrite the existing item.
<p>
Positioning of cursors may be performed even when a
full key isn't known, by attempting to access an item which doesn't
exist: the cursor will then be set to point to the first item with a
key before that requested.
<p>
The QuartzTable class defines the standard interface to tables.  This
has two subclasses - the QuartzDiskTable and QuartzBufferedTable 
interface.  The former provides direct access to the table as stored
on disk, and the latter provides access via a large buffer in order to
use the memory as a write cache and greatly speed the process of
indexing.

<h2>The contents of the tables</h2>

We shall worry about the implementation of the tables later, but first
we shall look at what is stored within each table.
<p>
There are six tables comprising a quartz database.
<ul>
<li>
<B>Record</B>.
This stores the arbitrary chunk of data associated with each document.
<p>
Key: lsb ... msb of the docid, until all remaining bytes are zero
<p>
It also stores a couple of special fields - one containing the next
document ID to use when adding a document (document IDs are allocated in
increasing order, starting at 1, and are currently never reused), and one
field containing the total length of the documents in the database.  This
latter quantity is used for calculation of the average document length, and
hence for calculation of normalised document lengths.
<p>
</li><li>
<B>Value</B>.
This stores a set of values for each document 
<p>
Currently, there is one item for each document in the database, which
consists of a list of value_no-s and values for that document.  The
alternative implementation is to store an item for each value, whose
key is a combination of the document ID and the keyno, and whose tag is the
value.
<p>
Which implementation is better depends on the access pattern: if a document
is being passed across a network link, all the values for a document
are read - if a document is being dealt with locally, usually only some of
the values will be read.
<p>
Documents will usually have very few values, so the current
implementation may actually be the most suitable.
<p>
</li><li>
<b>Lexicon</b>.
This stores some information about each term in the database in a fast
access form.  <b>At present the Lexicon is disabled to see if this
has a negative impact on performance</b>.
<p>
For each term in the database, this has an entry whose key is the term, and
whose contents are the term frequency for that term.  This is intended to be a
fast access table, so that processes can determine the term frequency (and
hence weight) of a term quickly, whether for the purpose of doing an
expand or for the purpose of selecting important terms.
<p>
Speed of access to this table is likely to be critical - attempting to
ensure that the most frequently used part of the lexicon is always cached
in memory to a large extent is likely to give high rewards.  Alternatively
it might be possible to optimise the PostList table in such a way that the
Lexicon can be removed and the PostList table used instead...
<p>
</li><li>
<b>TermList</b>.
This stores the list of terms which appear in a document.
<p>
Key: lsb ... msb of the docid, until all remaining bytes are zero
<p>
The list first stores the document length, and the number of entries in the
termlist (this latter value is stored for quick access - it could also be
determined by running through the termlist).  It then stores a set of
entries: each entry in the list consists of a term (as a string), and the
wdf (within document frequency - how many times the term appears in the
document) of that term.
<p>
In a non-modifiable database, the term frequency could be stored in the
termlist for each entry in each list.  This would enable query expansion
operations to occur significantly faster by avoiding the need for a large
number of extra lookups - however, this cannot be implemented in a
writable database without causing any modifications to modify a very large
proportion of the database.
<p>
</li><li>
<b>PositionList</b>.
For each (term,&nbsp;document) pair, this stores the list of positions in the
document at which the term occurs.
<p>
</li><li>
<b>PostList</b>.
This stores the list of documents in which each term appears.
<p>
</li>
</ul>

<h2>Representation of integers, strings, etc.</h2>

It is well known that in modern computers there are many, many CPU cycles
for each disk read, or even memory read.  It is therefore important to
minimise disk reads, and can be advantageous to do so even at the expense of
a large amount of computation.  In other words, <em>Compression is
good</em>.
<p>
The current implementation uses simple compression - we're investigating
more effective schemes - these are:
<ul>
<li>
In posting lists, successive document IDs are stored as a difference
which is compressed using a byte-wise huffman encoding (so it's stored
in 7, 14, 21, 28, ... bits):
<ol>
<li>
First byte: if integer is &lt; 128, store integer, otherwise store
integer modulo 128, but with top bit set.
</li><li>
Shift integer right 7 places.
</li><li>
Second byte: if integer is &lt; 128, store integer, otherwise store
integer modulo 128, but with top bit set.
</li><li>
Shift integer right 7 places.
</li><li>
etc...
</li>
</ol>
<p>
</li><li>
In position lists, successive positions are encoded similarly.
<p>
</li><li>
In termlists, terms are stored as string values in sorted order.  Although
not currently done, we intend to store the differences between successive
terms to reduce storage size.
<p>
</li>
</ul>

<h2>PostLists and chunks.</h2>

Posting lists can grow to be very large - some terms occur in a very large
proportion of the documents, and their posting lists can represent a
significant fraction of the size of the whole database.  Therefore, we do
not wish to read an entire posting list into memory at once.  (Indeed, we'd
rather only read a small portion of it at all, but that's a different
story - see the documentation on <A HREF="matcherdesign.html">optimisations
performed by the matcher</A>.
<p>
To deal with this, we store posting lists in small chunks, each the right
size to be stored in a single B-tree block, and hence to be accessed with a
minimal amount of disk latency.  
<p>
The key for the first chunk in a posting list is the term ID of the term
whose posting list it is.  The key in subsequent chunks is the term ID
followed by the document ID of the first document in the chunk.  This
allows the cursor methods to be used to scan through the chunks in order,
and also to jump to the chunk containing a particular document ID.

<p>
It is quite possible that data in other tables (eg, termlist and possibly
position lists) would benefit from being split into chunks in this way.

<h2>Btree implementation</h2>

The tables are currently all implemented as B-trees (actually a form of
B-tree which I think is often know as a B+ tree).
<p>
In some situations, the use of a different structure could be appropriate - in
particular for the lexicon where key ordering is irrelevant, and a hashing
scheme might provide more memory and time efficient access.  This
is an area for future investigation.
<p>
A B-tree is a fairly standard structure for storing this kind of data, so I
will not describe it in detail - see a reference book on database design and
algorithms for that.  The essential points are that it is a block-based
multiply branching tree structure, storing keys in the internal blocks and
key-tag pairs in the leaf blocks.
<p>
Our implementation is fairly standard, except for its revision scheme,
which allows modifications to be applied atomically whilst other processes
are reading the database.  This scheme involves copying each block in the
tree which is involved in a modification, rather than modifying it in
place, so that a complete new tree structure is built up whilst the old
structure is unmodified (although this new structure will typically share a
large number of blocks with the old structure).  The modifications can then
be atomically applied by writing the new root block and making it active.
<p>
After a modification is applied successfully, the old version of the
table is still fully intact, and can be accessed.  The old version only
becomes invalid when a second modification is attempted (and it becomes
invalid whether or not that second modification succeeds).
<p>
There is no need for a process which is writing the database to know
whether any processes are reading previous versions of the database.  As long
as only one update is performed before the reader closes (or reopens) the
database, no problem will occur.  If more than one update occurs whilst
the table is still open, the reader will notice that the database has been
changed whilst it has been reading it by comparing a revision number stored
at the start of each block with the revision number it was expecting.  An
appropriate action can then be taken (for example, to reopen the database
and repeat the operation).
<p>
An alternative approach would be to obtain a read-lock on the revision
being accessed.  A write would then have to wait until no read-locks
existed on the old revision before modifying the database.

<h2>Buffered tables</h2>

If each change to a table (ie, modification of a key-tag pair) was
immediately written to disk, there would be two problems.

<ol>
<li>
The system would be very slow.  If a disk read and then a write was
required each time an item was changed, the indexing process would
spend most of its time waiting for the disk's write head to seek to
the appropriate block.  By buffering up a large set of changes, and
then writing them all out in a sorted order, seeking is minimised.
</li>
<li>
Operations which involve modifying more than one key-tag pair would not
be atomic.  For example, when adding a document to a database the record
table has three items updated - one containing the data stored in the
document, one which stores the next document ID to allocate, and one which
stores the sum of all the document lengths in the database.  These three
items must be updated at the same time, so that a consistent state is always
seen by other processes, and a consistent state remains if the system
is terminated unexpectedly.
</li>
</ol>

<p>
As a result, the QuartzBufferedTable object is available.  This simply
stores a set of modified entries in memory, applying them to disk only
when the apply method is called.
<p>
In fact, a QuartzBufferedTable object has to have two handles open on
the table - one for reading and one for writing.  This is simply
because the interface for writing a table is more limited than that
for reading a table (in particular, cursor operations are not
available).
<p>
(Note: the current temporary implementation of quartz tables doesn't
use two handles.  It doesn't implement Cursor operations yet either.)

<h2>Applying changes to all the tables simultaneously</h2>

This is all wonderful: we have tables storing arbitrary bits of useful
data, we can update bits of them as we like, and we can then call a
method and have all the modifications applied to the table atomically.
Unfortunately, we need more than that - we need to be able to apply
modifications as a single atomic transaction across multiple tables, so
that the tables are always accessed in a mutually consistent state.
<p>
The revisioning scheme described earlier comes to the rescue!  By carefully
making sure that we open all the tables at the same revision, and by ensuring
that at least one such consistent revision always exists, we can extend the
scope of atomicity to cover all the tables.  In detail:

<ul>
<li>
When opening a database, we open each table in a specified order: lets call
the tables <em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>, <em>E</em>,
<em>F</em>, and say we open them in alphabetical order.
</li><li>
When opening a database, after opening the first table, <em>A</em>, at the
newest available revision, we read its revision number.  We then open all
the other tables at the same revision number.
</li><li>
When writing changes to a database, we write the tables in reverse order.
</li>
</ul>

This scheme guarantees that modifications are atomic across all the tables
- essentially we have made the modification get committed only when the
final table is committed.

<h2>Items to be added to this document</h2>

<ul>
<li>
Describe that postlists must be stored in sorted order, for boolean queries, so cannot store in reverse wdf order for efficiency.  A possible workaround is to
store the postlists in two or more chunks, ordered by wdf, and to access them
in this order.
</li>
<li>
An better explanation of why there will always be a consistent set of table
versions using the scheme described above.
</li>
<li>
Mention that future versions will allow the database creator to decide
whether to store certain levels of detail in the database - eg, whether to
store document lengths, term frequencies in the termlists, document lengths
in the posting lists, etc.
</li>
<li>
Mention that when writing to a database, items are kept in the packed form
they are stored in on disk and simply scanned through, modified and written
on-the-fly.  This minimises memory use, allowing more data to be cached,
and hopefully keeping performance high.
</li>
<li>
Add comment about the inversion process - we are essentially doing a text
based partitioning scheme.
</li>
<li>
Mention adding documents: usual to add with a new document ID which is
greater than any currently in the system.  This means that new postings
get added to the end of posting lists (so we make it easy to get to the
end of a posting list quickly).  Also, we key position lists by document
ID first and termname second, so that new positionlists get added to the
end of the positionlist database, meaning that hardly any blocks will need
to be altered in this database: data just gets added to the end.
</li>
</ul>

<h2>Endnote</h2>

The system as described could, no doubt, be improved in several ways.
If you can think of such ways then suggest it to us,
so we can have a discussion of the improvement to see whether it would
help: if it would we will add it to the design (and eventually the
code) - if not, we'll add a discussion about it to this document.

<h1><center>The Btree Implementation</center></h1>

[Note: the Btree code used to be object-like C, evolved through a strange
mishmash of this and C++, and is now pretty much "normal" C++.  These docs
may not be fully up-to-date with these changes (FIXME - check)]

<P>
I'm not sure about the name 'Btree' that runs through all this, since the fact
that it is all implemented as a B-tree is surely irrelevant. I have not been
able to think of a better name though ...

<P>
Some of the constants mentioned below depend upon a byte being 8 bits, but this
assumption is not built into the code.

<H2>Keys and tags</H2>

Thinking of 'byte' having type 'unsigned char', a key and a tag are both
sequences of bytes. The B-tree is a repository for key-tag pairs. A key can be
looked up to find its corresponding tag. If a key is deleted, the corresponding
tag is deleted. And in the B-tree keys are unique, so if a key-tag pair is
added in and the key is already in the Btree, the tag to be added in replaces
the tag in the B-tree.

<P>In the B-tree key-tag pairs are ordered, and the order is the ASCII collating
order of the keys. Very precisely, if key1 and key2 point to keys with lengths
key1_len, key2_len, key1 is before/equal/after key2 according as the following
procedure returns a value less than, equal to or greater than 0,

<pre>
static int compare_keys(const byte * key1, int key1_len,
			const byte * key2, int key2_len)
{
    int smaller = key1_len &lt; key2_len ? key1_len : key2_len;
    for (int i = 0; i &lt; smaller; i++) {
        int diff = (int) key1[i] - key2[i];
        if (diff != 0) return diff;
    }
    return key1_len - key2_len;
}
</pre>

<P>[This is okay, but none of the code fragments below have been checked.]

<P>
Any large-scale operation on the B-tree will run very much faster when the keys
have been sorted into ASCII collating order. This fact is critical to the
performance of the B-tree software.

<P>
A key-tag pair is called an 'item'. The B-tree consists therefore of a list of
items, ordered by their keys:

<pre>
    I<sub>1</sub>  I<sub>2</sub>  ...  I<sub>j-1</sub>  I<sub>j</sub>  I<sub>j+1</sub>  ...  I<sub>n-1</sub>  I<sub>n</sub>
</pre>

<P>
Item I<sub>j</sub> has a 'previous' item, I<sub>j-1</sub>, and a 'next' item, I<sub>j+1</sub>.

<P>
When the B-tree is created, a single item is added in with null key and null
tag. This is the 'null item'. The null item may be searched for, and it's
possible, although perhaps not useful, to replace the tag part of the null
item. But the null item cannot be deleted, and an attempt to do so is merely
ignored.

<P>
A key must not exceed 252 bytes in length, and will have a smaller upper limit
if the block size of the B-tree is less than 1086 bytes.

<P>
A tag may have length zero. There is an upper limit on the length of a tag, but
it is quite high. Roughly, the tag is divided into items of size L - kl, where
L is a a few bytes less than a quarter of the block size, and kl is length of
its key. You can then have 64K such items. So even with a block size as low as
2K and key length as large as 100, you could have a tag of 2.5 megabytes. More
realistically, with a 16K block size, the upper limit on the tag size is about
256 megabytes.

<H2>Revision numbers</H2>

<P>The B-tree has a revision number, and each time it is updated, the revision
number increases. In a single transaction on the B-tree, it is first opened,
its revision number, R is found, updates are made, and then the B-tree is
closed with a supplied revision number. The supplied revision number will
typically be R+1, but any R+k is possible, where k &gt; 0.

<P>
If this sequence fails to complete for some reason, revision R+k of the B-tree
will not, of course, be brought into existence. But revision R will still
exist, and it is that version of the B-tree that will be the starting point for
later revisions.

<P>
If this sequence runs to a successful termination, the new revision, R+k,
supplants the old revision, R. But it is still possible to open the B-tree at
revision R. After a successful revision of the B-tree, in fact, it will have
two valid versions: the current one, revision R+k, and the old one, revision R.

<P>
You might want to go back to the old revision of a B-tree if it is being
updated in tandem with second B-tree, and the update on the second B-tree
fails. Suppose B1 and B2 are two such B-trees. B1 is opened and its latest
revision number is found to be R1. B2 is opened and its latest revision number
is found to be R2. If R1 &gt; R2, it must be the case that the previous
transaction on B1 succeeded and the previous transaction on B2 failed. Then B1
needs to opened at its previous revision number, which must be R1.

<P>
The calls using revision numbers described below are intended to handle this
type of contingency.

<H2>The files</H2>

The B-tree has five associated files. DB contains the data proper of the
B-tree. The revision numbers, and other administrative information, are held in
two files, baseA and baseB. When the B-tree is opened without any particular
revision number being specified, the later of baseA and baseB is chosen as the
opening base, and as soon as a write to the file DB occurs, the earlier of
baseA or baseB is deleted. On closure, the new revision number is written to
baseB if baseA was the opening base, and to baseA if baseB was the opening
base. If the B-tree update fails for some reason, only one base will usually
survive.

<P>Corresponding to baseA and baseB are two files bitmapA and bitmapB. Bit n is
set in the bitmap if block n is in use in the corresponding revision of the
B-tree.

<H2>The API</H2>

Most of the procedures described below can return with an error condition. Error
conditions are described later. Meanwhile, the code examples given here ignore
the possibility of errors. Bad practice, but it makes them more readable.

<pre>
<!--int-->void Btree::create(const string &amp; name, int block_size);
</pre>

<blockquote>
    Creates a new B-tree with the given name and block size.
    <!--The integer result gives an error condition.-->
    On error, throws an exception.
<pre>
        <!--error_condition = -->Btree::create("/home/martin/develop/btree/", 8192);

        Btree::create("X-", 6000); /* files will be X-bitmapA, X-DB etc */
</pre>

    The block size must be less than 64K, where K = 1024. It is unwise to
    use a small block size (less than 1024 perhaps), but it is not at present
    forbidden.
</blockquote>

<P>
Thereafter there are two modes for accessing the B-tree: update and retrieval.

<H2>Update mode</H2>

<pre>
<!--bool-->void Btree::open_to_write(const string &amp; name);
</pre>

<blockquote>
    The name is the same as the one used in creating.  Throws an exception
    in case of error.  E.g:
<pre>
        Btree_open_to_write("/home/martin/develop/btree/");
</pre>
</blockquote>

<pre>
string::size_type B-&gt;max_key_len;
</pre>

<blockquote>
    This gives the upper limit of the size of a key that may
    be presented to the B-tree. As mentioned above, it will be 252 if the
    B-tree block size exceeds 1086 bytes, otherwise less. But it is of course
    good practice to use B-&gt;max_key_len, rather than writing '252' into your
    code.
<p>
    Note that for tiny B-tree block sizes this number becomes ridiculously
    small. (It is 3 when the block size is 100 bytes.)
</blockquote>

<pre>
uint4 B-&gt;revision_number;
</pre>

<blockquote>
    This gives the revision number of the B-tree.  
    (The type uint4 is an unsigned integral type at least 4 bytes in size).
</blockquote>

<pre>
uint4 B-&gt;other_revision_number;
</pre>

<blockquote>
    Similarly, this gives the revision number held in the other base file of the
    B-tree, or is zero if there is only one base file, and
</blockquote>

<pre>
bool B-&gt;both_bases;
</pre>

<blockquote>
    is true iff both files baseA and baseB exist as valid bases.
</blockquote>

<pre>
bool Btree::open_to_write(const string &amp; name, unsigned long revision);
</pre>

<blockquote>
    Like Btree_open_to_write, but open at the given revision number, and returns
    false if the database couldn't be opened at the requested revision.
</blockquote>

<pre>
bool Btree::add(const string &amp;key, const string &amp;tag);
</pre>

<blockquote>
    Adds the given key-tag pair to the B-tree. e.g.

<pre>
        ok = B-&gt;add("TODAY", "Mon 9 Oct 2000");

        ok = B-&gt;add(string(k + 1, k[0]), string(t + 1, t[0]));
</pre>

    The key and tag are C++ strings.
<p>
    If key and tag are empty, then the null item is replaced. If key.length()
    exceeds the the limit on key sizes an error condition occurs.  The result
    is false if the key is already in the B-tree, otherwise true.  Treated
    as an integer, the result also measures the increase in the total number of
    keys in the B-tree.
</blockquote>

<pre>
bool Btree::del(const string &amp;key);
</pre>

<blockquote>
    If key.empty() nothing happens, and the result is false.
<p>
    Otherwise this deletes the key and its tag from the B-tree, if found. e.g.

<pre>
        ok = B-&gt;del("TODAY")

        ok = B-&gt;del(string(k + 1, k[0]));
</pre>

    The result is then false if the key is not in the B-tree, true
    if it is.  Treated as an interger, the result also measures the decrease
    in the total number of keys in the B-tree.
</blockquote>

<pre>
Btree_item::Btree_item();
</pre>

<blockquote>
    Creates an object for holding B-tree items. After

<pre>
        t = new Btree_item();
</pre>

    We can make use of the following:

<pre>
        t-&gt;key        C++ string containing the key
        t-&gt;tag        C++ string containing the tag
</pre>
</blockquote>

<pre>
bool Btree::find_key(const string &amp;key);
</pre>

<blockquote>
    The result is true iff the specified key is found.
</blockquote>

<pre>
bool Btree::find_tag(const string &amp;key, Btree_item * t);
</pre>

<blockquote>
    The same result, but when the key is found the tag is copied to t-&gt;tag
    If the key is not found t-&gt;tag is left unchanged. e.g.

<pre>
        Btree_item t = Btree_item_create();
        B-&gt;find_tag("TODAY", t); /* get today's date */
</pre>
</blockquote>
<!--
<pre>
int Btree::close(unsigned long revision);
</pre>

<blockquote>
    There are two ways of closing the B-tree. Btree_close is the normal exit,
    with all changes being flushed back to disk. Btree_quit abandons the
    update, so the revision number of the B-tree will not increase.
<p>
    The revision number of Btree_close is typically one more than the revision
    number found after opening:

<pre>
        Btree * B = Btree_open_to_write("database-1/");
        unsigned long revision = B-&gt;revision_number;
        ...
        Btree_close(B, revision + 1);
</pre>

    An error condition occurs if the revision number given for closing does not
    exceed the revision number of the B-tree found after opening it.
</blockquote>
-->
<pre>
int4 B-&gt;item_count;
</pre>

<blockquote>
    This returns the number of items in the B-tree, not including the
    ever-present item with null key.
</blockquote>

<h2>Retrieval mode</h2>

In retrieval mode there is no opportunity for updating the B-tree, but access
is considerably elaborated by the use of cursors.


<pre>
<!--bool-->void Btree_open_to_read(const string &amp; name);
uint4 B-&gt;revision_number;
<!--bool-->void Btree_open_to_read(const string &amp; name, uint4 revision);
Btree_item::Btree_item();
</pre>

<blockquote>
    These are the same as for update mode, except that that the opened B-tree
    is not modifiable.
</blockquote>

<pre>
Bcursor::Bcursor(Btree *B);
</pre>

<blockquote>
    Creates a cursor, which can be used to remember a position inside the
    B-tree. The position is simply the item (key and tag) to which the cursor
    points. A cursor is either positioned or unpositioned, and is initially
    unpositioned.
    <p>
    NB: You must make sure that the Bcursor is destroyed before the Btree
    it is attached to.
</blockquote>

<pre>
bool Bcursor::find_key(const string &amp; key);
</pre>

<blockquote>
    The result is true iff the specified key is found in the Btree.
<p>
    If found, the cursor is made to point to the item with the given key, and
    if not found, it is made to point to the last item in the B-tree whose key
    is &lt;= the key being searched for, The cursor is then set as 'positioned'.
    Since the B-tree always contains a null key, which precedes everything, a
    call to Bcursor::find_key always results in a valid key being pointed to by
    the cursor.
</blockquote>

<pre>
bool Bcursor::next();
</pre>

<blockquote>
    If cursor BC is unpositioned, the result is simply false.
<p>
    If cursor BC is positioned, and points to the very last item in the Btree
    the
    cursor is made unpositioned, and the result is false. Otherwise the cursor
    BC is moved to the next item in the B-tree, and the result is true.
<p>
    Effectively, Bcursor::next() loses the position of BC when it drops off
    the end of the list of items. If this is awkward, one can always arrange
    for a key to be present which has a rightmost position in a set of keys,
    e.g.

<pre>
        B-&gt;add("\xFF", "");
        /* all other keys have first char &lt; xF0, and a fortiori &lt; xFF */
</pre>
</blockquote>

<pre> 
bool Bcursor::prev();
</pre>

<blockquote>
    This is like Bcursor::next, but BC is taken to the previous rather than
    next item.
</blockquote>

<pre> 
bool Bcursor::get_key(Btree_item *item);
</pre>

<blockquote>
    If cursor BC is unpositioned, the result is simply false.
<p>
    If BC is positioned, the key of the item is copied into item-&gt;key
    and the result is then true.
<p>
    For example,

<pre> 
        Bcursor * BC = Bcursor_create(B);
        Btree_item * kt = Btree_item_create();

        /* Now we'll print all the keys in the B-tree (assuming they
           have a simple form */

        BC-&gt;find_key("", 0); /* must give result true */

        while (BC-&gt;next()) {    /* bypassing the null item */
	    BC-&gt;get_key(kt);
	    for (int i = 0; i &lt; kt-&gt;key_len; i++)
		putc(kt-&gt;key[i]);
	    putc('\n');
        }
</pre>
</blockquote>

<pre> 
bool Bcursor::get_tag(Btree_item * kt);
</pre>

<blockquote>
    If cursor BC is unpositioned, the result is simply bool.
<p>
    If BC is positioned, the tag of the item at cursor BC is copied into
    kt-&gt;tag. BC is then moved to the next item
    as if Bcursor::next() had been called - this may leave BC unpositioned.
    The result is true iff BC is left positioned.
<p>
    For example,

<pre> 
        Bcursor * BC = B-&gt;Bcursor_create();
        Btree_item * kt = Btree_item_create();

        /* Now do something to each key-tag pair in the Btree */
           have a simple form */

        BC-&gt;find_key("", 0); /* must give result 1 */

        while (BC-&gt;get_key(kt)) {
            BC-&gt;get_tag(kt);
            do_something_to(kt-&gt;key, kt-&gt;tag);
        }

        /* when BC is unpositioned by Bcursor::get_tag, Bcursor::get_key
           gives result true the next time it called
        */
</pre>
<!--

    Tags (and keys) may be removed cheaply from a Btree_item structure kt by
    assigning kt-&gt;tag elsewhere, and the setting kt-&gt;tag to 0 and kt-&gt;tag_size
    to -1. [Perhaps there should be procedures to do this.] For example,

<pre> 
        Bcursor * BC = Bcursor_create(B);
        Btree_item * kt = Btree_item_create();

        unsigned char * calendar[2000];
        int year;

        for (year = 1; year &lt;= 2000; year++) {
            unsigned char s[20]; /* 20 is fine */
            sprintf(s, "YEAR%d CALENDAR", year);
            if (BC-&gt;find_key(s, strlen(s))) {
                BC-&gt;get_tag(kt);

                calendar[year] = kt-&gt;tag;  /* may be zero */
                kt-&gt;tag = 0;
                kt-&gt;tag_size = -1;
            }
            else calendar[year] = 0;
        }
        ....

        /* later on: */

        for (year = 1; year &lt;= 2000; year++) free(calendar[year]);
</pre>
-->
</blockquote>

<pre> 
Bcursor::~Bcursor();
</pre>

<blockquote>
    Loses cursor BC.
</blockquote>

<h2>Checking the B-tree</h2>

Provisionally, the following is provided:

<pre> 
void Btree::check(const char * name, const char * opt_string);
</pre> 

<blockquote>
    Btree::check(s, opts) is essentially equivalent to

<pre>
        Btree * B = new Btree();
	B-&gt;Btree_open_to_write(s);
        {
            /* do a complete integrity check of the B-tree,
               reporting according to the option string
            */
        }
        delete B;
</pre>

    The option string, if non-null, causes information to go to stdout. The
    following characters may appear in the option string:

<pre>
        t   - short summary of entire B-tree
        f   - full summary of entire B-tree
        b   - print the bitmap
        v   - print the basic information (revision number, blocksize etc.)
        +   - equivalent to tbv
        ?   - lists currently available options
</pre>

    The options cause a side-effect of printing, so Btree_check(s, "v") checks
    the entire B-tree and reports basic information, rather than merely
    reporting the basic information.
</blockquote>

<h2>Full compaction</h2>

As the B-tree grows, items are added into blocks, and, when a block is full, it
splits into two (amoeba-like) and one of the new blocks accommodated the new
entry. Blocks are therefore between 50% and 100% full during growth, or 75% full
on average.

<p>
Let us say an item is 'new' if it is presented for addition to the B-tree and
its key is not already in the B-tree. Then presenting a long run of new items
ordered by key causes the B-tree updating process to switch into a mode where
much higher compaction than 75% is achieved - about 90%. This is called
'sequential' mode. It is possible to force an even higher compaction rate with
the procedure


<pre> 
void Btree::full_compaction(bool parity);
</pre>

So

<pre> 
    B-&gt;full_compaction(true);
</pre>

switches full compaction on, and

<pre> 
    B-&gt;full_compaction(false);
</pre>

switches it off. Full compaction may be switched on or off at any time, but
it only affects the compaction rate of sequential mode. In sequential mode, full
compaction gives around 98-99% block usage - it is not quite 100% because keys
are not split across blocks.

<p>
The downside of full compaction is that block splitting will be heavy on the
next update. However, if a B-tree is created with no intention of being updated,
full compaction is very desirable.

<h2>Full compaction with revision 1</h2>

Retrieval mode is faster when the B-tree has revision number 1 than for higher
revision numbers. This is because there are no unused blocks in the B-tree and
the blocks are in a special order, and this enables the Bcursor::prev and
Bcursor::next procedures, and the other procedures which use them implicitly,
to have more efficient forms.

<p>
To make a really fast structure for retrieval therefore, create a new B-tree,
open it for updating, set full compaction mode, and add all the items in a
single transaction, sorted on keys. After closing, do not update further.
Further updates can be prevented quite easily by deleting (or moving) the bitmap
files. These are required in update mode but ignored in retrieval mode.

<p>
Here is a program fragment to unload B-tree B/ and reform it in Bnew/ as a fully
compact B-tree with revision number 1.

<pre> 
    {
	Btree B;
	B.open_to_read("B/");
        AutoPtr&lt;Bcursor&gt; BC = B.Bcursor_create();
        Btree_item item;

	Btree::create("Bnew/", 8192);

	Btree new_B;
	new_B.open_to_write("Bnew/");
	new_B.set_full_compaction(true);

	BC-&gt;find_key("", 0);

	while (true) {
	    if (!BC-&gt;get_key(&amp;item)) break;
	    BC-&gt;get_tag(&amp;item);
	    new_B.add(item.key, item.tag);
	}
	new_B.commit(1);
    }
</pre>

<h2>Notes on space requirements</h2>

The level of the B-tree is the distance of the root block from a leaf block. At
minimum this is zero. If a B-tree has level L and block size B, then update
mode requires space for 2(LB + b<sub>1</sub> + b<sub>2</sub>) bytes,
where b<sub>1</sub> and b<sub>2</sub> are the size of
the two bitmap files. Of course, L, b<sub>1</sub> and b<sub>2</sub>
may grow during an update on the
B-tree. If the revision number is greater than one, then retrieval mode
requires (L - 2 + 2c)B bytes, where c is the number of active cursors. If
however the revision number is one, it only requires (L - 2 + c)B bytes.

<p>
This may change in the future with code redesign, but meanwhile not that a K
term query that needs k &lt;= K cursors open at once to process, will demand 2kB
bytes of memory in the B-tree manager.

<h2>Updating during retrieval</h2>

The B-tree cannot be updated by two separate processes at the same time. The
user of the B-tree software should establish a locking mechanism to ensure that
this never happens.

<p>
It is possible to do retrieval while the B-tree is being updated. If the
updating process overwrites a part of the B-tree required by the retrieval
process, the flag

<pre> 
    bool B-&gt;overwitten;
</pre>

is set to true. This may be detected, and suitable action taken. Here is a model
scheme:

<pre> 
static Btree * reopen(Btree * B)
{
    uint4 revision = B-&gt;revision_number;

    // Get the revision number. This will return the correct value, even when
    // B-&gt;overwritten is detected during opening

    delete B;  /* close the B-tree */
    B = new Btree;
    B-&gt;open_to_read(s); /* and reopen */

    if (revision == B-&gt;revision_number) {
        // The revision number ought to have gone up from last time,
        // so if we arrive here, something has gone badly wrong ...
        printf("Possible database corruption - complain to Xapian\n");
        exit(1);
    }
    return B;
}


    ....

    char * s = "database/";
    Btree * B = new Btree;
    uint4 revision = 0;

    B-&gt;open_to_read(s);            /* open the B-tree */

    Btree_item t;
    do {
	while (B-&gt;overwritten) {
	    B = reopen(s);
	}
	...

	B-&gt;find_tag("brunel", &amp;t); /* look up some keyword */
    } while (B-&gt;overwitten);
    ...
</pre>

It may happen that B-&gt;overwitten is set to true in updating mode. This would
mean that there were two updating processes at work. If the code is correct
this does not need to be tested for, and in any case simultaneous updating is
an error that cannot generally be trapped in this way.

<p>
In retrieval mode B-&gt;overwitten should be tested after the following procedures,

<pre>
    Btree::open_to_read(name);
    Btree::open_to_read(name, revision);
    Bcursor::next();
    Bcursor::prev();
    Bcursor::find_key(key);
    Bcursor::get_tag(kt);
</pre>

The test is not required after any of the following:

<pre>
   Btree_item::Btree_item();
   Btree::Bcursor_create();
   Bcursor::get_key(kt);
</pre>

Note particularly that opening the B-tree can set B-&gt;overwritten, and that
Bcursor::get_key(..) will not set B-&gt;overwritten.

<h2>Error conditions</h2>

Note: this section is out of date - many methods now return errors in different
ways to those this section indicates.

<P>
The procedures described above report errors in three ways. (A) A null result.
If this:

<pre>
   AutoPtr&lt;Bcursor&gt; Btree::Bcursor_create();
</pre>

returns NULL, there was not enough space left to create the Bcursor. (B) A non-zero
result. Btree::close() returns an int result which is 0 if successful,
otherwise an error number. (C) The error is placed in B-&gt;error, where B is the
Btree structure used in the call, or the Btree structure from which the Bcursor
structure used in the call derives. Then B-&gt;error == 0 means no error,
otherwise it is a positive number (greater than 2) giving the error number.

<p>
Some procedures cannot give an error.  Here is a summary:

<pre>
    Error method  procedure
    (A)(B)(C)          error condition given by:
    ------------------------------------------------------
           *  n = Btree::find_key(key)
           *  n = Btree::find_tag(key, kt)
           *  n = Btree::add(key, tag)
           *  n = Btree::del(key)
           *  B = Btree::open_to_write(s)
           *  B = Btree::open_to_write(s, rev)
        *     n = Btree::close(B, rev)
        *     n = Btree::create(s, block_size)
           *  B = Btree::open_to_read(s)
           *  B = Btree::open_to_read(s, rev)
     *     *  BC= Bcursor::create(B)
           *  n = Bcursor::find_key(key)
           *  n = Bcursor::next()
           *  n = Bcursor::prev()
           *  n = Bcursor::get_key(kt)
           *  n = Bcursor::get_tag(kt)
                  Btree_full_compaction(B, parity)

    (A) null result (B) non-zero result (C) B-&gt;error == true
</pre>

Here are some suitable error tests with the different calls,

<pre>
    kt = Btree_item_create(s);
    if (kt == 0) ...

    B = Btree_open_to_write(s);
    if (B == 0 || B-&gt;error) ...

    n = Btree_create("...");
    if (n) ...

    n = B-&gt;delete(key);
    if (B-&gt;error) ...
</pre>

B-&gt;error is not cleared after being set true. B-&gt;error can, as a side effect,
set B-&gt;overwritten to true, but this should not matter since the test for
B-&gt;error should always be done first. The procedures that give no error can
still have the test for error (C) applied. Error (A) will be rare, and most
of the others should be rare, except for creating and opening the Btree, which
will of course fail when the necessary files cannot be created or found.

<p>
Errors (B) and (C) have a consistent set of values, defined in btree.h. They
are,

<pre>
BTREE_ERROR_BLOCKSIZE     block size too large or too small during creation
BTREE_ERROR_SPACE         malloc, calloc failure

BTREE_ERROR_BASE_CREATE   For the base files, failure to create
BTREE_ERROR_BASE_DELETE   - failure to delete
BTREE_ERROR_BASE_READ     - failure to read
BTREE_ERROR_BASE_WRITE    - failure to write

BTREE_ERROR_BITMAP_CREATE For the bit map files, failure to create
BTREE_ERROR_BITMAP_READ   - failure to read
BTREE_ERROR_BITMAP_WRITE  - failure to write

BTREE_ERROR_DB_CREATE     For the DB file, failure to create
BTREE_ERROR_DB_OPEN       - failure to open
BTREE_ERROR_DB_CLOSE      - failure to close
BTREE_ERROR_DB_READ       - failure to read
BTREE_ERROR_DB_WRITE      - failure to write

BTREE_ERROR_KEYSIZE       - key_len too large (programmer error)
BTREE_ERROR_TAGSIZE       - tag_len too large

BTREE_ERROR_REVISION      - rev too small in Btree_close (programmer error)
</pre>

See 'keys and tags' above for the upper limit on tag sizes.
<!-- FOOTER $Author$ $Date$ $Id$ -->
</BODY>
</HTML>
