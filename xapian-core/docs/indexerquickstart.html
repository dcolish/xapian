<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Muscat Indexing: Quickstart</TITLE>
</HEAD>
<BODY BGCOLOR="white">

<H1>Quickstart</H1>

<P>
This document is a short introduction to the graph-based indexing facilities
of Open Muscat.  For an introduction to the basic facilities of OM, see
<a href="quickstart.html">quickstart.html</a>.  This document assumes that
you've read that first.
</P>

<HR>
<H2>Requirements</H2>

<P>
Before following the steps outlined in this document, you will need to have
the Muscat library installed on your system.  See <a href="quickstart.html"
>quickstart.html</a> for details.
</P>
<P>
To build indexers using an XML description, you will need to have libxml
(and the development libraries if you are building the library).  libxml
is available from
<a href="ftp://ftp.gnome.org/pub/GNOME/MIRRORS.html">ftp.gnome.org</a> or
from your operating system distribution.
</P>

<HR>
<H2>Indexing scripts</H2>

<P>
A document in a database has the following information in OM:

<ul>
	<li>A list of terms, with positional information and frequencies.</li>
	<li>Some application-specific data describing the document</li>
	<li>A set of attributes used at match time</li>
</ul>

The role of an indexer is to convert a source document (which can be
an HTML page, a PDF document, or anything else) into a form suitable
for storing in the database.
</P>

<H3>The old way</H3>

<P>
In traditional Muscat, the indexing is done by a script written in a
special text processing language.
<!--FIXME: say more here-->
</P>

<H3>The new way</H3>

<P>
Open Muscat provides a new way to build an indexer based on a group of
co-operating nodes joined together into a network.  Each node is a unit
with some inputs and some outputs.  Each input is connected to the
output of node higher up in the network.  Once the network is constructed
it can be considered to be a single unit which takes raw documents from
the top and returns the extracted data at the bottom.
</P><P>
The nodes themselves each typically perform one relatively simple task.
Such tasks can be splitting on whitespace, stemming terms, joining lists,
etc.  A number of nodes are provided with the library to do useful general
tasks.  If necessary, an indexer writer can add new node types to the
system.
</P>

<HR>
<H2><A NAME="indexer">An example indexer</A></H2>

<P>
The code for this example is in the examples package, in
the &quot;<CODE>indexer</CODE>&quot; subdirectory.
</P>
<P>
The &quot;indexer&quot; presented here is a small program which
takes a path to a database and a filename on the command line, and
indexes that file into the database.  The terms generated are:

<ul>
    <li>Capitalised words lowercased and added without stemming</li>
    <li>All words (including capitalised ones), stemmed</li>
    <li>The filename (without directory), prefixed by "F"</li>
</ul>

The keys generated are:

<ol>
    <li>The filename, without directory</li>
    <li>The directory</li>
</ol>

The data contains just the original filename.
</P><P>
The indexing code in this example is almost all described in an XML file
called indexerfile.xml.  The program code in indexerfile.cc does little
more than setting up the indexer based on this XML file and passing it
the filename of the file to index.  We'll describe indexerfile.cc first.
</P>

<H3>The indexing program itself</H3>
<P>
Most of the content of indexfile.cc is similar to the examples from the
Open Muscat <a href="quickstart.html">quickstart document</a>.  We'll
only discuss the new parts here.
</P>
<H3>Options parsing</H3>
<P>
For this example we do very simple options parsing.  We index a single
file to a database, and don't need anything else.
</P><P>
Thus, our command line syntax is:
<UL><LI>
<B>Parameter 1</B> - the (possibly relative) path to the database.
</LI><LI>
<B>Parameter 2</B> - the name of the file to be indexed.
</LI></UL>
</P><P>
The validity of a command line can therefore be checked very simply by
ensuring that there are exactly least 3 parameters (including the program
name):
<PRE>
    if(argc != 3) {
        cout &lt;&lt; "usage: " &lt;&lt; argv[0] &lt;&lt;
	        " &lt;path to database&gt; &lt;file to index&gt;" &lt;&lt; endl;
        exit(1);
    }
</PRE>
</P>

<H3>Preparing the indexer</H3>

<P>
Setting up the indexer from the description file is very simple.  The
work is done by an object of the class <CODE>OmIndexerBuilder</CODE>.  
This object has a built-in library of nodes which can be put into an
indexer, and provides a way to register user-defined nodes.  The main
use, though, is to turn a textual description of the indexer into an
<CODE>OmIndexer</CODE> object which can be used directly.
</P><P>
The method of <CODE>OmIndexerBuilder</CODE> which we're interested in
is <CODE>build_from_file(std::string filename)</CODE>.  The only
parameter is the name of the file containing the indexer description.
The method returns an <CODE>AutoPtr</CODE> to an <CODE>OmIndexer</CODE>
object based on this description.  There are similar methods to use
when the XML description is in memory, or when the description is
already in a parsed structure in memory.
</P><P>
<CODE>AutoPtr</CODE> is a smart pointer which takes care of destroying
the object it points to when it goes out of scope, and is very close
to an implementation of <CODE>auto_ptr</CODE> from the C++ standard
template library.  Most of the time it can be used just like an
ordinary pointer, without needing to delete the target when it's no
longer in use.
</P><P>
Here is the code for creating our indexer:
</P>

<PRE>
	OmIndexerBuilder builder;
	AutoPtr&lt;OmIndexer&gt; indexer = builder.build_from_file(&quot;indexfile.xml&quot;);
</PRE>

<H3>Indexing the file</H3>

<P>
Now that we've built the indexer, we can index the file.  The example
indexer is set up to take a filename as input.  All we need to is to
supply the filename, and read the output.  The input is specified in
an OmIndexerMessage, which is the message used internally in the
indexer.  Here's the code fragment which does that:
</P>

<PRE>
	OmIndexerMessage filename(new OmIndexerData(argv[2]));
	indexer-&gt;set_input(filename);
	OmDocumentContents newdocument = indexer-&gt;get_output();
</PRE>

<H3>Displaying the document data</H3>

<P>
So that we can see what the indexer actually produced, we print out
the data stored in the <CODE>OmDocumentContents</CODE> object.
First we print out the data field:
</P>
<PRE>
	cout &lt;&lt; &quot;Document data: &quot; &lt;&lt; newdocument.data.value &lt;&lt; endl;
</PRE>
<P>
Next, we print out the keys.  The keys are stored in an STL <CODE>map</CODE>,
so we enumerate the values using an iterator:
</P>
<PRE>
	cout &lt;&lt; &quot;Document keys: &quot; &lt;&lt; endl;
	for (OmDocumentContents::document_keys::const_iterator i =
	     newdocument.keys.begin();
	     i != newdocument.keys.end();
	     ++i) {
	    cout &lt;&lt; &quot;\t&quot; &lt;&lt; i-&gt;first &lt;&lt; &quot;\t&quot; &lt;&lt; i-&gt;second &lt;&lt; endl;
	}
</PRE>

<P>
Finally, we print out the document terms.  This is very similar to printing
out the keys.
</P>

<PRE>
	cout &lt;&lt; &quot;Document terms: &quot; &lt;&lt; endl;
	for (OmDocumentContents::document_terms::const_iterator i =
	     newdocument.terms.begin();
	     i != newdocument.terms.end();
	     ++i) {
	    cout &lt;&lt; &quot;\t&quot; &lt;&lt; i-&gt;first &lt;&lt; &quot;\t&quot; &lt;&lt; i-&gt;second &lt;&lt; endl;
	}
</PRE>

<HR>
<H2>The indexing script</H2>

We've now seen the program which controls the indexing.  It's now time
to look at the indexing script itself, in indexfile.xml.

<H3>The file format</H3>

<P>
The file format is described by the XML DTD omindexer.dtd, which should
be installed with the Open Muscat library.  At the time of writing there
are no graphical or other tools to generate indexer descriptions - it
must be written by hand.  In future this should no longer be the case.
</P><P>
We'll go through the part of the indexer responsible for generating the
terms, without describing the parts which generate the keys and data
field.
</P>

<H3>The basic XML skeleton</H3>

An indexer XML description will always start with a tag identifying the
version of XML being used, and the rest will be enclosed in a top-level
<CODE>&lt;omindexer&gt;</CODE> tag:

<PRE>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;omindexer&gt;
  ...
&lt;/omindexer&gt;
</PRE>

<H3>The splitter node</H3>

<P>
One of the basic nodes available is the <CODE>omsplitter</CODE> node.
It has one input (in) and two outputs (left, right), and simply
duplicates the input and provides a copy on each output.  This is an
important node, since it lets the indexer do two different things
with the same piece of data.
</P><P>
The top node in this indexer is an <CODE>omsplitter</CODE> which
connects to the special "START" node.  The "START" node has one output,
which contains the data passed in from <CODE>OmIndexer::set_input()</CODE>.
</P>

<PRE>
    &lt;!-- First make split the filename down two paths --&gt;
    &lt;node type=&quot;omsplitter&quot; id=&quot;splitfname&quot;&gt;
        &lt;input name=&quot;in&quot; node=&quot;START&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<P>
This specifies a node of type <CODE>omsplitter</CODE>, with id "splitfname".
The id can be anything, but must be unique in the indexer.  It should be a
descriptive name.  This node has one input connection, named "in", which is
connected to the "out" connection of the node with id "START".
</P>

<H3>Reading the file into memory</H3>

<P>
Before the terms can be extracted from the file, it must be loaded into
memory.  This is done by an <CODE>omfilereader</CODE> node.  The node
has one input, "filename", which should be the path to the file to open.
The file is read into memory, and written to the "out" connection.
</P>

<PRE>
    &lt;!-- In the left path, read the file into memory --&gt;
    &lt;node type=&quot;omfilereader&quot; id=&quot;readfile&quot;&gt;
        &lt;input name=&quot;filename&quot; node=&quot;splitfname&quot; out_name=&quot;left&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Splitting the file into words</H3>

<P>
The next thing to do is to split the contents of the file into words.
This is done by an <CODE>omregexsplit</CODE> node.  It takes a string
at input "in", and splits it into a list of smaller strings.  The
boundary is described by a POSIX regular expression, specified as a
configuration parameter named "regex".
</P><P>
The regular expression used here is "[^a-zA-Z]\+", which matches any
non-zero string of non-letters.  The result of the split will
therefore be a list of all the sequences of letters from the input
string.
</P>

<PRE>
    &lt;!-- Split the file into &quot;words&quot; --&gt;
    &lt;node type=&quot;omregexsplit&quot; id=&quot;wordsplit&quot;&gt;
        &lt;param name=&quot;regex&quot; type=&quot;string&quot; value=&quot;[^a-zA-Z]\+&quot;/&gt;
        &lt;input name=&quot;in&quot; node=&quot;readfile&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Duplicating the word list</H3>

<P>
We make use of an <CODE>omsplitter</CODE> node again to copy the list
of words, so that we can do different operations on each copy.
</P>

<PRE>
    &lt;!-- Duplicate the list of words --&gt;
    &lt;node type=&quot;omsplitter&quot; id=&quot;dupwords&quot;&gt;
        &lt;input name=&quot;in&quot; node=&quot;wordsplit&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Processing capitalised words</H3>

<P>
The first step is to remove the lower-case words from the list.  This is
done using an <CODE>omregexfilter</CODE> node.  The input to this node
is a list of strings.  The output is the subset of the strings in the
input list which match a particular regular expression.  In this case
we set the regular expression to "^[A-Z]", which matches a capital letter
at the start of the string.
</P>
<PRE>
    &lt;!-- Left branch, separate capital words --&gt;
    &lt;node type=&quot;omregexfilter&quot; id=&quot;capsonly&quot;&gt;
        &lt;param name=&quot;regex&quot; type=&quot;string&quot; value=&quot;^[A-Z]&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;dupwords&quot; out_name=&quot;left&quot;/&gt;&lt;/node&gt;
</PRE>

<P>
Once we've separated the capitalized words out, we want to lower case them.
In our indexing scheme all normal words are stored in the database lower
cased, and some special terms may be stored with an initial capital letter.
We do the lower-casing using an <CODE>omtranslatelist</CODE> node.  It takes
as input a list of strings (the similar <CODE>omtranslate</CODE> node takes
a single string instead).  There are two configuration parameters to set.
"from" and "to" should be strings of equal length.  The nth character of
"from" will be replaced by the nth character of "to" in the output of the
node.  In this example we translate each upper-case letter to its lower-case
equivalent.
</P>

<PRE>
    &lt;node type=&quot;omtranslatelist&quot; id=&quot;lowercaps&quot;&gt;
        &lt;param name=&quot;from&quot; type=&quot;string&quot; value=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;/&gt;
        &lt;param name=&quot;to&quot; type=&quot;string&quot; value=&quot;abcdefghijklmnopqrstuvwxyz&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;capsonly&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Processing the second copy of the word list</H3>

<P>
We'll take the other copy of the word list and apply the English stemmer.
For this we use the <CODE>omstemmer</CODE> node.  This node takes a list
of words in the input "in" and returns the list of stemmed words in output
"out".  The configuration parameter "language" sets the stemmer language.
</P><P>
Before stemming, we need to lower-case the words, which we do with an
<CODE>omtranslate</CODE> node as before.
</P>

<PRE>
    &lt;!-- Right branch, lower case everything... --&gt;
    &lt;node type=&quot;omtranslatelist&quot; id=&quot;tolower&quot;&gt;
        &lt;param name=&quot;from&quot; type=&quot;string&quot; value=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;/&gt;
        &lt;param name=&quot;to&quot; type=&quot;string&quot; value=&quot;abcdefghijklmnopqrstuvwxyz&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;dupwords&quot; out_name=&quot;right&quot;/&gt;&lt;/node&gt;
    &lt;!-- ... and stem --&gt;
    &lt;node type=&quot;omstemmer&quot; id=&quot;stem&quot;&gt;
        &lt;param name=&quot;language&quot; type=&quot;string&quot; value=&quot;english&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;tolower&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Merging the word lists</H3>

<P>
Now that we have two lists of words, we want to join them back together
again.  This is done with an <CODE>omlistconcat</CODE> node.  It has
two inputs, "left" and "right", and simply appends the contents of
the list at "right" to the list at "left".

<PRE>
    &lt;!-- Now merge the two lists of terms --&gt;
    &lt;node type=&quot;omlistconcat&quot; id=&quot;terms&quot;&gt;
        &lt;input name=&quot;left&quot; node=&quot;lowercaps&quot; out_name=&quot;out&quot;/&gt;
	&lt;input name=&quot;right&quot; node=&quot;stem&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Making a termlist from the words</H3>

<P>
Before it can be used with an <CODE>OmDocumentContents</CODE> object, the
termlist must be in the right form.  Two nodes help with this:
<CODE>omnewtermlist</CODE> and <CODE>omtermlistadd</CODE>.  The
<CODE>omnewtermlist</CODE> node creates a new termlist structure from
scratch, and <CODE>omtermlistadd</CODE> lets us add strings into the
newly created termlist.
</P><P>
<CODE>omnewtermlist</CODE> has no inputs, and produced an empty termlist
on output.  <CODE>omtermlistadd</CODE> has two inputs.  "termlist" is the
termlist created by <CODE>omnewtermlist</CODE> and "words" is the list of
words to add.  The output "out" is the new termlist with extra words.

<PRE>
    &lt;!-- convert the terms into a termlist --&gt;
    &lt;node type=&quot;omnewtermlist&quot; id=&quot;maketermlist&quot;&gt;&lt;/node&gt;
    &lt;node type=&quot;omtermlistadd&quot; id=&quot;addtermlist&quot;&gt;
        &lt;input name=&quot;termlist&quot; node=&quot;maketermlist&quot; out_name=&quot;out&quot;/&gt;
	&lt;input name=&quot;words&quot; node=&quot;terms&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Combining the results into the document</H3>

<P>
The last thing the indexer must do is combine all the parts of the
document (terms, keys, and data) into one structure.  This work is
done by <CODE>ommakedoc</CODE>.  It has three inputs, one for each
component of the document.  The output will usually be connected
to the indexer's output (see next section).
</P>

<PRE>
    &lt;!-- join everything into the final document --&gt;
    &lt;node type=&quot;ommakedoc&quot; id=&quot;doc&quot;&gt;
        &lt;input name=&quot;terms&quot; node=&quot;addfilename&quot; out_name=&quot;out&quot;/&gt;
	&lt;input name=&quot;data&quot; node=&quot;splitfname3&quot; out_name=&quot;right&quot;/&gt;
	&lt;input name=&quot;keys&quot; node=&quot;addkeys&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Specifying the network's output</H3>

<P>
The indexing system needs to know where to get the result of the indexing
from.  The XML file has an &lt;output&gt; tag to specify this.  In our
case it's the <CODE>ommakedoc</CODE> node from the previous section:
</P>

<PRE>
    &lt;!-- specify the output --&gt;
    &lt;output node=&quot;doc&quot; out_name=&quot;out&quot;/&gt;
</PRE>

<!-- FIXME: below is still from the original quickstart.html -->

<HR>
<H2>Compiling</H2>

Now that we have the code written, all we need to do is compile it.  The
compilation is virtually identical to that for the simple examples
described in <a href="quickstart.html">quickstart.html</a>.

<HR>
<H2>Running the examples</H2>

<P>
Once we have compiled the example indexer, we can build up a simple database as
follows.  Note that we must first create a directory for the database files to
live in; although Muscat will create new empty database files if they do not
yet exist, it will not create a new directory for them.
<PRE>
$ mkdir mydb
$ ./indexfile mydb textfile.txt
</PRE>
</P>

<P>
We can at last perform searches over the database using the simplesearch
program described in <a href="quickstart.html">quickstart.html</a>.
</P>

<HR>
<H2>Further documentation</H2>

For more detailed documentation on the API, there are two pieces of
documentation available.
<UL><LI>
The <A HREF="userman.html">user manual</A>, which is designed as an
introduction to the API.
</LI>
<LI>
An <A HREF="apidoc/html/index.html">API reference</A>, which is automatically extracted from the extensive
comments in the source code by
<EM><A HREF="http://www.stack.nl/~dimitri/doxygen/index.html">Doxygen</A></EM>.
This is distributed together with the source code packages, but in the
event that you do not have a this there is a
<A HREF="http://open.muscat.com/developer/docs/apidoc/html/index.html">copy</A>
available on our website.
</LI></UL>

For those interested in how Muscat works internally, there is also
automatically extracted documentation of the full source code, available
on our
<A HREF="http://open.muscat.com/developer/docs/sourcedoc/html/index.html">website</A>.  You may also build this documentation yourself, if you have Doxygen
installed, by running
<PRE>
    make doxygen_docs
</PRE>
from within the <CODE>docs</CODE> subdirectory of the <CODE>om</CODE> source
tree.

<!-- FOOTER $Author$ $Date$ $Id$ -->
</BODY>
</HTML>
