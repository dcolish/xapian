<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Muscat Indexing: Quickstart</TITLE>
</HEAD>
<BODY BGCOLOR="white">

<H1>Quickstart</H1>

<P>
This document is a short introduction to the graph-based indexing facilities
of Open Muscat.  For an introduction to the basic facilities of OM, see
<a href="quickstart.html">quickstart.html</a>.
</P>

<HR>
<H2>Requirements</H2>

<P>
Before following the steps outlined in this document, you will need to have
the Muscat library installed on your system.
For instructions on obtaining and installing Muscat, read the
<A HREF="intro.html">Introduction</A> document.
</P>
<P>
You will also need a reasonably recent C++ compiler.  We currently use GCC
version 2.95.2, but any reasonably ANSI compilant C++ compiler should have
a decent chance of successfully compiling the code.
</P>
<P>
To build indexers using an XML description, you will need to have libxml
(and the development libraries if you are building the library).  libxml
is available from
<a href="ftp://ftp.gnome.org/pub/GNOME/MIRRORS.html">ftp.gnome.org</a> or
from your operating system distribution.
</P>

<HR>
<H2>Indexing scripts</H2>

<P>
A document in a database has the following information in OM:

<ul>
	<li>A list of terms, with positional information and frequencies.</li>
	<li>Some application-specific data describing the document</li>
	<li>A set of attributes used at match time</li>
</ul>

The role of an indexer is to convert a source document (which can be
an HTML page, a PDF document, or anything else) into a form suitable
for storing in the database.
</P>

<H3>The old way</H3>

<P>
In traditional Muscat, the indexing is done by a script written in a
special text processing language.
<!--FIXME: say more here-->
</P>

<H3>The new way</H3>

<P>
Open Muscat provides a new way to build an indexer based on a group of
co-operating nodes joined together into a network.  Each node is a unit
with some inputs and some outputs.  Each input is connected to the
output of node higher up in the network.  Once the network is constructed
it can be considered to be a single unit which takes raw documents from
the top and returns the extracted data at the bottom.
</P><P>
The nodes themselves each typically perform one relatively simple task.
Such tasks can be splitting on whitespace, stemming terms, joining lists,
etc.  A number of nodes are provided with the library to do useful general
tasks.  If necessary, an indexer writer can add new node types to the
system.
</P>

<HR>
<H2><A NAME="indexer">An example indexer</A></H2>

<P>
The code for this example is in the examples package, in
the &quot;<CODE>indexer</CODE>&quot; subdirectory.
</P>
<P>
The &quot;indexer&quot; presented here is a small program which
takes a path to a database and a filename on the command line, and
indexes that file into the database.  The terms generated are:

<ul>
    <li>Capitalised words lowercased and added without stemming</li>
    <li>All words (including capitalised ones), stemmed</li>
    <li>The filename (without directory), prefixed by "F"</li>
</ul>

The keys generated are:

<ol>
    <li>The filename, without directory</li>
    <li>The directory</li>
</ol>

The data contains just the original filename.
</P><P>
The indexing code in this example is almost all described in an XML file
called indexerfile.xml.  The program code in indexerfile.cc does little
more than setting up the indexer based on this XML file and passing it
the filename of the file to index.  We'll describe indexerfile.cc first.
</P>

<H3>Include header files</H3>
<P>
The first requirement in any program using the Muscat library is to
include the Muscat header file, &quot;<CODE>om.h</CODE>&quot;.
This should be installed in a subdirectory &quot;<CODE>om</CODE>&quot; of
a directory on the include path, so:
<PRE>    #include &lt;om/om.h&gt;</PRE>
</P>
<P>
Our example only has a single function, main(), so next we start that:
<PRE>    int main(int argc, char *argv[])</PRE>
</P>
<H3>Options parsing</H3>
<P>
For this example we do very simple options parsing.  We index a single
file to a database, and don't need anything else.
</P><P>
Thus, our command line syntax is:
<UL><LI>
<B>Parameter 1</B> - the (possibly relative) path to the database.
</LI><LI>
<B>Parameter 2</B> - the name of the file to be indexed.
</LI></UL>
</P><P>
The validity of a command line can therefore be checked very simply by
ensuring that there are exactly least 3 parameters (including the program
name):
<PRE>
    if(argc != 3) {
        cout &lt;&lt; "usage: " &lt;&lt; argv[0] &lt;&lt;
	        " &lt;path to database&gt; &lt;file to index&gt;" &lt;&lt; endl;
        exit(1);
    }
</PRE>
</P>

<H3>Catching exceptions</H3>
<P>
When an error occurs in Muscat it is reported by means of the C++ exception
mechanism.  All errors in Muscat are derived classes of
<CODE>OmError</CODE>, so simple error handling can be performed by
enclosing all the code in a try-catch block to catch any
<CODE>OmError</CODE> exceptions.  A (hopefully) helpful message can be
extracted from the <CODE>OmError</CODE> object by calling its
<CODE>get_msg()</CODE> method, which returns a human readable string.
</P>
<P>
Note that all calls to the Muscat library should be performed inside a
try-catch block, since otherwise errors will result in uncaught exceptions;
this usually results in the execution aborting.
</P>
<P>
Note also that OmError is a virtual base class, and thus can't be copied:
you must therefore catch exceptions by reference, as in the following example
code:
</P>
<PRE>
    try {
        <B>[code which accesses Muscat]</B>
    }
    catch(OmError &amp; error) {
        cout &lt;&lt; "Exception: " &lt;&lt; error.get_msg() &lt;&lt; endl;
    }
</PRE>

<H3>Opening the database</H3>

<P>
In Muscat, a database is opened for writing by creating an OmWritableDatabase
object.  The constructor for this object takes two arguments.
<OL><LI>
<B>type</B> - this is a string determining the type of the database to open.
The possible values for this depend on which backends are compiled into the
system: if the type is not known an <CODE>OmInvalidArgument</CODE> error will
be thrown.  For this example, we use the &quot;<CODE>sleepycat</CODE>&quot;
database type.
</LI><LI>
<B>parameters</B> - this is a set of parameters to be used to open the
database, stored in an STL vector. The meaning of the parameters is
dependent on the database type: for a sleepycat database there is expected
to be one and only one argument, which is the path (possibly relative to
the current directory) of a directory in which the database files reside.
</LI></OL>
</P>
<P>
If an attempt is made to open a database which doesn't exist, an attempt
to create an empty database in the specified position will be made.
</P>
<P>
If an error occurs when trying to open a database, or to create a new database,
an exception, usually of type <CODE>OmOpeningError</CODE>, will be thrown.
</P>
<P>
The code to open a database for writing is, then:
</P>

<PRE>
    OmSettings db_parameters;
    db_parameters.set("backend", "sleepycat");
    db_parameters.set("sleepycat_dir", argv[1]);
    OmWritableDatabase database(db_parameters);
</PRE>

<H3>Preparing the indexer</H3>

<P>
Setting up the indexer from the description file is very simple.  The
work is done by an object of the class <CODE>OmIndexerBuilder</CODE>.  
This object has a built-in library of nodes which can be put into an
indexer, and provides a way to register user-defined nodes.  The main
use, though, is to turn a textual description of the indexer into an
<CODE>OmIndexer</CODE> object which can be used directly.
</P><P>
The method of <CODE>OmIndexerBuilder</CODE> which we're interested in
is <CODE>build_from_file(std::string filename)</CODE>.  The only
parameter is the name of the file containing the indexer description.
The method returns an <CODE>AutoPtr</CODE> to an <CODE>OmIndexer</CODE>
object based on this description.  There are similar methods to use
when the XML description is in memory, or when the description is
already in a parsed structure in memory.
</P><P>
<CODE>AutoPtr</CODE> is a smart pointer which takes care of destroying
the object it points to when it goes out of scope, and is very close
to an implementation of <CODE>auto_ptr</CODE> from the C++ standard
template library.  Most of the time it can be used just like an
ordinary pointer, without needing to delete the target when it's no
longer in use.
</P><P>
Here is the code for creating our indexer:
</P>

<PRE>
	OmIndexerBuilder builder;
	AutoPtr&lt;OmIndexer&gt; indexer = builder.build_from_file(&quot;indexfile.xml&quot;);
</PRE>

<H3>Indexing the file</H3>

<P>
Now that we've built the indexer, we can index the file.  The example
indexer is set up to take a filename as input.  All we need to is to
supply the filename, and read the output.  The input is specified in
an OmIndexerMessage, which is the message used internally in the
indexer.  Here's the code fragment which does that:
</P>

<PRE>
	OmIndexerMessage filename(new OmIndexerData(argv[2]));
	indexer-&gt;set_input(filename);
	OmDocumentContents newdocument = indexer-&gt;get_output();
</PRE>

<H3>Displaying the document data</H3>

<P>
So that we can see what the indexer actually produced, we print out
the data stored in the <CODE>OmDocumentContents</CODE> object.
First we print out the data field:
</P>
<PRE>
	cout &lt;&lt; &quot;Document data: &quot; &lt;&lt; newdocument.data.value &lt;&lt; endl;
</PRE>
<P>
Next, we print out the keys.  The keys are stored in an STL <CODE>map</CODE>,
so we enumerate the values using an iterator:
</P>
<PRE>
	cout &lt;&lt; &quot;Document keys: &quot; &lt;&lt; endl;
	for (OmDocumentContents::document_keys::const_iterator i =
	     newdocument.keys.begin();
	     i != newdocument.keys.end();
	     ++i) {
	    cout &lt;&lt; &quot;\t&quot; &lt;&lt; i-&gt;first &lt;&lt; &quot;\t&quot; &lt;&lt; i-&gt;second &lt;&lt; endl;
	}
</PRE>

<P>
Finally, we print out the document terms.  This is very similar to printing
out the keys.
</P>

<PRE>
	cout &lt;&lt; &quot;Document terms: &quot; &lt;&lt; endl;
	for (OmDocumentContents::document_terms::const_iterator i =
	     newdocument.terms.begin();
	     i != newdocument.terms.end();
	     ++i) {
	    cout &lt;&lt; &quot;\t&quot; &lt;&lt; i-&gt;first &lt;&lt; &quot;\t&quot; &lt;&lt; i-&gt;second &lt;&lt; endl;
	}
</PRE>

<H3>Adding the document to the database</H3>

<P>
Finally, we can add the document to the database.  This simply involves
calling <CODE>OmWritableDatabase::add_document()</CODE>, and passing it
the <CODE>OmDocumentContents</CODE> object:
</P>
<PRE>
    database.add_document(newdocument);
</PRE>

<P>
The operation of adding a document is atomic: either the document will be
added, or an exception will be thrown and the document will not be in the
new database.
</P>
<P>
<CODE>add_document()</CODE> returns a value of type <CODE>om_docid</CODE>.
This is the document ID of the newly added document, which is simply a
handle which can be used to access the document in future.
</P>
<P>
Note that this use of <CODE>add_document()</CODE> is actually fairly
inefficient: if we had a large database, it would be desirable to group
as many document additions together as possible, by encapsulating
them within a session.  For details of this, and of the transaction
facility for performing sets of database modifications atomically, see
the <A HREF="userman.html">user manual</A>.
</P>

<HR>
<H2>The indexing script</H2>

We've now seen the program which controls the indexing.  It's now time
to look at the indexing script itself, in indexfile.xml.

<H3>The file format</H3>

<P>
The file format is described by the XML DTD omindexer.dtd, which should
be installed with the Open Muscat library.  At the time of writing there
are no graphical or other tools to generate indexer descriptions - it
must be written by hand.  In future this should no longer be the case.
</P><P>
We'll go through the part of the indexer responsible for generating the
terms, without describing the parts which generate the keys and data
field.
</P>

<H3>The basic XML skeleton</H3>

An indexer XML description will always start with a tag identifying the
version of XML being used, and the rest will be enclosed in a top-level
<CODE>&lt;omindexer&gt;</CODE> tag:

<PRE>
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;omindexer&gt;
  ...
&lt;/omindexer&gt;
</PRE>

<H3>The splitter node</H3>

<P>
One of the basic nodes available is the <CODE>omsplitter</CODE> node.
It has one input (in) and two outputs (left, right), and simply
duplicates the input and provides a copy on each output.  This is an
important node, since it lets the indexer do two different things
with the same piece of data.
</P><P>
The top node in this indexer is an <CODE>omsplitter</CODE> which
connects to the special "START" node.  The "START" node has one output,
which contains the data passed in from <CODE>OmIndexer::set_input()</CODE>.
</P>

<PRE>
    &lt;!-- First make split the filename down two paths --&gt;
    &lt;node type=&quot;omsplitter&quot; id=&quot;splitfname&quot;&gt;
        &lt;input name=&quot;in&quot; node=&quot;START&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<P>
This specifies a node of type <CODE>omsplitter</CODE>, with id "splitfname".
The id can be anything, but must be unique in the indexer.  It should be a
descriptive name.  This node has one input connection, named "in", which is
connected to the "out" connection of the node with id "START".
</P>

<H3>Reading the file into memory</H3>

<P>
Before the terms can be extracted from the file, it must be loaded into
memory.  This is done by an <CODE>omfilereader</CODE> node.  The node
has one input, "filename", which should be the path to the file to open.
The file is read into memory, and written to the "out" connection.
</P>

<PRE>
    &lt;!-- In the left path, read the file into memory --&gt;
    &lt;node type=&quot;omfilereader&quot; id=&quot;readfile&quot;&gt;
        &lt;input name=&quot;filename&quot; node=&quot;splitfname&quot; out_name=&quot;left&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Splitting the file into words</H3>

<P>
The next thing to do is to split the contents of the file into words.
This is done by an <CODE>omregexsplit</CODE> node.  It takes a string
at input "in", and splits it into a list of smaller strings.  The
boundary is described by a POSIX regular expression, specified as a
configuration parameter named "regex".
</P><P>
The regular expression used here is "[^a-zA-Z]\+", which matches any
non-zero string of non-letters.  The result of the split will
therefore be a list of all the sequences of letters from the input
string.
</P>

<PRE>
    &lt;!-- Split the file into &quot;words&quot; --&gt;
    &lt;node type=&quot;omregexsplit&quot; id=&quot;wordsplit&quot;&gt;
        &lt;param name=&quot;regex&quot; type=&quot;string&quot; value=&quot;[^a-zA-Z]\+&quot;/&gt;
        &lt;input name=&quot;in&quot; node=&quot;readfile&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Duplicating the word list</H3>

<P>
We make use of an <CODE>omsplitter</CODE> node again to copy the list
of words, so that we can do different operations on each copy.
</P>

<PRE>
    &lt;!-- Duplicate the list of words --&gt;
    &lt;node type=&quot;omsplitter&quot; id=&quot;dupwords&quot;&gt;
        &lt;input name=&quot;in&quot; node=&quot;wordsplit&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Processing capitalised words</H3>

<P>
The first step is to remove the lower-case words from the list.  This is
done using an <CODE>omregexfilter</CODE> node.  The input to this node
is a list of strings.  The output is the subset of the strings in the
input list which match a particular regular expression.  In this case
we set the regular expression to "^[A-Z]", which matches a capital letter
at the start of the string.
</P>
<PRE>
    &lt;!-- Left branch, separate capital words --&gt;
    &lt;node type=&quot;omregexfilter&quot; id=&quot;capsonly&quot;&gt;
        &lt;param name=&quot;regex&quot; type=&quot;string&quot; value=&quot;^[A-Z]&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;dupwords&quot; out_name=&quot;left&quot;/&gt;&lt;/node&gt;
</PRE>

<P>
Once we've separated the capitalized words out, we want to lower case them.
In our indexing scheme all normal words are stored in the database lower
cased, and some special terms may be stored with an initial capital letter.
We do the lower-casing using an <CODE>omtranslatelist</CODE> node.  It takes
as input a list of strings (the similar <CODE>omtranslate</CODE> node takes
a single string instead).  There are two configuration parameters to set.
"from" and "to" should be strings of equal length.  The nth character of
"from" will be replaced by the nth character of "to" in the output of the
node.  In this example we translate each upper-case letter to its lower-case
equivalent.
</P>

<PRE>
    &lt;node type=&quot;omtranslatelist&quot; id=&quot;lowercaps&quot;&gt;
        &lt;param name=&quot;from&quot; type=&quot;string&quot; value=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;/&gt;
        &lt;param name=&quot;to&quot; type=&quot;string&quot; value=&quot;abcdefghijklmnopqrstuvwxyz&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;capsonly&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Processing the second copy of the word list</H3>

<P>
We'll take the other copy of the word list and apply the English stemmer.
For this we use the <CODE>omstemmer</CODE> node.  This node takes a list
of words in the input "in" and returns the list of stemmed words in output
"out".  The configuration parameter "language" sets the stemmer language.
</P><P>
Before stemming, we need to lower-case the words, which we do with an
<CODE>omtranslate</CODE> node as before.
</P>

<PRE>
    &lt;!-- Right branch, lower case everything... --&gt;
    &lt;node type=&quot;omtranslatelist&quot; id=&quot;tolower&quot;&gt;
        &lt;param name=&quot;from&quot; type=&quot;string&quot; value=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;/&gt;
        &lt;param name=&quot;to&quot; type=&quot;string&quot; value=&quot;abcdefghijklmnopqrstuvwxyz&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;dupwords&quot; out_name=&quot;right&quot;/&gt;&lt;/node&gt;
    &lt;!-- ... and stem --&gt;
    &lt;node type=&quot;omstemmer&quot; id=&quot;stem&quot;&gt;
        &lt;param name=&quot;language&quot; type=&quot;string&quot; value=&quot;english&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;tolower&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Merging the word lists</H3>

<P>
Now that we have two lists of words, we want to join them back together
again.  This is done with an <CODE>omlistconcat</CODE> node.  It has
two inputs, "left" and "right", and simply appends the contents of
the list at "right" to the list at "left".

<PRE>
    &lt;!-- Now merge the two lists of terms --&gt;
    &lt;node type=&quot;omlistconcat&quot; id=&quot;terms&quot;&gt;
        &lt;input name=&quot;left&quot; node=&quot;lowercaps&quot; out_name=&quot;out&quot;/&gt;
	&lt;input name=&quot;right&quot; node=&quot;stem&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
</PRE>

<H3>Making a termlist from the words</H3>

<P>
Before it can be used with an <CODE>OmDocumentContents</CODE> object, the
termlist must be in the right form.  Two nodes help with this:
<CODE>omnewtermlist</CODE> and <CODE>omtermlistadd</CODE>
<!--
    &lt;!-- convert the terms into a termlist --&gt;
    &lt;node type=&quot;omnewtermlist&quot; id=&quot;maketermlist&quot;&gt;&lt;/node&gt;
    &lt;node type=&quot;omtermlistadd&quot; id=&quot;addtermlist&quot;&gt;
        &lt;input name=&quot;termlist&quot; node=&quot;maketermlist&quot; out_name=&quot;out&quot;/&gt;
	&lt;input name=&quot;words&quot; node=&quot;terms&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;

    &lt;!-- Right branch from splitfname --&gt;
    &lt;!-- Split the filename again --&gt;
    &lt;node type=&quot;omsplitter&quot; id=&quot;splitfname2&quot;&gt;
        &lt;input name=&quot;in&quot; node=&quot;splitfname&quot; out_name=&quot;right&quot;/&gt;&lt;/node&gt;
    &lt;node type=&quot;omsplitter&quot; id=&quot;splitfname3&quot;&gt;
        &lt;input name=&quot;in&quot; node=&quot;splitfname2&quot; out_name=&quot;right&quot;/&gt;&lt;/node&gt;
    &lt;!-- extract the filename --&gt;
    &lt;node type=&quot;omregexreplace&quot; id=&quot;filenameonly&quot;&gt;
        &lt;param name=&quot;regex&quot; type=&quot;string&quot; value=&quot;^(.*/)?([^/]+)$&quot;/&gt;
        &lt;param name=&quot;replace_expr&quot; type=&quot;string&quot; value=&quot;\2&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;splitfname2&quot; out_name=&quot;left&quot;/&gt;&lt;/node&gt;
    &lt;!-- prefix the filename with &quot;F&quot; --&gt;
    &lt;node type=&quot;omprefix&quot; id=&quot;prefixF&quot;&gt;
        &lt;param name=&quot;prefix&quot; type=&quot;string&quot; value=&quot;F&quot;/&gt;
	&lt;input name=&quot;in&quot; node=&quot;filenameonly&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;
    &lt;!-- add into termlist --&gt;
    &lt;node type=&quot;omtermlistaddone&quot; id=&quot;addfilename&quot;&gt;
        &lt;input name=&quot;termlist&quot; node=&quot;addtermlist&quot; out_name=&quot;out&quot;/&gt;
	&lt;input name=&quot;words&quot; node=&quot;prefixF&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;

    &lt;!-- handle the keys: make a new keylist --&gt;
    &lt;node type=&quot;omnewkeylist&quot; id=&quot;newkey&quot;&gt;&lt;/node&gt;
    &lt;!-- split the filename into directory and name --&gt;
    &lt;node type=&quot;omregexmatch&quot; id=&quot;splitdir&quot;&gt;
        &lt;param name=&quot;regex&quot; type=&quot;string&quot;&gt;\(.*/\)\?\([^/]*\)$&lt;/param&gt;
    	&lt;input name=&quot;in&quot; node=&quot;splitfname3&quot; out_name=&quot;left&quot;/&gt;&lt;/node&gt;
    &lt;!-- Select the submatches, dropping the whole filename --&gt;
    &lt;node type=&quot;omselectitems&quot; id=&quot;selectsubs&quot;&gt;
        &lt;param name=&quot;items&quot; type=&quot;list&quot;&gt;
	    &lt;item value=&quot;1&quot;/&gt;
	    &lt;item value=&quot;2&quot;/&gt;&lt;/param&gt;
	&lt;input name=&quot;in&quot; node=&quot;splitdir&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;

    &lt;!-- Generate the key numbers --&gt;
    &lt;node type=&quot;ommakerange&quot; id=&quot;keyrange&quot;&gt;
        &lt;param name=&quot;first&quot; type=&quot;string&quot; value=&quot;1&quot;/&gt;
        &lt;param name=&quot;step&quot; type=&quot;string&quot; value=&quot;1&quot;/&gt;
        &lt;param name=&quot;count&quot; type=&quot;string&quot; value=&quot;2&quot;/&gt;&lt;/node&gt;
    &lt;!-- pair the key numbers with the key values --&gt;
    &lt;node type=&quot;ommakepairs&quot; id=&quot;keypairs&quot;&gt;
        &lt;input name=&quot;left&quot; node=&quot;keyrange&quot; out_name=&quot;out&quot;/&gt;
        &lt;input name=&quot;right&quot; node=&quot;selectsubs&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;

    &lt;!-- add the key to the list --&gt;
    &lt;node type=&quot;omkeylistadd&quot; id=&quot;addkeys&quot;&gt;
    	&lt;input name=&quot;keylist&quot; node=&quot;newkey&quot; out_name=&quot;out&quot;/&gt;
	&lt;input name=&quot;keys&quot; node=&quot;keypairs&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;

    &lt;!-- join everything into the final document --&gt;
    &lt;node type=&quot;ommakedoc&quot; id=&quot;doc&quot;&gt;
        &lt;input name=&quot;terms&quot; node=&quot;addfilename&quot; out_name=&quot;out&quot;/&gt;
	&lt;input name=&quot;data&quot; node=&quot;splitfname3&quot; out_name=&quot;right&quot;/&gt;
	&lt;input name=&quot;keys&quot; node=&quot;addkeys&quot; out_name=&quot;out&quot;/&gt;&lt;/node&gt;

    &lt;!-- specify the output --&gt;
    &lt;output node=&quot;doc&quot; out_name=&quot;out&quot;/&gt;
</PRE>
-->

<!-- FIXME: below is still from the original quickstart.html -->

<HR>
<H2>Compiling</H2>

Now that we have the code written, all we need to do is compile it!

<H3>Finding the Muscat library</H3>

<P>
A small utility, &quot;libomus-config&quot;, is installed along with Muscat
to assist you in finding the installed Muscat library, and in generating
the flags to pass to the compiler and linker to compile.
</P><P>
After a successful compilation, this utility should be in your path, so
you can simply run
<BLOCKQUOTE><CODE>libomus-config --cflags</CODE></BLOCKQUOTE>
to determine the flags to pass to the compiler, and
<BLOCKQUOTE><CODE>libomus-config --libs</CODE></BLOCKQUOTE>
to determine the flags to pass to the linker.

These flags are returned on the utility's standard output (so you could use
backtick notation to include them on your command line).
</P><P>
If your project uses the GNU autoconf tool, you may also use the
<CODE>OM_PATH_LIBOMUS</CODE> macro, which is included as part of Muscat,
and will check for an installation of Muscat and set (and
<CODE>AC_SUBST</CODE>) the <CODE>LIBOMUS_CFLAGS</CODE> and
<CODE>LIBOMUS_LIBS</CODE> variables to
be the flags to pass to the compiler and linker, respectively.
This macro will also allow you to use an uninstalled version of Muscat.
</P><P>
If you don't use GNU autoconf, don't worry about this.
</P>

<H3>Compiling the simple examples</H3>
Once you know the compilation flags, compilation is a simple matter of
invoking the compiler!  For our example, we could compile the two
utilities (simpleindex and simplesearch) with the commands:
<PRE>
c++ simpleindex.cc `libomus-config --libs --cflags` -o simpleindex
c++ simplesearch.cc `libomus-config --libs --cflags` -o simplesearch
</PRE>

<HR>
<H2>Running the examples</H2>

<P>
Once we have compiled the examples, we can build up a simple database as
follows.  Note that we must first create a directory for the database files to
live in; although Muscat will create new empty database files if they do not
yet exist, it will not create a new directory for them.
<PRE>
$ mkdir proverbs
$ ./simpleindex proverbs \
&gt; "people who live in glass houses should not throw stones" \
&gt; people live glass house stone
$ ./simpleindex proverbs \
&gt; "Don't look a gift horse in the mouth" \
&gt; look gift horse mouth
</PRE>
</P>

<P>
Now, we should have a database with a couple of documents in it.  Looking
in the database directory, you should see something like:
<PRE>
$ ls proverbs/
document.db  postlist.db  termid.db  termlist.db  termname.db
</PRE>
</P>
<P>
Given the small amount of data in the database, you may be concerned that
the total size of these files is somewhat over 50k.  Be reassured that the
database is block structured, here consisting of largely empty
blocks, and will behave much better for large databases.  It is worth
noting, however, that the sleepycat backend is not currently very efficient
(in either space or time), and that this will be improving greatly in the
future.
</P>

<P>
We can at last perform searches over the database using the simplesearch
program.
<PRE>
$ ./simplesearch proverbs look
Performing query `look'
1 results found
Document ID 2   50% [Don't look a gift horse in the mouth]
</PRE>
</P>

<HR>
<H2>Further documentation</H2>

For more detailed documentation on the API, there are two pieces of
documentation available.
<UL><LI>
The <A HREF="userman.html">user manual</A>, which is designed as an
introduction to the API.
</LI>
<LI>
An <A HREF="apidoc/html/index.html">API reference</A>, which is automatically extracted from the extensive
comments in the source code by
<EM><A HREF="http://www.stack.nl/~dimitri/doxygen/index.html">Doxygen</A></EM>.
This is distributed together with the source code packages, but in the
event that you do not have a this there is a
<A HREF="http://open.muscat.com/developer/docs/apidoc/html/index.html">copy</A>
available on our website.
</LI></UL>

For those interested in how Muscat works internally, there is also
automatically extracted documentation of the full source code, available
on our
<A HREF="http://open.muscat.com/developer/docs/sourcedoc/html/index.html">website</A>.  You may also build this documentation yourself, if you have Doxygen
installed, by running
<PRE>
    make doxygen_docs
</PRE>
from within the <CODE>docs</CODE> subdirectory of the <CODE>om</CODE> source
tree.

<!-- FOOTER $Author$ $Date$ $Id$ -->
</BODY>
</HTML>
