<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Muscat: User manual</TITLE>
</HEAD>
<BODY BGCOLOR="white">

<B>Note: This document is still in the early stages of being written.<BR>
The content, and formatting, will improve.  Helpful comments are always welcome.
<BR>
Richard Boulton - 11 Feb 2000</B>

<H1>Overview</H1>

<P>
This document provides an introduction to the native C++ Muscat API.
This API allows programmers quickly to add the ability to search through
(potentially very large) bodies of data using probabalistic methods.
</P>

<P>
<EM>Note:</EM>
The API currently implemented covers only the part of Muscat concerned with
searching through existing indices.  The process of creating indexes is thus
not covered by this document.
</P>

<P>
It is probably a good idea to read the
<A HREF="intro_ir.html">Introduction to Information Retrieval</A> and the
<A HREF="intro.html">Introduction to Muscat</A> before reading this document,
or at least before attempting to use the API.
</P>

<P>
This document does not detail the exact calling conventions (parameters
passed, return value, exceptions thrown, etc...) for each method in the API.
For such documentation, you should refer to the automatically extracted
documentation, which is generated from detailed comments in the source code,
and should thus remain up-to-date and accurate.  This documentation is
generated by using a slightly modified version of 
<A HREF="http://www.linuxsupportline.com/~doc++">DOC++</A>.
This is available on our CVS site (module
<A HREF="http://cvs.muscat.com/cvs/doc++">doc++</A>), but to save you having to
use this, we include the <A HREF="apidoc/index.html">built version</A>
in our distributions, and also keep the
<A HREF="http://open.muscat.com/open/developer/docs/apidoc/index.html">latest version</A> on our website.
</P>

<H2>Errors and exceptions</H2>

<P>
Error reporting is often relegated to the back of manuals such as this.
However, it is extremely important to understand the errors which may be
caused by the operations which you are trying to perform.

This becomes particularly relevant when using a large system, with such
possibilities as databases which are being updated while you search
through them, and distributed enquiry systems.
</P>

<P>
Errors in Muscat are all reported by means of exceptions.  All exceptions
thrown by Muscat will be subclasses of
<A HREF="apidoc/OmError.html"><CODE>OmError</CODE></A>.  Note that
<CODE>OmError</CODE> is an abstract class; thus you should catch exceptions
by reference rather than by value.
</P>

<P>
There are two flavours of error, derived from <CODE>OmError</CODE>:
<UL><LI>
<A HREF="apidoc/OmLogicError.html"><CODE>OmLogicError</CODE></A>
- for error conditions due to programming errors, such as a misuse of the
API.  A finished application should not receive these errors (though it
would still be sensible to catch them).
</LI><LI>
<A HREF="apidoc/OmRuntimeError.html"><CODE>OmRuntimeError</CODE></A>
- for error conditions due to run time problems, such as failure to open
a database.  You must always be ready to cope with such errors.
</LI></UL>
</P>

<P>
Each of these flavours is further subdivided, such that any particular
error condition can be trapped by catching the appropriate exception.
If desired, a human readable explanation of the error can be retrieved
by calling
<A HREF="apidoc/OmError.html#get_msg"><CODE>OmError::get_msg()</CODE></A>.
</P>

<P>
In addition, standard system errors may occur: these will be reported by
throwing appropriate exceptions.  Most notably, if the system runs out
of memory, a <CODE>std::bad_alloc()</CODE> exception will be thrown.
</P>

<H2>Terminology</H2>
<H3>Databases</H3>
<P>
These may also occasionally be called <EM>Indexes</EM>.  In Muscat (as
opposed to a database package) a database consists of little more than
indexed documents: this reflects the purpose of Muscat as an information
retrieval system, rather than an information storage system.
</P>
<P>
The exact contents of a database depend on the type (see
&quot;<A HREF="#database_types">Database Types</A>&quot; for more details
of the database types currently provided).
</P>

<H3>Queries</H3>


<H2>The OmEnquire class</H2>

<P>
The <A HREF="apidoc/OmEnquire.html"><CODE>OmEnquire()</CODE></A> class
is central to all searching operations.  It provides an interface for
<UL><LI>
Specifying the database, or databases, to search across.
</LI><LI>
Specifying a query to perform.
</LI><LI>
Specifying a set of documents which a user considers relevant.
</LI><LI>
Given the supplied information, returning a ranked set of documents for
the user.
</LI><LI>
Given the supplied information, suggesting a ranked set of terms to add to the
query.
</LI><LI>
</LI></UL>
</P>
<P>
A typical enquiry session will consist of most of these operations, in
various orders.  The OmEnquire class presents as few restrictions as
possible on the order in which operations should be performed.  For
example, although you must set the query before asking for the results,
the database can be specified, or changed, before or after running the
query.
</P>
<P>
Many operations performed by the OmEnquire class are performed lazily (ie,
just before their results are needed).  This need not concern the user
except to note that, as a result, errors may not be reported as soon as
would otherwise be expected.  In particular, 
</P>

<H2>Opening a database</H2>

Before any other enquire operations may be performed, a database must be
opened.
(An
<A HREF="apidoc/OmInvalidArgumentError.html"><CODE>OmInvalidArgumentError</CODE></A>
will be thrown if the database is not
)

<H3>Opening more databases</H3>

<P>
Muscat can search across several databases as easily as searching across a
single one.  Simply call
<A HREF="apidoc/OmEnquire.html#add_database"><CODE>OmEnquire::add_database()</CODE></A>
for each database that you wish to search through.
</P>
<P>
Other operations may be performed
</P>

<A NAME="database_types"><H3>Database types</H3></A>

<H2>Specifying a query</H2>

<P>
Muscat implements both boolean and probabalistic searching.  Traditionally,
these have been combined either by:
<OL><LI>
Performing a boolean search and then a probabalistic search over the
resulting documents, or
</LI><LI>
by performing a probabalistic search and filtering the resulting documents
with a boolean query.
</LI></OL>
The difference between these two is that the collection statistics for the
former will represent the space of documents being searched by probabalistic
methods, rather than some abstract larger set. If the boolean query is
being used to restrict to, say, documents in English (where the database
contains English and French documents), the latter would result in a word such
as &quot;<EM>chose</EM>&quot;, which has different usage in both langauges,
being allocated an incorrect weight.
</P>
<P>
In summary, the former is likely to produce a better result, but the
latter can be more efficiently implemented.
</P>
<P>
Muscat uses a third approach, which is to perform both queries
simultaneously.  This allows us to
</P>

<H3>Undefined queries</H3>
<P>
These are an added complication, although they make it possible to write
much neater code, and to perform some extra types of query. (See
<A HREF="#purebool">"Specifying a pure boolean query"</A>).
</P>

<P>
Undefined queries are not empty queries, or queries which match nothing:
rather, they should be thought of as placeholders.  An undefined query is
created by calling the default constructor for OmQuery(), and can then be
used in many places in construction of a query.
</P>

<H3><A NAME="purebool">Specifying a pure boolean query</A></H3>
Occasionally it may be desirable to perform a purely boolean query, and not
to calculate weights for each document.  This can be performed within Muscat
as follows:
<UL><LI>
Make the desired boolean query, as described above.
For example, putting it in <CODE>query</CODE>:
example:<PRE>
OmQuery query(OM_MOP_NOT, OmQuery("cheese"), OmQuery("bread"));
</PRE>
</LI><LI>
Make a boolean only query, by filtering a null query with the boolean query.
For example:
<PRE>
OmQuery boolquery(OM_MOP_FILTER, OmQuery(), query);
</PRE>
</LI></UL>

The boolquery will return a set of documents matching the criteria supplied:
each document in the result set will have a weight of 1.
<P>
Why does this work?  Well, 

<H2>Setting options for a query</H2>

There are various additional options 

<H2>Retrieving the results of a query</H2>

<H3>The MSet</H3>

<H2>Specifying a relevance set</H2>

<H2>Suggesting new terms for the query</H2>


<H2>A simple example</H2>
<P>
A simple example of usage of the Muscat API is given 
</P>

<HR>

Last modified: 7 Feb 2000 by Richard Boulton

</BODY>
</HTML>
