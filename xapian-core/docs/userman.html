<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Muscat: User manual</TITLE>
</HEAD>
<BODY BGCOLOR="white">

<B>Note: This document is still in the early stages of being written.<BR>
The content, and formatting, will improve.  Helpful comments are always welcome.
<BR>
Richard Boulton - 11 Feb 2000</B>

<H1>Overview</H1>

<P>
This document provides an introduction to the native C++ Muscat API.
This API allows programmers quickly to add the ability to search through
(potentially very large) bodies of data using probabilistic methods.
</P>

<P>
<EM>Note:</EM>
The API currently implemented covers only the part of Muscat concerned with
searching through existing indices.  The process of creating indexes is thus
not covered by this document.
</P>

<P>
It is probably a good idea to read the
<A HREF="intro_ir.html">Introduction to Information Retrieval</A> and the
<A HREF="intro.html">Introduction to Muscat</A> before reading this document,
or at least before attempting to use the API.
</P>

<P>
This document does not detail the exact calling conventions (parameters
passed, return value, exceptions thrown, etc...) for each method in the API.
For such documentation, you should refer to the automatically extracted
documentation, which is generated from detailed comments in the source code,
and should thus remain up-to-date and accurate.  This documentation is
generated by using a slightly modified version of 
<A HREF="http://www.linuxsupportline.com/~doc++">DOC++</A>.
This is available on our CVS site (module
<A HREF="http://cvs.muscat.com/cvs/doc++">doc++</A>), but to save you having to
use this, we include the <A HREF="apidoc/index.html">built version</A>
in our distributions, and also keep the
<A HREF="http://open.muscat.com/open/developer/docs/apidoc/index.html">latest version</A> on our website.
</P>

<H2>Errors and exceptions</H2>

<P>
Error reporting is often relegated to the back of manuals such as this.
However, it is extremely important to understand the errors which may be
caused by the operations which you are trying to perform.

This becomes particularly relevant when using a large system, with such
possibilities as databases which are being updated while you search
through them, and distributed enquiry systems.
</P>

<P>
Errors in Muscat are all reported by means of exceptions.  All exceptions
thrown by Muscat will be subclasses of
<A HREF="apidoc/OmError.html"><CODE>OmError</CODE></A>.  Note that
<CODE>OmError</CODE> is an abstract class; thus you should catch exceptions
by reference rather than by value.
</P>

<P>
There are two flavours of error, derived from <CODE>OmError</CODE>:
<UL><LI>
<A HREF="apidoc/OmLogicError.html"><CODE>OmLogicError</CODE></A>
- for error conditions due to programming errors, such as a misuse of the
API.  A finished application should not receive these errors (though it
would still be sensible to catch them).
</LI><LI>
<A HREF="apidoc/OmRuntimeError.html"><CODE>OmRuntimeError</CODE></A>
- for error conditions due to run time problems, such as failure to open
a database.  You must always be ready to cope with such errors.
</LI></UL>
</P>

<P>
Each of these flavours is further subdivided, such that any particular
error condition can be trapped by catching the appropriate exception.
If desired, a human readable explanation of the error can be retrieved
by calling
<A HREF="apidoc/OmError.html#get_msg"><CODE>OmError::get_msg()</CODE></A>.
</P>

<P>
In addition, standard system errors may occur: these will be reported by
throwing appropriate exceptions.  Most notably, if the system runs out
of memory, a <CODE>std::bad_alloc()</CODE> exception will be thrown.
</P>

<H2>Terminology</H2>
<H3>Databases</H3>
<P>
These may also occasionally be called <EM>Indexes</EM>.  In Muscat (as
opposed to a database package) a database consists of little more than
indexed documents: this reflects the purpose of Muscat as an information
retrieval system, rather than an information storage system.
</P>
<P>
The exact contents of a database depend on the type (see
&quot;<A HREF="#database_types">Database Types</A>&quot; for more details
of the database types currently provided).
</P>

<H3>Queries</H3>
<P>
The information to be searched for is specified by a <EM>Query</EM>.  In
Muscat, queries are comprised of a structured boolean tree, upon which
probabilistic weightings are imposed: when the search is performed, the
documents returned are filtered according to the boolean structure, and
weighted (and sorted) according to the probabilistic model of information
retrieval.
</P>

<H2>The OmEnquire class</H2>

<P>
The <A HREF="apidoc/OmEnquire.html"><CODE>OmEnquire()</CODE></A> class
is central to all searching operations.  It provides an interface for
<UL><LI>
Specifying the database, or databases, to search across.
</LI><LI>
Specifying a query to perform.
</LI><LI>
Specifying a set of documents which a user considers relevant.
</LI><LI>
Given the supplied information, returning a ranked set of documents for
the user.
</LI><LI>
Given the supplied information, suggesting a ranked set of terms to add to the
query.
</LI><LI>
Returning information about the documents which matched, such as their
associated data, and 
</LI></UL>
</P>
<P>
A typical enquiry session will consist of most of these operations, in
various orders.  The OmEnquire class presents as few restrictions as
possible on the order in which operations should be performed.  For
example, although you must set the query before asking for the results,
the database can be specified, or changed, before or after running the
query.
</P>
<P>
Many operations performed by the OmEnquire class are performed lazily (ie,
just before their results are needed).  This need not concern the user
except to note that, as a result, errors may not be reported as soon as
would otherwise be expected.  In particular, errors regarding opening of
the database may be reported when a query is performed (although they
may not: you should catch exceptions in both situations).
</P>

<H2>Specifying a database</H2>

<P>
Before any other enquire operations may be performed, a database to search
must be specified.  (An
<A HREF="apidoc/OmInvalidArgumentError.html"><CODE>OmInvalidArgumentError</CODE></A>
will be thrown if the database is not specified when it is needed.)
</P>
<P>
Databases are specified by calling
<A HREF="apidoc/OmEnquire.html#add_database"><CODE>OmEnquire::add_database()</CODE></A>
.  This takes two parameters;
"<CODE><B>type</B></CODE>" which is a string
representing the type of the database to open, and
"<CODE><B>params</B></CODE>" which is a set of strings, the meaning of which
depend on the database type.
</P>
<P>
Note that these parameters <EM>are</EM> case sensitive.

<A NAME="database_types"><H3>Database types</H3></A>
The current types understood by muscat are:
</P>
<TABLE>
<TR><TD VALIGN="top"><B>da_flimsy</B></TD><TD>
This is a proprietory, legacy format, holding a database in a
non-updatable form (ie, the database can't be altered, it is built
from an existing database).  We support read-only access to this,
and it is thus unlikely to be useful outside our company.
<BR>
It takes one parameter, which is the path to the directory containing
the Term and Record files. 
</TD></TR>
<TR><TD VALIGN="top"><B>inmemory</B></TD><TD>
This type is an index held entirely in memory.
It is really designed to be used as a cache while building indexes
(ie, build up your records into one of these, and periodically
flush into the main database).
<BR>
However, for the moment a simple indexing routine is grafted
onto it, which indexes a file of text into records (roughly on a
paragraph by paragraph basis).
<BR>
It will eventually take no parameters at all, but for now takes an
arbitrary number of filenames: each one will be opened and indexed into the
database when the database is first used.
</TD></TR>
</TABLE>

<H3>Multiple databases</H3>

<P>
Muscat can search across several databases as easily as searching across a
single one.  Simply call
<A HREF="apidoc/OmEnquire.html#add_database"><CODE>OmEnquire::add_database()</CODE></A>
for each database that you wish to search through.
</P>
<P>
Other operations, such as setting the query, may be performed before or after
this call.  It is even possible to perform a query, add a further database,
and then perform the query again to get the results with the extra database
(although this isn't very likely to be useful in practice).
</P>

<H2>Specifying a query</H2>

<P>
Muscat implements both boolean and probabilistic searching.  Traditionally,
these have been combined either by:
<UL><LI>
Performing a boolean search and then a probabilistic search over the
resulting documents, or
</LI><LI>
By performing a probabilistic search and filtering the resulting documents
with a boolean query.
</LI></UL>
The difference between these two is that the collection statistics for the
former will represent the space of documents being searched by probabilistic
methods, rather than some abstract larger set. If the boolean query is
being used to restrict to, say, documents in English (where the database
contains English and French documents), the latter would result in a word such
as &quot;<EM>chose</EM>&quot;, which has different usage in both langauges,
being allocated an incorrect weight.
</P>
<P>
In summary, the former is likely to produce a better result, but the
latter can be more efficiently implemented.
</P>
<P>
Muscat uses a third approach, which is to perform both searches
simultaneously.  This allows us to perform various optimisations, such
as giving up on calculating a boolean AND operations when the probabilistic
weights that could result from further documents can have no effect on the
result set.  Early indications are that these optimisations give us a two- or
three-fold performance increase in certain cases.  The performance is
particularly good for queries containing many terms.
</P>

<H3>A query for a single term</H3>
<P>
All queries are represented by
<A HREF="apidoc/OmQuery.html"><CODE>OmQuery()</CODE></A>
objects.  The simplest possible (non-trivial) query is one which searches
for a single term.  This can be created as follows (where <CODE>tname</CODE> is the term to be searched for):
</P>
<PRE>
OmQuery query(tname);
</PRE>
<P>
A term in Muscat is simply represented by a string of binary characters.
Usually, when searching text, these characters will be the word which the
term represents, but during the information retrieval process Muscat
attaches no specific meaning to the term.
</P>
<P>
This constructor actually takes a couple of extra parameters, which may be
used to specify positional and frequency information for terms in the query:
<P>
<PRE>
OmQuery(const om_termname &amp; tname_,
        om_termcount wqf_ = 1,
        om_termpos term_pos_ = 0) 
</PRE>

<H3>Compound queries</H3>
<P>
More complicated queries are built up by combining single term queries
using various operators, using the following constructor:
</P>
<PRE>
OmQuery(om_queryop op_,
	const OmQuery &amp; left,
	const OmQuery &amp; right)
</PRE>
<P>
The full set of available operators is:
<TABLE>
<TR><TD VALIGN="top">
OM_MOP_AND 
</TD><TD>
Return a document if and only if both subqueries are satisfied.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_OR 
</TD><TD>
Return a document if either subquery is satisfied.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_AND_NOT 
</TD><TD>
Return a document if left subquery is satisfied and right subquery is not
satisfied.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_XOR 
</TD><TD>
Return a document if one subquery is satisfied, but not both.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_AND_MAYBE 
</TD><TD>
Return a document if and only if the left subquery is satisfied, but calculate
document weights using both queries.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_FILTER 
</TD><TD>
As OM_MOP_AND, but use only weights from left subquery.
</TD></TR>
</TABLE>
</P>

<H3>Undefined queries</H3>
<P>
These are an added complication, although they make it possible to write
much neater code, and to perform some extra types of query. (See
<A HREF="#purebool">"Specifying a pure boolean query"</A>).
</P>

<P>
Undefined queries are not empty queries, or queries which match nothing:
rather, they should be thought of as placeholders.  An undefined query is
created by calling the default constructor for OmQuery(), and can then be
used in many places in construction of a query.
</P>

<H3><A NAME="purebool">Specifying a pure boolean query</A></H3>
Occasionally it may be desirable to perform a purely boolean query, and not
to calculate weights for each document.  This can be performed within Muscat
as follows:
<UL><LI>
Make the desired boolean query, as described above.
For example, putting it in <CODE>query</CODE>:
example:<PRE>
OmQuery query(OM_MOP_NOT, OmQuery("cheese"), OmQuery("bread"));
</PRE>
</LI><LI>
Make a boolean only query, by filtering a null query with the boolean query.
For example:
<PRE>
OmQuery boolquery(OM_MOP_FILTER, OmQuery(), query);
</PRE>
</LI></UL>

The boolquery will return a set of documents matching the criteria supplied:
each document in the result set will have a weight of 1.
<P>
Why does this work?  Well, 

<H2>Setting options for a query</H2>

There are various additional options 

<H2>Retrieving the results of a query</H2>

<H3>The MSet</H3>

<H2>Specifying a relevance set</H2>

<H2>Suggesting new terms for the query</H2>


<H2>A simple example</H2>
<P>
A simple example of usage of the Muscat API is given 
</P>

<HR>

Last modified: 7 Feb 2000 by Richard Boulton

</BODY>
</HTML>
