<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Muscat: User manual</TITLE>
</HEAD>
<BODY BGCOLOR="white">

<B>Note: This document is still being written.<BR>
The content, and formatting, will improve.  Helpful comments are always welcome.
<BR>
Richard Boulton - 15 Feb 2000</B>

<H1>Overview</H1>

<P>
This document provides an introduction to the native C++ Muscat API.
This API provides programmers with the ability to search through
(potentially very large) bodies of data using probabilistic methods.
</P>

<P>
<EM>Note:</EM>
The API currently implemented covers only the part of Muscat concerned with
searching through existing indices.  The process of creating indexes is thus
not covered by this document.
</P>

<P>
It is probably a good idea to read the
<A HREF="intro_ir.html">Introduction to Information Retrieval</A> and the
<A HREF="intro.html">Introduction to Muscat</A> before reading this document,
or at least before attempting to use the API.
</P>

<P>
This document does not detail the exact calling conventions (parameters
passed, return value, exceptions thrown, etc...) for each method in the API.
For such documentation, you should refer to the automatically extracted
documentation, which is generated from detailed comments in the source code,
and should thus remain up-to-date and accurate.  This documentation is
generated by using a slightly modified version of 
<A HREF="http://www.linuxsupportline.com/~doc++">DOC++</A>.
This is available on our CVS site (module
<A HREF="http://cvs.muscat.com/cvs/doc++">doc++</A>), but to save you having to
use this, we include the <A HREF="apidoc/index.html">built version</A>
in our distributions, and also keep the
<A HREF="http://open.muscat.com/open/developer/docs/apidoc/index.html">latest version</A> on our website.
</P>

<H2>Errors and exceptions</H2>

<P>
Error reporting is often relegated to the back of manuals such as this.
However, it is extremely important to understand the errors which may be
caused by the operations which you are trying to perform.

This becomes particularly relevant when using a large system, with such
possibilities as databases which are being updated while you search
through them, and distributed enquiry systems.
</P>

<P>
Errors in Muscat are all reported by means of exceptions.  All exceptions
thrown by Muscat will be subclasses of
<A HREF="apidoc/OmError.html"><CODE>OmError</CODE></A>.  Note that
<CODE>OmError</CODE> is an abstract class; thus you must catch exceptions
by reference rather than by value.
</P>

<P>
There are two flavours of error, derived from <CODE>OmError</CODE>:
<UL><LI>
<A HREF="apidoc/OmLogicError.html"><CODE>OmLogicError</CODE></A>
- for error conditions due to programming errors, such as a misuse of the
API.  A finished application should not receive these errors (though it
would still be sensible to catch them).
</LI><LI>
<A HREF="apidoc/OmRuntimeError.html"><CODE>OmRuntimeError</CODE></A>
- for error conditions due to run time problems, such as failure to open
a database.  You must always be ready to cope with such errors.
</LI></UL>
</P>

<P>
Each of these flavours is further subdivided, such that any particular
error condition can be trapped by catching the appropriate exception.
If desired, a human readable explanation of the error can be retrieved
by calling
<A HREF="apidoc/OmError.html#get_msg"><CODE>OmError::get_msg()</CODE></A>.
</P>

<P>
In addition, standard system errors may occur: these will be reported by
throwing appropriate exceptions.  Most notably, if the system runs out
of memory, a <CODE>std::bad_alloc()</CODE> exception will be thrown.
</P>

<H2>Terminology</H2>
<H3>Databases</H3>
<P>
These may also occasionally be called <EM>Indexes</EM>.  In Muscat (as
opposed to a database package) a database consists of little more than
indexed documents: this reflects the purpose of Muscat as an information
retrieval system, rather than an information storage system.
</P>
<P>
The exact contents of a database depend on the type (see
&quot;<A HREF="#database_types">Database Types</A>&quot; for more details
of the database types currently provided).
</P>

<H3>Queries</H3>
<P>
The information to be searched for is specified by a <EM>Query</EM>.  In
Muscat, queries are comprised of a structured boolean tree, upon which
probabilistic weightings are imposed: when the search is performed, the
documents returned are filtered according to the boolean structure, and
weighted (and sorted) according to the probabilistic model of information
retrieval.
</P>

<H2>The OmEnquire class</H2>

<P>
The <A HREF="apidoc/OmEnquire.html"><CODE>OmEnquire()</CODE></A> class
is central to all searching operations.  It provides an interface for
<UL><LI>
Specifying the database, or databases, to search across.
</LI><LI>
Specifying a query to perform.
</LI><LI>
Specifying a set of documents which a user considers relevant.
</LI><LI>
Given the supplied information, returning a ranked set of documents for
the user.
</LI><LI>
Given the supplied information, suggesting a ranked set of terms to add to the
query.
</LI><LI>
Returning information about the documents which matched, such as their
associated data, and which terms from the query were found within them.
</LI></UL>
</P>
<P>
A typical enquiry session will consist of most of these operations, in
various orders.  The OmEnquire class presents as few restrictions as
possible on the order in which operations should be performed.  For
example, although you must set the query before asking for the results,
the database can be specified, or changed, before or after running the
query.
</P>
<P>
Many operations performed by the OmEnquire class are performed lazily (ie,
just before their results are needed).  This need not concern the user
except to note that, as a result, errors may not be reported as soon as
would otherwise be expected.  In particular, errors regarding opening of
the database may be reported when a query is performed (although they
may not: you should catch exceptions in both situations).
</P>

<H2>Specifying a database</H2>

<P>
Before any other enquire operations may be performed, a database to search
must be specified.  (An
<A HREF="apidoc/OmInvalidArgumentError.html"><CODE>OmInvalidArgumentError</CODE></A>
will be thrown if the database is not specified when it is needed.)
</P>
<P>
Databases are specified by calling
<A HREF="apidoc/OmEnquire.html#add_database"><CODE>OmEnquire::add_database()</CODE></A>
.  This takes two parameters;
"<CODE><B>type</B></CODE>" which is a string
representing the type of the database to open, and
"<CODE><B>params</B></CODE>" which is a set of strings, the meaning of which
depend on the database type.
</P>
<P>
Note that these parameters <EM>are</EM> case sensitive.

<A NAME="database_types"><H3>Database types</H3></A>
The current types understood by muscat are:
</P>
<TABLE>
<TR><TD VALIGN="top"><B>da_flimsy</B></TD><TD>
This is a proprietory, legacy format, holding a database in a
non-updatable form (ie, the database can't be altered, it is built
from an existing database).  We support read-only access to this,
and it is thus unlikely to be useful outside our company.
<BR>
It takes one parameter, which is the path to the directory containing
the Term and Record files. 
</TD></TR>
<TR><TD VALIGN="top"><B>inmemory</B></TD><TD>
This type is an index held entirely in memory.
It is really designed to be used as a cache while building indexes
(ie, build up your records into one of these, and periodically
flush into the main database).
<BR>
However, for the moment a simple indexing routine is grafted
onto it, which indexes a file of text into records (roughly on a
paragraph by paragraph basis).
<BR>
It will eventually take no parameters at all, but for now takes an
arbitrary number of filenames: each one will be opened and indexed into the
database when the database is first used.
</TD></TR>
</TABLE>

<H3>Multiple databases</H3>

<P>
Muscat can search across several databases as easily as searching across a
single one.  Simply call
<A HREF="apidoc/OmEnquire.html#add_database"><CODE>OmEnquire::add_database()</CODE></A>
for each database that you wish to search through.
</P>
<P>
Other operations, such as setting the query, may be performed before or after
this call.  It is even possible to perform a query, add a further database,
and then perform the query again to get the results with the extra database
(although this isn't very likely to be useful in practice).
</P>

<H2>Specifying a query</H2>

<P>
Muscat implements both boolean and probabilistic searching.  Traditionally,
these have been combined either by:
<UL><LI>
Performing a boolean search and then a probabilistic search over the
resulting documents, or
</LI><LI>
By performing a probabilistic search and filtering the resulting documents
with a boolean query.
</LI></UL>
The difference between these two is that the collection statistics for the
former will represent the space of documents being searched by probabilistic
methods, rather than some abstract larger set. If the boolean query is
being used to restrict to, say, documents in English (where the database
contains English and French documents), the latter would result in a word such
as &quot;<EM>chose</EM>&quot;, which has different usage in both langauges,
being allocated an incorrect weight.
</P>
<P>
In summary, the former is likely to produce a better result, but the
latter can be more efficiently implemented.
</P>
<P>
Muscat uses a third approach, which is to perform both searches
simultaneously.  This allows us to perform various optimisations, such
as giving up on calculating a boolean AND operations when the probabilistic
weights that could result from further documents can have no effect on the
result set.  Early indications are that these optimisations give us a two- or
three-fold performance increase in certain cases.  The performance is
particularly good for queries containing many terms.
</P>

<H3>A query for a single term</H3>
<P>
All queries are represented by
<A HREF="apidoc/OmQuery.html"><CODE>OmQuery()</CODE></A>
objects.  The simplest possible (non-trivial) query is one which searches
for a single term.  This can be created as follows (where <CODE>tname</CODE> is the term to be searched for):
</P>
<PRE>
OmQuery query(tname);
</PRE>
<P>
A term in Muscat is simply represented by a string of binary characters.
Usually, when searching text, these characters will be the word which the
term represents, but during the information retrieval process Muscat
attaches no specific meaning to the term.
</P>
<P>
This constructor actually takes a couple of extra parameters, which may be
used to specify positional and frequency information for terms in the query:
<P>
<PRE>
OmQuery(const om_termname &amp; tname_,
        om_termcount wqf_ = 1,
        om_termpos term_pos_ = 0) 
</PRE>
<P>
The <CODE>wqf</CODE> (<B>W</B>ithin <B>Q</B>uery <B>F</B>requency) is
a measure of how common a term is in the query.  This is particularly useful
when generating a query from an existing document, but may also be used
as a crude way of increasing the importance of a term in a query.  Note that,
if the intention is simply to ensure that a particular term is in the query
results, you should use a boolean AND rather than set a high wqf.
</P>
<P>
The <CODE>term_pos</CODE> represents the position of the term in the query.
This is used for phrase searching, passage retrieval, and other operations
which require knowledge of the order of terms in the query (such as returning
the set of matching terms in a given document in the same order as they
occur in the query).  If such operations are not required, the default
value of 0 may be used.
</P>
<P>
Note that it may not make much sense to specify a wqf other than 1 when
supplying a term position (unless you are trying to affect the weighting,
as previously described).
</P>
<P>
Note also that the results of <CODE>OmQuery(tname, 2)</CODE> and
<CODE>OmQuery(OM_MOP_OR, OmQuery(tname), OmQuery(tname))</CODE>
are exactly equivalent.
</P>

<H3>Compound queries</H3>
<P>
More complicated queries are built up by combining single term queries
using various operators, using the following constructor:
</P>
<PRE>
OmQuery(om_queryop op_,
	const OmQuery &amp; left,
	const OmQuery &amp; right)
</PRE>
<P>
The two most common operators are <CODE>OM_MOP_AND</CODE> and
<CODE>OM_MOP_OR</CODE>, which provide facilities for performing boolean AND
and OR operations.
The traditional probabalistic model would consist of a set of terms
joined together with <CODE>OM_MOP_OR</CODE>.
</P>
<P>
The full set of available
<A HREF="apidoc/om_queryop.html"><CODE>om_queryop</CODE></A> operators is:
<TABLE>
<TR><TD VALIGN="top">
OM_MOP_AND 
</TD><TD>
Return a document if and only if both subqueries are satisfied.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_OR 
</TD><TD>
Return a document if either subquery is satisfied.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_AND_NOT 
</TD><TD>
Return a document if left subquery is satisfied and right subquery is not
satisfied.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_XOR 
</TD><TD>
Return a document if one subquery is satisfied, but not both.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_AND_MAYBE 
</TD><TD>
Return a document if and only if the left subquery is satisfied, but calculate
document weights using both queries.
</TD></TR><TR><TD VALIGN="top">
OM_MOP_FILTER 
</TD><TD>
As OM_MOP_AND, but use only weights from left subquery.
</TD></TR>
</TABLE>
</P>

<H3>Undefined queries</H3>
<P>
These are an added complication, although they make it possible to write
much neater code, and to perform some extra types of query. (See
<A HREF="#purebool">"Specifying a pure boolean query"</A>).
</P>

<P>
Undefined queries are not empty queries, or queries which match nothing:
rather, they should be thought of as placeholders.  An undefined query is
created by calling the default constructor for OmQuery(), and can then be
used in many places in construction of a query.
</P>

<H3><A NAME="purebool">Specifying a pure boolean query</A></H3>
<P>
Occasionally it may be desirable to perform a purely boolean query, and not
to calculate weights for each document.  This can be performed within Muscat
as follows:
<UL><LI>
Make the desired query, as described above.
For example, putting it in <CODE>query</CODE>:
example:<PRE>
OmQuery query(OM_MOP_AND_NOT, OmQuery("cheese"), OmQuery("bread"));
</PRE>
</LI><LI>
Make a pure boolean query, by filtering a null query with the boolean query.
For example:
<PRE>
OmQuery boolquery(OM_MOP_FILTER, OmQuery(), query);
</PRE>
</LI></UL>

The boolquery will return a set of documents matching the criteria supplied:
each document in the result set will have a weight of 1.
</P>

<H2>Retrieving the results of a query</H2>

<P>
The OmEnquire class does not require that a method be called in order to
perform the query.  Rather, you simply ask for the results of a query,
and it will perform whatever calculations are neccessary to provide the
answer:
</P>
<PRE>
OmMSet <A HREF="apidoc/OmEnquire.html#get_mset">OmEnquire::get_mset</A>(om_doccount first,
                           om_doccount maxitems,
                           const OmRSet * omrset = 0,
                           const OmMatchOptions * moptions = 0,
                           const OmMatchDecider * mdecider = 0) const 
</PRE>
<P>
When asking for the results, you must specify (in <CODE>first</CODE>) the
first item in the result set to return, where the numbering starts at zero
(so a value of
zero corresponds to the first item returned being that with the highest
score, and a value of 10 corresponds to the first 10 items being ignored,
and the returned items starting at the eleventh).
</P>
<P>
You must also specify (in <CODE>maxitems</CODE>) the the maximum number of
items to return.  Unless there are not enough matching items, precisely
this number of items will be returned.
If <CODE>maxitems</CODE> is zero, no items will be returned, but the usual
statistics (such as the maximum possible weight which a document could be
assigned by the query) will be calculated.  (See &quot;The OmMSet&quot; below).
</P>

<H3>The OmMSet</H3>
<P>
Query results are returned in an
<A HREF="apidoc/OmMSet.html"><CODE>OmMSet</CODE></A> object.  The prime
field in this is <CODE>items</CODE>, which is a list of OmMSet comprising the
selected part of the match results.  This list is in descending sorted order
of relevance (so the most relevant document is first in the list).
Each OmMSet item contains a document id, and the weight calculated for this
document.
</P>
<P>
An OmMSet also contains various information about the search result:
<TABLE>
<TR><TD VALIGN="top">
<CODE>firstitem</CODE>
</TD><TD>
The index of the first item in the result to put
into the mset.  (Corresponding to <CODE>first</CODE> in
<CODE>OmEnquire::get_mset()</CODE>)
</TD></TR><TR><TD VALIGN="top">
<CODE>max_attained</CODE>
</TD><TD>
The greatest weight which is attained in the mset. 
</TD></TR><TR><TD VALIGN="top">
<CODE>max_possible</CODE>
</TD><TD>
The maximum possible weight in the mset. 
</TD></TR><TR><TD VALIGN="top">
<CODE>mbound</CODE>
</TD><TD>
A lower bound on the number of documents in the database which have a weight greater than zero. 
</TD><TR>
</TABLE>
</P>

<H3>Match options</H3>

<P>
There are various additional options 
</P>

<H2>Specifying a relevance set</H2>

<H2>Suggesting new terms for the query</H2>
<P>
</P>

<H2>A simple example</H2>
<P>
A simple example of usage of the Muscat API is given by the msearch
example in the om-examples package.
</P>

<HR>

Last modified: 15 Feb 2000 by Richard Boulton

</BODY>
</HTML>
