<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Muscat: Quickstart</TITLE>
</HEAD>
<BODY BGCOLOR="white">

<H1>Quickstart</H1>

<P>
This document contains sufficient information to enable you to build your
first application using Muscat.  It does not attempt to provide complete
coverage of all the features of Muscat: for that, see the accompanying
user manual and reference document.
</P><P>
The document contains a quick introduction to the basic concepts, and then
a walk-through development of a simple application using the Muscat
library, together with commentary on how the application could be taken
further.
</P>

<HR>
<H2>Requirements</H2>

<P>
Before following the steps outlined in this document, you will need to have
the Muscat library installed on your system.
For instructions on obtaining and installing Muscat, read the
<A HREF="intro.html">Introduction</A> document.
</P>
<P>
You will also need a reasonably recent C++ compiler.  We currently use GCC
version 2.95.2, but any reasonably ANSI compilant C++ compiler should have
a decent chance of successfully compiling the code.
</P>
<P>
In addition, to run the examples, you will need a version of Muscat
compiled with support for the "sleepycat" database access method.  This
requires a copy of the sleepycat database system library to be installed on
your system, and for Muscat to be compiled to use this (by passing the
--enable-backend-sleepy parameter to the configuration script).
</P>
<P>
If you don't have this library available, there is at the time of writing
no database access method which allows you to write databases to permanent
storage.  As a temporary measure, you could use the InMemory database
method, which keeps a database entirely in memory, and either search the
database directly, or write it to a text file and create a DA file from it,
using the makeDA utility (which is binary only, and available only for Linux).
</P>
<P>
Other access methods will be written in due course, and in the meantime
this guide should be useful to you as an overview of how the system works.
</P>

<HR>
<H2>Databases</H2>

<P>
An information retrieval system using Muscat typically has two parts.  The
first part is the <EM>indexer</EM>, which takes documents in various
formats, processes them so that they can be efficiently searched, and
stores the processed documents in an appropriate data structure (the
<EM>database</EM>).  The second part is the <EM>searcher</EM>, which takes
queries and reads the database to return a list of the documents relevant
to each query.
</P>
<P>
The database is the data structure which ties the indexer and searcher
together, and is fundamental to the retrieval process.  Given how
fundamental it is, it is unsurprising that different applications put
different demands on the database.  For example, some applications may be
happy to deal with searching a static collection of data, but need to do
this extremely fast (for example, a web search engine which builds new
databases from scratch nightly or even weekly).  Other applications may
require that new data can be added to the system incrementally, but don't
require extremely high performance searching (perhaps an email system,
which is only being searched occasionally).  There are many other
constraints which may be placed on an information retrieval system: for
example, it may be required to have small database sizes, even at the
expense of getting poorer results from the system.
</P>
<P>
To provide the required flexibility, Muscat has the ability to use one of
many available database <EM>backends</EM>, each of which satisfies a
different set of constraints, stores its data in a different way.

Currently, these must be compiled into the whole system, and selected at
runtime, but the ability to dynamically load modules for each of these
backends is likely to be added in future, and would require little design
modification.
</P>
<P>
If you are in a real hurry, you could probably skip the rest of this
section, but it is helpful to understand roughly what information Muscat
stores in a database and how it is structured, and the following
subsections detail this.
</P>

<H3>The contents of a database</H3>

<P>
FIXME: to be written.
Documents, terms, data, keys.
What can be accessed fast, what can't.
How each piece of data might be stored.
</P>

<H3><A NAME="sleepycat_databases">SleepyCat databases</A></H3>

<P>
FIXME: to be written.
</P>

<H3><A NAME="da_databases">DA databases</A></H3>

<P>
The DA database format is one of the formats which our old software used to
store data.  It is a non-modifyable format; all the data must be known at
the time at which it is created.  It is however a fairly efficient database
format for searching, and is certainly better than the sleepycat database
structure, which is in the early stages of development and is currently
rather inefficient.
</P><P>
On the other hand, it does have various drawbacks, foremost of which is
that of not storing positional information in the posting lists, and thus
some operations (such as phrase searching) will never be possible with
this database format.
</P>
<P>
Another major disadvantage is that document length information is not
stored in this database, so retrieval will not be as good as it could be
with this information.
</P>
<P>
Because the DA format is an old format, we do not provide software to directly
create DA files.  However, you may use the makeDA utility to create these
files, either from text data which you have hand prepared, or from data
unloaded from a sleepycat (or other format) database.
</P>
<P>
You can search a DA database in exactly the same way as you would search a
sleepycat database (see the <A HREF="#searcher">example searcher</A>).
</P>

<HR>
<H2><A NAME="indexer">An example indexer</A></H2>

<P>
The code for this example is in the examples package, in
the &quot;<CODE>simple</CODE>&quot; subdirectory.  An HTML formatted
version is available <A HREF="simpleindex.cc.html">here</A>.
</P>
<P>
The &quot;indexer&quot; presented here is simply a small program which
takes a path to a database and a set of parameters defining a document on
the command line, and stores that document as a new entry in the database.
</P>
<H3>Include header files</H3>
<P>
The first requirement in any program using the Muscat library is to
include the Muscat header file, &quot;<CODE>om.h</CODE>&quot;.
This should be installed in a subdirectory &quot;<CODE>om</CODE>&quot; of
a directory on the include path, so:
<PRE>    #include &lt;om/om.h&gt;</PRE>
</P>
<P>
Our example only has a single function, main(), so next we start that.
<PRE>    int main(int argc, char *argv[])</PRE>
</P>
<H3>Options parsing</H3>
<P>
For this example we do very simple options parsing.  We are going to
use the core functionality of Muscat of searching for specific terms in the
database, and we are not going to use any of the extra facilities, such as
the keys which may be associated with each document.  We are also going to
store a simple string as the data associated with each document.
</P><P>
Thus, our command line syntax is:
<UL><LI>
<B>Parameter 1</B> - the (possibly relative) path to the database.
</LI><LI>
<B>Parameter 2</B> - the string to be stored as the document data.
</LI><LI>
<B>Parameters 3 onward</B> - the terms to be stored in the database.  The
terms will be assumed to occur at successive positions in the document.
</LI></UL>
</P><P>
The validity of a command line can therefore be checked very simply by
ensuring that there are at least 3 parameters:
<PRE>
    if(argc &lt; 4) {
        cout &lt;&lt; "usage: " &lt;&lt; argv[0] &lt;&lt;
	        " &lt;path to database> &lt;document data> &lt;document terms>" &lt;&lt; endl;
        exit(1);
    }
</PRE>
</P>

<H3>Catching exceptions</H3>
<P>
When an error occurs in Muscat it is reported by means of the C++ exception
mechanism.  All errors in Muscat are derived classes of
<CODE>OmError</CODE>, so simple error handling can be performed by
enclosing all the code in a try-catch block to catch any
<CODE>OmError</CODE> exceptions.  A (hopefully) helpful message can be
extracted from the <CODE>OmError</CODE> object by calling its
<CODE>get_msg()</CODE> method, which returns a human readable string.
</P>
<P>
Note that all calls to the Muscat library should be performed inside a
try-catch block, since otherwise errors will result in uncaught exceptions;
this usually results in the execution aborting.
</P>
<P>
Note also that OmError is a virtual base class, and thus can't be copied:
you must therefore catch exceptions by reference, as in the following example
code.
</P>
<PRE>
    try {
        <B>[code which accesses Muscat]</B>
    }
    catch(OmError &amp; error) {
        cout &lt;&lt; "Exception: "  &lt;&lt; error.get_msg() &lt;&lt; endl;
    }
</PRE>

<H3>Opening the database</H3>

<P>
In Muscat, a database is opened for writing by creating an OmWritableDatabase
object.  The constructor for this object takes two arguments.
<OL><LI>
<B>type</B> - this is a string determining the type of the database to open.
The possible values for this depend on which backends are compiled into the
system: if the type is not known an <CODE>OmInvalidArgument</CODE> error will
be thrown.  For this example, we use the &quot;<CODE>sleepycat</CODE>&quot;
database type.
</LI><LI>
<B>parameters</B> - this is a set of parameters to be used to open the
database, stored in an STL vector. The meaning of the parameters is
dependent on the database type: for a sleepycat database there is expected
to be one and only one argument, which is the path (possibly relative to
the current directory) of a directory in which the database files reside.
</LI></OL>
</P>
<P>
If an attempt is made to open a database which doesn't exist, an attempt
to create an empty database in the specified position will be made.
</P>
<P>
If an error occurs when trying to open a database, or to create a new database,
an exception, usually of type <CODE>OmOpeningError</CODE>, will be thrown.
</P>
<P>
The code to open a database for writing is, then:
</P>

<PRE>
    vector&lt;string&gt; parameters;
    parameters.push_back(argv[1]);
    OmWritableDatabase database("sleepycat", parameters);
</PRE>

<H3>Preparing the new document</H3>

<PRE>
    // Make the document
    OmDocumentContents newdocument;

    // Put the data in the document
    newdocument.data = string(argv[2]);

    // Put the terms into the document
    for(int i = 3; i &lt; argc; i++) {
        newdocument.add_posting(argv[i], i - 2);
    }
</PRE>

<H3>Adding the document to the database</H3>

<P>
Finally, we can add the document to the database.  This simply involves
calling <CODE>OmWritableDatabase::add_document()</CODE>, and passing it
the <CODE>OmDocumentContents</CODE> object.
</P>
<P>
The operation of adding a document is atomic: either the document will be
added, or an exception will be thrown and the document will not be in the
new database.
</P>
<P>
<CODE>add_document()</CODE> returns a value of type <CODE>om_docid</CODE>.
This is the document ID of the newly added document, which is simply a
handle which can be used to access the document in future.
</P>

<PRE>
    database.add_document(newdocument);
</PRE>

<HR>
<H2><A NAME="searcher">An example searcher</A></H2>

<P>
The code for this example is also in the examples package, in
the &quot;<CODE>simple</CODE>&quot; subdirectory.  An HTML formatted
version is available <A HREF="simplesearch.cc.html">here</A>.
</P>

<HR>
<H2>Compiling</H2>

<H3>Finding the Muscat library</H3>

<P>
A small utility, &quot;libomus-config&quot;, is installed along with Muscat
to assist you in finding the installed Muscat library, and in generating
the flags to pass to the compiler and linker to compile.  
</P><P>
After a successful compilation, this utility should be in your path, so
you can simply run
<BLOCKQUOTE><CODE>libomus-config --cflags</CODE></BLOCKQUOTE>
to determine the flags to pass to the compiler, and
<BLOCKQUOTE><CODE>libomus-config --libs</CODE></BLOCKQUOTE>
to determine the flags to pass to the linker.

These flags are returned on the utility's standard output (so you could use
backtick notation to include them on your command line).
</P><P>
If your project uses the GNU autoconf tool, you may also use the
<CODE>OM_PATH_LIBOMUS</CODE> macro, which is included as part of Muscat,
and will check for an installation of Muscat and set (and
<CODE>AC_SUBST</CODE>) the <CODE>LIBOMUS_CFLAGS</CODE> and
<CODE>LIBOMUS_LIBS</CODE> variables to
be the flags to pass to the compiler and linker, respectively.
This macro will also allow you to use an uninstalled version of Muscat.
</P><P>
If you don't use GNU autoconf, don't worry about this.
</P>

<H3>Compiling the simple examples</H3>
Once you know the compilation flags, compilation is a simple matter of
invoking the compiler!  For our example, we could compile the two
utilities (simpleindex and simplesearch) by the commands:
<PRE>
c++ simpleindex.cc `libomus-config --libs --cflags` -o simpleindex
<BR>
c++ simplesearch.cc `libomus-config --libs --cflags` -o simplesearch
</PRE>

<HR>
<H2>Running the examples</H2>

<HR>
<H2>Further documentation</H2>

<!-- FOOTER $Author$ $Date$ $Id$ -->
</BODY>
</HTML>
