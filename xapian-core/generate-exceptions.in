#!@PERL@ -w
use strict;
my $copyright = <<'EOF';
/* Copyright (C) 2003,2004,2006,2007 Olly Betts
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
EOF

my $generated_warning =
"/* Warning: This file is generated by $0 - do not modify directly! */\n";

my @baseclasses = ();
my @classes = ();

sub errorbaseclass {
    push @baseclasses, join("\t", @_);
}

sub errorclass {
    push @classes, join("\t", @_);
}

errorbaseclass('LogicError', 'Error', <<'DOC');
/** The base class for exceptions indicating errors in the program logic.
 *
 *  A subclass of LogicError will be thrown if Xapian detects a violation
 *  of a class invariant or a logical precondition or postcondition, etc.
 */
DOC

errorclass('AssertionError', 'LogicError', <<'DOC');
/** AssertionError is thrown if a logical assertion inside Xapian fails.
 *
 *  In a debug build of Xapian, a failed assertion in the core library code
 *  will cause AssertionError to be thrown.
 *
 *  This represents a bug in Xapian (either an invariant, precondition, etc
 *  has been violated, or the assertion is incorrect!)
 */
DOC

errorclass('InvalidArgumentError', 'LogicError', <<'DOC');
/** InvalidArgumentError indicates an invalid parameter value was passed to the API.
*/
DOC

errorclass('InvalidOperationError', 'LogicError', <<'DOC');
/** InvalidOperationError indicates the API was used in an invalid way.
 */
DOC

errorclass('UnimplementedError', 'LogicError', <<'DOC');
/** UnimplementedError indicates an attempt to use an unimplemented feature. */
DOC

# RuntimeError and subclasses:

errorbaseclass('RuntimeError', 'Error', <<'DOC');
/** The base class for exceptions indicating errors only detectable at runtime.
 *
 *  A subclass of RuntimeError will be thrown if Xapian detects an error
 *  which is exception derived from RuntimeError is thrown when an
 *  error is caused by problems with the data or environment rather
 *  than a programming mistake.
 */
DOC

errorclass('DatabaseError', 'RuntimeError', <<'DOC');
/** DatabaseError indicates some sort of database related error. */
DOC

errorclass('DatabaseCorruptError', 'DatabaseError', <<'DOC');
/** DatabaseCorruptError indicates database corruption was detected. */
DOC

errorclass('DatabaseCreateError', 'DatabaseError', <<'DOC');
/** DatabaseCreateError indicates a failure to create a database. */
DOC

errorclass('DatabaseLockError', 'DatabaseError', <<'DOC');
/** DatabaseLockError indicates failure to lock a database. */
DOC

errorclass('DatabaseModifiedError', 'DatabaseError', <<'DOC');
/** DatabaseModifiedError indicates a database was modified.
 *
 *  To recover after catching this error, you need to call
 *  Xapian::Database::reopen() on the Database and repeat the operation
 *  which failed.
 */
DOC

errorclass('DatabaseOpeningError', 'DatabaseError', <<'DOC');
/** DatabaseOpeningError indicates failure to open a database. */
DOC

errorclass('DocNotFoundError', 'RuntimeError', <<'DOC');
/** Indicates an attempt to access a document not present in the database. */
DOC

errorclass('FeatureUnavailableError', 'RuntimeError', <<'DOC');
/** Indicates an attempt to use a feature which is unavailable.
 *
 *  Typically a feature is unavailable because it wasn't compiled in, or
 *  because it requires other software or facilities which aren't available.
 */
DOC

errorclass('InternalError', 'RuntimeError', <<'DOC');
/** InternalError indicates a runtime problem of some sort. */
DOC

errorclass('NetworkError', 'RuntimeError', <<'DOC');
/** Indicates a problem communicating with a remote database. */
DOC

errorclass('NetworkTimeoutError', 'NetworkError', <<'DOC');
/** Indicates a timeout expired while communicating with a remote database. */
DOC

errorclass('QueryParserError', 'RuntimeError', <<'DOC');
/** Indicates a query string can't be parsed. */
DOC

errorclass('RangeError', 'RuntimeError', <<'DOC');
/** RangeError indicates an attempt to access outside the bounds of a container.
 */
DOC

open HDR, ">include/xapian/error.h" or die $!;
open DISPATCH, ">include/xapian/errordispatch.h" or die $!;

print HDR <<'EOF';
/** @file error.h
 *  @brief Hierarchy of classes which Xapian can throw as exceptions.
 */
EOF

print HDR $generated_warning;
print DISPATCH $generated_warning;

print HDR $copyright;
print DISPATCH $copyright;

print HDR <<'EOF';

#ifndef XAPIAN_INCLUDED_ERROR_H
#define XAPIAN_INCLUDED_ERROR_H

#include <string>

namespace Xapian {

class ErrorHandler;

/** All exceptions thrown by Xapian are subclasses of Xapian::Error.
 *
 *  This class can not be instantiated directly - instead a subclass should
 *  be used.
 */
class Error {
    // ErrorHandler needs to be able to access Error::already_handled.
    friend class ErrorHandler;

    /// Message giving details of the error, intended for human consumption.
    std::string msg;

    /** Optional context information.
     *
     *  This context is intended for use by Xapian::ErrorHandler (for example
     *  so it can know which remote server is unreliable and report the problem
     *  and remove that server from those being searched).  But it's typically
     *  a plain-text string, and so also fit for human consumption.
     */
    std::string context;

    /// The type of this error (e.g. DocNotFoundError.)
    const char * type;

    /** Optional value of 'errno' associated with this error.
     *
     *  If no value is associated, this member variable will be 0.
     *
     *  NB We don't just call this member "errno" to avoid problems on
     *  platforms where errno is a preprocessor macro.
     */
    int my_errno;

    /// True if this error has already been passed to an ErrorHandler.
    bool already_handled;

    /// Don't allow assignment of the base class.
    void operator=(const Error &o);

  protected:
    /** @private @internal
     *  @brief Constructor for use by constructors of derived classes.
     */
    Error(const std::string &msg_, const std::string &context_,
	  const char * type_, int errno_)
	: msg(msg_), context(context_), type(type_), my_errno(errno_),
	  already_handled(false) { }

  public:
    /// The type of this error (e.g. "DocNotFoundError".)
    std::string get_type() const { return std::string(type); }

    /// Message giving details of the error, intended for human consumption.
    const std::string & get_msg() const { return msg; }

    /** Optional context information.
     *
     *  This context is intended for use by Xapian::ErrorHandler (for example
     *  so it can know which remote server is unreliable and report the problem
     *  and remove that server from those being searched).  But it's typically
     *  a plain-text string, and so also fit for human consumption.
     */
    const std::string & get_context() const { return context; }

    /** Optional value of 'errno' associated with this error.
     *
     *  If no 'errno' value is associated, returns 0.
     */
    int get_errno() const { return my_errno; }
};

/* This hook is needed to allow SWIG generated-bindings to use GCC's
 * visibility support.  This can go away once we add GCC visibility support
 * to the main library.
 */
#if defined(SWIGEXPORT) && defined(__GNUC__) && (__GNUC__ >= 4)
# define XAPIAN_EXCEPTION_EXPORT SWIGEXPORT
#else
# define XAPIAN_EXCEPTION_EXPORT
#endif
EOF

print DISPATCH <<'EOF';

/* Note that this file isn't an external header - it's located in
 * include/xapian in the source tree because it's generated so this
 * is the simplest way to make inclusion work in a VPATH build.
 */

// DOXYGEN gets confused by this header-with-code.
#ifndef DOXYGEN
EOF

for (@baseclasses) {
    my ($class, $parent, $comment) = split /\t/, $_, 3;
    print HDR <<EOF;

${comment}class XAPIAN_EXCEPTION_EXPORT $class : public $parent {
  protected:
    /** \@Internal Constructor for use by constructors of derived classes. */
    $class(const std::string \&msg_, const std::string \&context_, const char * type_, int errno_)
	: $parent(msg_, context_, type_, errno_) {}
};
EOF
}

for (@classes) {
    my ($class, $parent, $comment) = split /\t/, $_, 3;

    print DISPATCH "if (type == \"$class\") throw Xapian::$class(msg, context);\n";

    print HDR <<EOF;

${comment}class XAPIAN_EXCEPTION_EXPORT $class : public $parent {
  public:
    /** General purpose constructor. */
    $class(const std::string \&msg_, const std::string \&context_ = "", int errno_ = 0)
	: $parent(msg_, context_, "$class", errno_) {}
    /** Construct from message and errno value. */
    $class(const std::string \&msg_, int errno_)
	: $parent(msg_, "", "$class", errno_) {}
  protected:
    /** \@Internal Constructor for use by constructors of derived classes. */
    $class(const std::string \&msg_, const std::string \&context_, const char * type_, int errno_)
	: $parent(msg_, context_, type_, errno_) {}
};
EOF
}

print HDR <<'EOF';

}

#endif /* XAPIAN_INCLUDED_ERROR_H */
EOF

print DISPATCH <<'EOF';
#endif /* DOXYGEN */
EOF

close HDR or die $!;
close DISPATCH or die $!;
