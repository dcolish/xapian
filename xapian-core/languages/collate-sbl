#!/usr/bin/perl
use strict;
use warnings;
my $copyright = <<'EOF';
/* Copyright (C) 2007,2012,2013 Olly Betts
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
EOF

open HDR, ">languages/sbl-dispatch.h" or die $!;

print HDR <<"EOF";
/** \@file sbl-dispatch.h
 *  \@brief Map string to object
 */
/* Warning: This file is generated by $0 - do not modify directly! */
$copyright
#ifndef XAPIAN_INCLUDED_SBL_DISPATCH_H
#define XAPIAN_INCLUDED_SBL_DISPATCH_H

EOF

my $srcdir = shift @ARGV;

add_token('none', 'NONE');
foreach (sort @ARGV) {
    m{.*/(.*)\.sbl$} or die "Failed to parse snowball source: $_\n";
    my $enum = uc $1;
    add_token($1, $enum);
    open SBL, '<', "$srcdir/$_" or die "Open $srcdir/$_ failed: $!\n";
    my $l = <SBL>;
    close SBL;
    $l =~ s/^\W*Alias:\s*//i or die "No Alias: header in $srcdir/$_\n";
    $l =~ s/\s*$//;
    for (split /\s+/, $l) {
	add_token($_, $enum);
    }
}

write_header(\*HDR, 'sbl_code');

print HDR <<'EOF';

#endif
EOF

close HDR or die $!;

my %m;
my %enum_values;
sub add_token {
    my ($t, $enum) = @_;
    !exists ${$m{length $t}}{$t} or die "Token $t already seen";
    ${$m{length $t}}{$t} = $enum;
    if (!exists $enum_values{$enum}) {
	$enum_values{$enum} = scalar keys %enum_values;
    }
    return;
}

sub write_header {
    my ($hdr, $type) = @_;
    print $hdr "enum $type {\n";
    print $hdr join ",\n", map { "    $_ = $enum_values{$_}" } sort {$enum_values{$a} <=> $enum_values{$b}} keys %enum_values;
    print $hdr "\n};\n";

    my $max = 255;
    if (scalar keys %enum_values > $max + 1) {
	die "Token value ", (scalar keys %enum_values) - 1, " > $max";
    }
    my @lens = sort {$a <=> $b} keys %m;
    my $max_len = $lens[-1];
    # 1 means "no entries" since it can't be a valid offset.
    my @h = (1) x $max_len;
    my @r = ();
    my $offset = 0;
    for my $len (@lens) {
	push @r, undef;
	$offset == 1 and die "Offset $offset == 1";
	$offset > $max and die "Offset $offset > $max";
	$h[$len - 1] = $offset;
	my $href = $m{$len};
	my $tab_len = scalar(keys %$href);
	$tab_len - 1 < 0 and die "Offset $tab_len < 0";
	$tab_len - 1 > $max and die "Offset $tab_len > $max";
	push @r, "($tab_len - 1),";
	++$offset;
	for my $s (sort keys %$href) {
	    $offset += 1 + length($s);
	    my $v = $$href{$s};
	    push @r, "$v, " . join(",", map { my $o = ord $_; $o >= 32 && $o < 127 ? "'$_'" : $o } split //, $s) . ",";
	}
    }
    print $hdr "\nstatic const unsigned char tab[] = {\n";
    print $hdr "    $max_len,\n";
    my $c = 0;
    for (@h) {
	if ($c++ % 8 == 0) {
	    print $hdr "\n    ";
	} else {
	    print $hdr " ";
	}
	printf $hdr "%3d,", $_;
    }
    print $hdr "\n";

    $r[-1] =~ s/,$//;

    for (@r) {
	if (defined $_) {
	    print $hdr "    ", $_;
	}
	print $hdr "\n";
    }

    print $hdr "};\n";
    return;
}
