%include {
/* queryparser.lemony: build a Xapian::Query object from a user query string.
 *
 * Copyright (C) 2004,2005,2006,2007 Olly Betts
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
 * USA
 */

#include <config.h>

#include "omassert.h"
#include "queryparser_internal.h"
#include <xapian/unicode.h>
#include "utils.h"

// Include the list of token values lemon generates.
#include "queryparser_token.h"

#include <algorithm>
#include <list>
#include <string>

using namespace std;

using namespace Xapian;

inline bool
U_isupper(unsigned ch) {
    return (ch < 128 && C_isupper((unsigned char)ch));
}

inline bool
U_isdigit(unsigned ch) {
    return (ch < 128 && C_isdigit((unsigned char)ch));
}

inline bool
U_isalpha(unsigned ch) {
    return (ch < 128 && C_isalpha((unsigned char)ch));
}

inline bool
U_isspace(unsigned ch) {
    return (ch < 128 && C_isspace((unsigned char)ch));
}

inline bool
U_isnotspace(unsigned ch) {
    return !U_isspace(ch);
}

inline bool
is_termchar(unsigned ch) {
    return Unicode::is_wordchar(ch) || ch == '_';
}

inline bool
is_not_termchar(unsigned ch) {
    return !is_termchar(ch);
}

// FIXME: we used to keep trailing "-" (e.g. Cl-) but it's of dubious utility
// and there's the risk of hyphens getting stuck onto the end of terms...
inline bool
is_suffix(unsigned ch) {
    return ch == '+' || ch == '#';
}

inline bool
prefix_needs_colon(const string & prefix, unsigned ch)
{
    if (!U_isupper(ch)) return false;
    string::size_type len = prefix.length();
    return (len > 1 && prefix[len - 1] != ':');
}

using Unicode::is_currency;

/// Wrapper around a query, allowing us to distinguish between a query
/// representing an empty list of queries, and a "MatchNothing" query.
/* FIXME: can we replace this by using Query * and NULL vs MatchNothing?
 * We pass round Query * generally, so that should dovetail quite nicely!
 */
class QpQuery {
    /// The underlying query object.
    Query q;

    /// Flag, true iff this represents a "MatchNothing" query.
    bool match_nothing;

  public:
    QpQuery(const QpQuery & tocopy)
	: q(tocopy.q), match_nothing(tocopy.match_nothing)
    {}

    QpQuery & operator=(const QpQuery & tocopy)
    {
	q = tocopy.q;
	match_nothing = tocopy.match_nothing;
	return *this;
    }

    /** A query consisting of a single term. */
    QpQuery(const std::string & tname, Xapian::termcount wqf,
	    Xapian::termpos pos)
	: q(tname, wqf, pos), match_nothing(false)
    {}

    /** A query consisting of two subqueries, combined with operator op. */
    QpQuery(Query::op op, const QpQuery & left, const QpQuery & right)
	: q(op, left.get(), right.get()), match_nothing(false)
    {}

    QpQuery(Query::op op_, Xapian::valueno valno,
	  const std::string &begin, const std::string &end)
	: q(op_, valno, begin, end), match_nothing(false)
    {}

    QpQuery(const Query & q_) : q(q_), match_nothing(false) {}
    QpQuery() : q(), match_nothing(false) {}
    QpQuery(bool m) : q(), match_nothing(m) {}
    Query & get() { return q; }
    const Query & get() const { return q; }

    /// True iff the query is not empty, and doesn't explicitly match nothing.
    bool can_match() { return (!q.empty() && !match_nothing); }
    // FIXME:
    // If matching nothing is true, q.empty() must be true too
    // (from looking at the constructors).
    // The can_match() condition above is:
    //	    (!q.empty() && !match_nothing)
    // <=>  !(q.empty() || match_nothing)
    // <=>  !(q.empty() || match_nothing)
    // <=>  !(q.empty()

    /// True iff the query is defined, but empty.
    bool empty() { return !match_nothing && q.empty(); }

#if 0
    /// Get a description of the query
    std::string get_description() {
	if (match_nothing) {
	    return "[MATCH_NOTHING]";
	} else {
	    return q.get_description();
	}
    }
#endif
};

/** Class used to pass information about a token from lexer to parser.
 *
 *  Generally a this class carries term information, but it can be used for the
 *  start or end of a value range, with some operators (e.g. the distance
 *  in NEAR/3 or ADJ/3, etc).
 */
class Term {
    // So State can read our name.
    friend class ::State;
    State * state;

    string name;
    string prefix;
    string unstemmed;
    bool stem;
    termpos pos;

    std::string make_term() const;

  public:
    Term(const string &name_, termpos pos_) : name(name_), stem(false), pos(pos_) { }
    Term(const string &name_) : name(name_), stem(false), pos(0) { }
    Term(termpos pos_) : stem(false), pos(pos_) { }
    Term(State * state_, const string &name_, const string &prefix_,
	 const string &unstemmed_, bool stem_, termpos pos_)
	: state(state_), name(name_), prefix(prefix_), unstemmed(unstemmed_),
	  stem(stem_), pos(pos_) { }

    void dont_stem() { stem = false; }

    termpos get_termpos() const { return pos; }

    QpQuery * as_query() const { return new QpQuery(make_term(), 1, pos); }

    QpQuery * as_wildcarded_query(State * state) const;

    QpQuery as_query_object() const { return QpQuery(make_term(), 1, pos); }
};

/// Parser State shared between the lexer and the parser.
class State {
  private:
    QueryParser::Internal * qpi;

  public:
    QpQuery query;
    const char * error;
    unsigned flags;

    State(QueryParser::Internal * qpi_, unsigned flags_)
	: qpi(qpi_), error(NULL), flags(flags_) { }

    string stem_term(const string &term) {
	return qpi->stemmer(term);
    }

    void add_to_stoplist(const Term * term) {
	qpi->stoplist.push_back(term->name);
    }

    void add_to_unstem(const string & term, const string & unstemmed) {
	qpi->unstem.insert(make_pair(term, unstemmed));
    }

    QpQuery * value_range(Term *a, Term *b) {
	string start = a->name;
	string end = b->name;
	delete a;
	delete b;
	Xapian::valueno valno = Xapian::BAD_VALUENO;
	list<ValueRangeProcessor *>::const_iterator i;
	for (i = qpi->valrangeprocs.begin(); i != qpi->valrangeprocs.end(); ++i) {
	    valno = (**i)(start, end);
	    if (valno != Xapian::BAD_VALUENO) break;
	}
	if (valno == Xapian::BAD_VALUENO) {
	    // FIXME: Do we want to report an error for this?  If not we need
	    // to perform the above check in the tokeniser and if none of the
	    // ValueRangeProcessor classes like the range, we rollback to
	    // parsing the query without treating this as a range.  Needs
	    // more thought and probably a look at queries users actually
	    // enter.
	    error = "Unknown range operation";
	    return NULL;
	}
	return new QpQuery(Query::OP_VALUE_RANGE, valno, start, end);
    }

    Query::op default_op() const { return qpi->default_op; }

    bool is_stopword(const Term *term) const {
	return qpi->stopper && (*qpi->stopper)(term->name);
    }

    Database get_database() {
	return qpi->db;
    }
};

string
Term::make_term() const
{
    string term;
    if (stem) term += 'Z';
    if (!prefix.empty()) {
	term += prefix;
	if (prefix_needs_colon(prefix, name[0])) term += ':';
    }
    if (stem) {
	term += state->stem_term(name);
    } else {
	term += name;
    }

    if (!unstemmed.empty())
	state->add_to_unstem(term, unstemmed);
    return term;
}

static void
add_to_query(QpQuery & q, Query::op op, const QpQuery &term)
{
    if (q.empty()) {
	q = term;
    } else {
	q = QpQuery(op, q, term);
    }
}

QpQuery *
Term::as_wildcarded_query(State * state_) const
{
    Database db = state_->get_database();
    TermIterator t = db.allterms_begin();
    t.skip_to(name);
    QpQuery q;
    while (t != db.allterms_end() && (*t).substr(0, name.size()) == name) {
	add_to_query(q, Query::OP_OR, QpQuery(*t, 1, pos));
	++t;
    }
    if (q.get().empty()) {
	return new QpQuery(true);
    } else {
	return new QpQuery(q);
    }
}

inline bool
is_phrase_generator(unsigned ch)
{
    // These characters generate a phrase search.
    // Ordered mostly by frequency of calls to this function done when
    // running queryparsertest.
    return (ch && ch < 128 && strchr(".-/:\\@", ch) != NULL);
}

inline bool
is_stem_preventer(unsigned ch)
{
    return (ch && ch < 128 && strchr("(/\\@<>=*[{\"", ch) != NULL);
}

inline bool
should_stem(const std::string & term)
{
    const unsigned int SHOULD_STEM_MASK =
	(1 << Unicode::LOWERCASE_LETTER) |
	(1 << Unicode::TITLECASE_LETTER) |
	(1 << Unicode::MODIFIER_LETTER) |
	(1 << Unicode::OTHER_LETTER);
    Utf8Iterator u(term);
    return ((SHOULD_STEM_MASK >> Unicode::get_category(*u)) & 1);
}

struct yyParser;

// Prototype the functions lemon generates.
static yyParser *ParseAlloc();
static void ParseFree(yyParser *);
static void Parse(yyParser *, int, Term *, State *);

Query
QueryParser::Internal::parse_query(const string &qs, unsigned flags, const string &default_prefix)
{
    yyParser * pParser = ParseAlloc();

    // Set value_ranges if we may have to handle value ranges in the query.
    bool value_ranges;
    value_ranges = !valrangeprocs.empty() && (qs.find("..") != string::npos);

    termpos term_pos = 1;
    Utf8Iterator it(qs), end;

    State state(this, flags);

    list<string> prefix_stack;
    // We always have the current prefix on the top of the stack.
    prefix_stack.push_back(default_prefix);

    enum {
	DEFAULT, IN_QUOTES, IN_PREFIXED_QUOTES, IN_PHRASED_TERM
    } mode = DEFAULT;

    unsigned newprev = ' ';
main_lex_loop:
    while (it != end) {
	if (mode == IN_PHRASED_TERM) mode = DEFAULT;
	if (U_isspace(*it)) {
	    newprev = ' ';
	    ++it;
	    it = find_if(it, end, U_isnotspace);
	    if (it == end) break;
	}

	if (mode == DEFAULT && value_ranges) {
	    // Scan forward to see if this could be the "start of range"
	    // token.  Sadly this has O(n^2) tendencies, though at least
	    // "n" is the number of words in a query which is likely to
	    // remain fairly small.  FIXME: can we tokenise more elegantly?
	    Utf8Iterator p = it;
	    unsigned ch = 0;
	    while (p != end) {
		if (ch == '.' && *p == '.') {
		    ++p;
		    if (p == end || *p <= ' ' || *p == ')') break;

		    string r;
		    do {
			Unicode::append_utf8(r, *it++);
		    } while (it != p);
		    // Trim off the trailing "..".
		    r.resize(r.size() - 2);
		    Parse(pParser, RANGE_START, new Term(r), &state);
		    r.resize(0);
		    // Allow any character except whitespace and ')' in a
		    // RANGE_END.  Or should we be consistent with RANGE_START?
		    do {
			Unicode::append_utf8(r, *p++);
		    } while (p != end && *p > ' ' && *p != ')');
		    Parse(pParser, RANGE_END, new Term(r), &state);
		    it = p;
		    goto main_lex_loop;
		}
		ch = *p;
		if (!(is_termchar(ch) || is_currency(ch) ||
		      (ch < 128 && strchr("%,-./:@", ch)))) break;
		++p;
	    }
	}

	if (!is_termchar(*it)) {
	    unsigned prev = newprev;
	    unsigned ch = *it++;
	    if (it != end) newprev = *it;
	    switch (ch) {
	      case '"':
		// Skip whitespace.
		it = find_if(it, end, U_isnotspace);
		if (mode == DEFAULT) {
		    if (it == end) {
			// Ignore an unmatched " at the end of the query to
			// avoid generating an empty pair of QUOTEs which will
			// cause a parse error.
			goto done;
		    }
		    if (*it == '"') {
			// Ignore empty "" (but only if we're not already
			// IN_QUOTES as we don't merge two adjacent quoted
			// phrases!)
			newprev = *it++;
			break;
		    }
		}
		if (flags & QueryParser::FLAG_PHRASE) {
		    Parse(pParser, QUOTE, NULL, &state);
		    if (mode == DEFAULT) {
			mode = IN_QUOTES;
		    } else {
			// Remove the prefix we pushed for this phrase.
			if (mode == IN_PREFIXED_QUOTES)
			    prefix_stack.pop_back();
			mode = DEFAULT;
		    }
		}
		break;

	      case '+': case '-':
		// Ignore + or - at end of query.
		if (it == end) goto done;
		if (prev > ' ' && prev != '(') {
		    // Or if not after whitespace or an open bracket.
		    break;
		}
		if (U_isspace(*it) || *it == '+' || *it == '-') {
		    // Ignore + or - followed by a space, or further + or -.
		    // Postfix + (such as in C++ and H+) is handled as part of
		    // the term lexing code below.
		    newprev = *it++;
		    break;
		}
		if (mode == DEFAULT && (flags & FLAG_LOVEHATE))
		    Parse(pParser, (ch == '+' ? LOVE : HATE), NULL, &state);
		break;

	      case '(':
		// Skip whitespace.
		it = find_if(it, end, U_isnotspace);
		// Ignore ( at end of query.
		if (it == end) goto done;
		if (prev > ' ' && prev != '(' && prev != ')') {
		    // Or if not after whitespace or a bracket.
		    break;
		}
		if (*it == ')') {
		    // Ignore empty ().
		    newprev = *it++;
		    break;
		}
		if (mode == DEFAULT && (flags & FLAG_BOOLEAN)) {
		    prefix_stack.push_back(prefix_stack.back());
		    Parse(pParser, BRA, NULL, &state);
		}
		break;

	      case ')':
		if (term_pos == 1) {
		    // Ignore ) at start of query.
		    break;
		}
		if (mode == DEFAULT && (flags & FLAG_BOOLEAN)) {
		    // Remove the prefix we pushed for the corresponding BRA.
		    // If brackets are unmatched, it's a syntax error, but
		    // that's no excuse to SEGV!
		    if (prefix_stack.size() > 1) prefix_stack.pop_back();
		    Parse(pParser, KET, NULL, &state);
		}
		break;
	    }
	    // Skip any other characters.
	    continue;
	}

	newprev = 'A'; // Any letter will do...

	// A term, a prefix, or a boolean operator.
	string prefix;
	if (mode == DEFAULT && !prefixes.empty()) {
	    // Check for fieldname prefixes (e.g. title:historical).
	    Utf8Iterator p = find_if(it, end, is_not_termchar);
	    if (p != end && *p == ':' && ++p != end && *p > ' ' && *p != ')') {
		string field;
		p = it;
		while (*p != ':')
		    Unicode::append_utf8(field, *p++);
		map<string, PrefixInfo>::const_iterator f;
		f = prefixes.find(field);
		if (f != prefixes.end()) {
		    // Special handling for prefixed fields, depending on the
		    // type of the prefix.
		    unsigned ch = *++p;
		    PrefixInfo::prefix_type type = f->second.type;
		    prefix = f->second.str;

		    if (type == PrefixInfo::BOOL_FILTER) {
			// Can't boolean prefix a subexpression or phrase;
			// just use anything following the boolean prefix
			// until the next space or ')' as part of the boolean
			// term.
			it = p;
			if (prefix_needs_colon(prefix, *it))
			    prefix += ':';
			string term;
			while (it != end && *it > ' ' && *it != ')')
			    Unicode::append_utf8(term, *it++);
			prefix += term;
			field += ':';
			field += term;
			unstem.insert(make_pair(prefix, field));
			Parse(pParser, BOOLEAN_FILTER, new Term(prefix),
			      &state);
			continue;
		    }

		    Assert(type == PrefixInfo::FREE_TEXT);

		    if (ch == '"' && (flags & FLAG_PHRASE)) {
			// Prefixed phrase, e.g.: subject:"space flight"
			mode = IN_PREFIXED_QUOTES;
			Parse(pParser, QUOTE, NULL, &state);
			it = p;
			newprev = ch;
			++it;
			prefix_stack.push_back(prefix);
			continue;
		    }

		    if (ch == '(' && (flags & FLAG_BOOLEAN)) {
			// Prefixed subexpression, e.g.: title:(fast NEAR food)
			Parse(pParser, BRA, NULL, &state);
			it = p;
			newprev = ch;
			++it;
			prefix_stack.push_back(prefix);
			continue;
		    }

		    if (is_termchar(ch)) {
			// Prefixed term.
			it = p;
		    } else {
			// It looks like a prefix but isn't, so parse it as
			// text instead.
			prefix.resize(0);
		    }
		}
	    }
	}

phrased_term:
	string term;
	// Look for initials separated by '.' (e.g. P.T.O., U.N.C.L.E).
	// Don't worry if there's a trailing '.' or not.
	if (U_isupper(*it)) {
	    string t;
	    Utf8Iterator p = it;
	    do {
		Unicode::append_utf8(t, *p++);
	    } while (p != end && *p == '.' && ++p != end && U_isupper(*p));
	    // One letter does not make an acronym!  If we handled a single
	    // uppercase letter here, we wouldn't catch M&S below.
	    if (t.length() > 1) {
		// Check there's not a (lower case) letter or digit
		// immediately after it.
		// FIXME: should I.B.M..P.T.O be a range search?
		if (p == end || !is_termchar(*p)) {
		    it = p;
		    swap(term, t);
		}
	    }
	}
	bool was_acronym = !term.empty();

	if (term.empty()) {
	    while (it != end) {
		unsigned ch = *it;
		if (!is_termchar(ch)) {
		    // Treat a single embedded '&' or "'" as a word character
		    // (e.g. AT&T, Fred's).
		    if (ch != '&' && ch != '\'') break;
		    Utf8Iterator p = it;
		    ++p;
		    if (p == end || !is_termchar(*p)) break;
		}
		Unicode::append_utf8(term, ch);
		++it;
	    }
	    if (it != end && is_suffix(*it)) {
		string suff_term = term;
		Utf8Iterator p = it;
		// Keep trailing + (e.g. C++, Na+) or # (e.g. C#).
		do {
		    if (suff_term.size() - term.size() == 3) {
			suff_term.resize(0);
			break;
		    }
		    suff_term += *p;
		} while (is_suffix(*++p));
		if (!suff_term.empty() && (p == end || !is_termchar(*p))) {
		    // If the suffixed term doesn't exist, check that the
		    // non-suffixed term does.  This also takes care of
		    // the case when QueryParser::set_database() hasn't
		    // been called.
		    bool use_suff_term = false;
		    string lc = Unicode::tolower(suff_term);
		    if (db.term_exists(lc)) {
			use_suff_term = true;
		    } else {
			lc = Unicode::tolower(term);
			if (!db.term_exists(lc)) use_suff_term = true;
		    }
		    if (use_suff_term) {
			term = suff_term;
			it = p;
		    }
		}
	    }
	}

	// Boolean operators.
	if (mode == DEFAULT && (flags & FLAG_BOOLEAN) &&
	    // Don't want to interpret A.N.D. as an AND operator.
	    !was_acronym &&
	    prefix.empty() &&
	    term.size() >= 2 && term.size() <= 4 && U_isalpha(term[0])) {

	    string op = term;
	    if (flags & FLAG_BOOLEAN_ANY_CASE) {
		for (string::iterator i = op.begin(); i != op.end(); ++i) {
		    *i = C_toupper(*i);
		}
	    }
	    if (op.size() == 3) {
		if (op == "AND") {
		    Parse(pParser, AND, NULL, &state);
		    continue;
		} else if (op == "NOT") {
		    Parse(pParser, NOT, NULL, &state);
		    continue;
		} else if (op == "XOR") {
		    Parse(pParser, XOR, NULL, &state);
		    continue;
		} else if (op == "ADJ") {
		    if (it != end && *it == '/') {
			size_t width = 0;
			Utf8Iterator p = it;
			while (++p != end && U_isdigit(*p)) {
			    width = (width * 10) + (*p - '0');
			}
			if (width && (p == end || U_isspace(*p))) {
			    it = p;
			    Parse(pParser, ADJ, new Term(width), &state);
			    continue;
			}
		    }

		    Parse(pParser, ADJ, NULL, &state);
		    continue;
		}
	    } else if (op.size() == 2) {
		if (op == "OR") {
		    Parse(pParser, OR, NULL, &state);
		    continue;
		}
	    } else if (op.size() == 4) {
		if (op == "NEAR") {
		    if (it != end && *it == '/') {
			size_t width = 0;
			Utf8Iterator p = it;
			while (++p != end && U_isdigit(*p)) {
			    width = (width * 10) + (*p - '0');
			}
			if (width && (p == end || U_isspace(*p))) {
			    it = p;
			    Parse(pParser, NEAR, new Term(width), &state);
			    continue;
			}
		    }

		    Parse(pParser, NEAR, NULL, &state);
		    continue;
		}
	    }
	}

	if (prefix.empty()) prefix = prefix_stack.back();

	{
	    string unstemmed_term(term);
	    term = Unicode::tolower(term);
	    // Don't stem if:
	    // * We're not stemming terms at all!
	    // * We're not stemming all terms and "should_stem()" returns false.
	    // * If the term is followed by a stem preventer character.
	    bool dont_stem =
		stem_action == STEM_NONE ||
		(stem_action == STEM_SOME && !should_stem(unstemmed_term)) ||
		(it != end && is_stem_preventer(*it));

	    Term * term_obj = new Term(&state, term, prefix, unstemmed_term, !dont_stem, term_pos++);
	    if (mode == IN_PHRASED_TERM) {
		Parse(pParser, PHR_TERM, term_obj, &state);
	    } else {
		if (mode == DEFAULT) {
		    if (it != end) {
			if (flags & FLAG_WILDCARD && *it == '*') {
			    Utf8Iterator p(it);
			    ++p;
			    if (p == end || !is_termchar(*p)) {
				it = p;
				// Wildcard at end of term (also known as
				// "right truncation").
				Parse(pParser, WILD_TERM, term_obj, &state);
				continue;
			    }
			}
		    } else {
			if (flags & FLAG_PARTIAL) {
			    // Final term of a partial match query, with no
			    // following characters - treat as a wildcard.
			    Parse(pParser, WILD_TERM, term_obj, &state);
			    continue;
			}
		    }
		}

		Parse(pParser, TERM, term_obj, &state);
		if (mode != DEFAULT) continue;
	    }
	}

	if (it != end && is_phrase_generator(*it)) {
	    // Skip multiple phrase generators.
	    do {
		++it;
	    } while (it != end && is_phrase_generator(*it));
	    // Don't generate a phrase unless the phrase generators are
	    // immediately followed by another term.
	    if (it != end && is_termchar(*it)) {
		mode = IN_PHRASED_TERM;
		goto phrased_term;
	    }
	}
    }
done:
    // Implicitly close any unclosed quotes...
    if (mode == IN_QUOTES || mode == IN_PREFIXED_QUOTES)
	Parse(pParser, QUOTE, NULL, &state);
    Parse(pParser, 0, NULL, &state);
    ParseFree(pParser);

    errmsg = state.error;
    return state.query.get();
}

struct ProbQuery {
    QpQuery query;
    QpQuery love;
    QpQuery hate;
    QpQuery filter;
};

class TermList {
    list<Query> terms;
    size_t window;

  public:
    TermList() : window(0) { }

    /// Add a Term object to this TermList object.
    void add_term(Term * term) {
	terms.push_back(term->as_query_object().get());
	delete term;
    }

    /// Add an unstemmed Term object to this TermList object.
    void add_unstemmed_term(Term * term) {
	term->dont_stem();
	add_term(term);
    }

    void adjust_window(size_t alternative_window) {
	if (alternative_window > window) window = alternative_window;
    }

    /// Convert to a Xapian::Query * using adjacent OP_PHRASE.
    QpQuery * as_phrase_query() const {
	QpQuery * term;
	term = new QpQuery(Query(Query::OP_PHRASE, terms.begin(), terms.end(),
				 terms.size()));
	delete this;
	return term;
    }

    /// Convert to a Xapian::Query * using OP_NEAR.
    QpQuery * as_near_query() const {
	QpQuery * term;
	// The common meaning of 'a NEAR b' is "a within 10 terms of b", which
	// means a window size of 11.  For more than 2 terms, we just add one
	// to the window size for each extra term.
	size_t w = window;
	if (w == 0) w = 10;
	term = new QpQuery(Query(Query::OP_NEAR, terms.begin(), terms.end(),
				 terms.size() + w - 1));
	delete this;
	return term;
    }

    /// Convert to a Xapian::Query * using OP_PHRASE to implement ADJ.
    QpQuery * as_adj_query() const {
	QpQuery * term;
	// The common meaning of 'a ADJ b' is "a at most 10 terms before b",
	// which means a window size of 11.  For more than 2 terms, we just add
	// one to the window size for each extra term.
	size_t w = window;
	if (w == 0) w = 10;
	term = new QpQuery(Query(Query::OP_PHRASE, terms.begin(), terms.end(),
				 terms.size() + w - 1));
	delete this;
	return term;
    }

    /** Provide a way to explicitly delete an object of this class.  The
     *  destructor is protected to prevent auto-variables of this type.
     */
    void destroy() { delete this; }

  protected:
    /** Protected destructor, so an auto-variable of this type is a
     *  compile-time error - you must allocate this object with new.
     */
    ~TermList() { }
};

// Helper macro for converting a boolean operation into a Xapian::Query.
#define BOOL_OP_TO_QPQUERY(E, A, OP, B, OP_TXT) \
    do {\
	if (!A || !B) {\
	    state->error = "Syntax: <expression> "OP_TXT" <expression>";\
	    yy_parse_failed(yypParser);\
	    return;\
	}\
	E = new QpQuery(OP, *A, *B);\
	delete A;\
	delete B;\
    } while (0)

}

%token_type {Term *}
%token_destructor {delete $$;}

%extra_argument {State * state}

%parse_failure {
    // If we've not already set an error message, set a default one.
    if (!state->error) state->error = "parse error";
}

// Operators, grouped in order of increasing precedence:
%nonassoc ERROR.
%left NOT OR XOR.
%left AND.
%left NEAR ADJ.
%left LOVE HATE.

// Destructors for terminal symbols:

// TERM is a query term, including prefix (if any).
%destructor TERM {delete $$;}

// PHR_TERM is a query term which follows a TERM or another PHR_TERM and is
// separated only by one or more phrase generator characters (hyphen and
// apostrophe are common examples - see is_phrase_generator() for the list
// of all punctuation which does this).
%destructor PHR_TERM {delete $$;}

// WILD_TERM is like a TERM, but has a trailing wildcard which need to be
// expanded.
%destructor WILD_TERM {delete $$;}

// BOOLEAN_FILTER is a query term with a prefix registered using
// add_bool_prefix().  It's added to the query using a FILTER operator,
// e.g. site:xapian.org (or using AND_NOT if it's negated).
%destructor BOOLEAN_FILTER {delete $$;}

// Grammar rules:

// query - The whole query - just an expr or nothing.

// query non-terminal doesn't need a type, so just give a dummy one.
%type query {int}

query ::= expr(E). {
    // Save the parsed query in the State structure so we can return it.
    state->query = *E;
    delete E;
}

query ::= . {
    // Handle a query string with no terms in.
    state->query = QpQuery();
}

// expr - A query expression.

%type expr {QpQuery *}
%destructor expr {delete $$;}

expr(E) ::= prob_expr(P).
	{ E = P; }

expr(E) ::= bool_arg(A) AND bool_arg(B).
	{ BOOL_OP_TO_QPQUERY(E, A, Query::OP_AND, B, "AND"); }

expr(E) ::= bool_arg(A) NOT bool_arg(B). {
    // 'NOT foo' -> '<alldocuments> NOT foo'
    if (!A && (state->flags & QueryParser::FLAG_PURE_NOT)) {
	A = new QpQuery("", 1, 0);
    }
    BOOL_OP_TO_QPQUERY(E, A, Query::OP_AND_NOT, B, "NOT");
}

expr(E) ::= bool_arg(A) AND NOT bool_arg(B). [NOT]
	{ BOOL_OP_TO_QPQUERY(E, A, Query::OP_AND_NOT, B, "AND NOT"); }

expr(E) ::= bool_arg(A) OR bool_arg(B).
	{ BOOL_OP_TO_QPQUERY(E, A, Query::OP_OR, B, "OR"); }

expr(E) ::= bool_arg(A) XOR bool_arg(B).
	{ BOOL_OP_TO_QPQUERY(E, A, Query::OP_XOR, B, "XOR"); }

// bool_arg - an argument to a boolean operator such as AND or OR.

%type bool_arg {QpQuery *}
%destructor bool_arg {delete $$;}

bool_arg(A) ::= expr(E). { A = E; }

bool_arg(A) ::= . [ERROR] {
    // Set the argument to NULL, which enables the bool_arg-using rules in
    // expr above to report uses of AND, OR, etc which don't have two
    // arguments.
    A = NULL;
}

// prob_expr - a single compound term, or a prob.

%type prob_expr {QpQuery *}
%destructor prob_expr {delete $$;}

prob_expr(E) ::= prob(P). {
    E = new QpQuery(P->query);
    // Handle any "+ terms".
    if (!P->love.empty()) {
	if (E->empty()) {
	    *E = P->love;
	} else {
	    *E = QpQuery(Query::OP_AND_MAYBE, P->love, *E);
	}
    }
    // Handle any "- terms".
    if (P->hate.can_match()) {
	if (E->empty()) {
	    delete E;
	    // Can't just hate!
	    yy_parse_failed(yypParser);
	    return;
	}
	*E = QpQuery(Query::OP_AND_NOT, *E, P->hate);
    }
    // Handle any boolean filters.
    if (!P->filter.empty()) {
	if (E->empty()) {
	    *E = P->filter;
	    // FIXME and make the query boolean somehow...
	} else {
	    *E = QpQuery(Query::OP_FILTER, *E, P->filter);
	}
    }
    // FIXME what if E->empty() (all terms are stopwords)?
    delete P;
}

prob_expr(E) ::= term(T). {
    E = T;
}

// prob - a probabilistic sub-expression consisting of stop_terms, "+" terms,
// "-" terms, boolean filters, and/or value ranges.
//
// Note: stop_term can also be several other things other than a simple term!

%type prob {ProbQuery *}
%destructor prob {delete $$;}

prob(P) ::= RANGE_START(A) RANGE_END(B). {
    QpQuery * range = state->value_range(A, B);
    if (range == NULL) yy_parse_failed(yypParser);
    P = new ProbQuery;
    P->filter = *range;
    delete range;
}

prob(P) ::= stop_prob(Q) RANGE_START(A) RANGE_END(B). {
    QpQuery * range = state->value_range(A, B);
    if (range == NULL) yy_parse_failed(yypParser);
    P = Q;
    add_to_query(P->filter, Query::OP_AND, *range);
    delete range;
}

prob(P) ::= stop_term(T) stop_term(U). {
    P = new ProbQuery;
    P->query = *T;
    delete T;
    if (!U->empty())
	add_to_query(P->query, state->default_op(), *U);
    delete U;
}

prob(P) ::= prob(Q) stop_term(T). {
    P = Q;
    // If T is a stopword, there's nothing to do here.
    if (!T->empty())
	add_to_query(P->query, state->default_op(), *T);
    delete T;
}

prob(P) ::= LOVE term(T). {
    P = new ProbQuery;
    if (state->default_op() == Query::OP_AND) {
	P->query = *T;
    } else {
	P->love = *T;
    }
    delete T;
}

prob(P) ::= stop_prob(Q) LOVE term(T). {
    P = Q;
    if (state->default_op() == Query::OP_AND) {
	/* The default op is AND, so we just put loved terms into the query
	 * (in this case the only effect of love is to ignore the stopword
	 * list). */
	add_to_query(P->query, Query::OP_AND, *T);
    } else {
	add_to_query(P->love, Query::OP_AND, *T);
    }
    delete T;
}

prob(P) ::= HATE term(T). {
    P = new ProbQuery;
    P->hate = *T;
    delete T;
}

prob(P) ::= stop_prob(Q) HATE term(T). {
    P = Q;
    add_to_query(P->hate, Query::OP_OR, *T);
    delete T;
}

prob(P) ::= HATE BOOLEAN_FILTER(T). {
    P = new ProbQuery;
    P->hate = T->as_query_object();
    delete T;
}

prob(P) ::= stop_prob(Q) HATE BOOLEAN_FILTER(T). {
    P = Q;
    add_to_query(P->hate, Query::OP_OR, T->as_query_object());
    delete T;
}

prob(P) ::= BOOLEAN_FILTER(T). {
    P = new ProbQuery;
    P->filter = T->as_query_object();
    delete T;
}

prob(P) ::= stop_prob(Q) BOOLEAN_FILTER(T). {
    P = Q;
    // FIXME we should OR filters with the same prefix...
    add_to_query(P->filter, Query::OP_AND, T->as_query_object());
    delete T;
}

prob(P) ::= LOVE BOOLEAN_FILTER(T). {
    // LOVE BOOLEAN_FILTER(T) is just the same as BOOLEAN_FILTER
    P = new ProbQuery;
    P->filter = T->as_query_object();
    delete T;
}

prob(P) ::= stop_prob(Q) LOVE BOOLEAN_FILTER(T). {
    // LOVE BOOLEAN_FILTER(T) is just the same as BOOLEAN_FILTER
    P = Q;
    // FIXME we should OR filters with the same prefix...
    add_to_query(P->filter, Query::OP_AND, T->as_query_object());
    delete T;
}

// stop_prob - A prob or a stop_term.

%type stop_prob {ProbQuery *}
%destructor stop_prob {delete $$;}

stop_prob(P) ::= prob(Q).
    { P = Q; }

stop_prob(P) ::= stop_term(T). {
    P = new ProbQuery;
    P->query = *T;
    delete T;
}

// stop_term - A term which should be checked against the stopword list,
// or a compound_term.
//
// If a term is loved, hated, or in a phrase, we don't want to consult the
// stopword list, so stop_term isn't used there (instead term is).

%type stop_term {QpQuery *}
%destructor stop_term {delete $$;}

stop_term(T) ::= TERM(U). {
    if (state->is_stopword(U)) {
	T = new QpQuery;
	state->add_to_stoplist(U);
    } else {
	T = U->as_query();
    }
    delete U;
}

stop_term(T) ::= compound_term(U). {
    T = U;
}

// term - A term or a compound_term.

%type term {QpQuery *}
%destructor term {delete $$;}

term(T) ::= TERM(U). {
    T = U->as_query();
    delete U;
}

term(T) ::= compound_term(U). {
    T = U;
}

// compound_term - A WILD_TERM, a quoted phrase (with or without prefix), a
// phrased_term, near_expr, adj_expr, or a bracketed subexpression (with or
// without prefix).

%type compound_term {QpQuery *}
%destructor compound_term {delete $$;}

compound_term(T) ::= WILD_TERM(U). {
    T = U->as_wildcarded_query(state);
    delete U;
}

compound_term(T) ::= QUOTE phrase(P) QUOTE.
	{ T = P->as_phrase_query(); }

compound_term(T) ::= phrased_term(P).
	{ T = P->as_phrase_query(); }

compound_term(T) ::= near_expr(P).
	{ T = P->as_near_query(); }

compound_term(T) ::= adj_expr(P).
	{ T = P->as_adj_query(); }

compound_term(T) ::= BRA expr(E) KET.
	{ T = E; }

// phrase - The "inside the quotes" part of a double-quoted phrase.

%type phrase {TermList *}

%destructor phrase {$$->destroy();}

phrase(P) ::= TERM(T). {
    P = new TermList;
    P->add_unstemmed_term(T);
}

phrase(P) ::= phrase(Q) TERM(T). {
    P = Q;
    P->add_unstemmed_term(T);
}

// phrased_term - A phrased term works like a single term, but is actually
// 2 or more terms linked together into a phrase by punctuation.  There must be
// at least 2 terms in order to be able to have punctuation between the terms!

%type phrased_term {TermList *}
%destructor phrased_term {$$->destroy();}

phrased_term(P) ::= TERM(T) PHR_TERM(U). {
    P = new TermList;
    P->add_unstemmed_term(T);
    P->add_unstemmed_term(U);
}

phrased_term(P) ::= phrased_term(Q) PHR_TERM(T). {
    P = Q;
    P->add_unstemmed_term(T);
}

// near_expr - 2 or more terms with NEAR in between.  There must be at least 2
// terms in order for there to be any NEAR operators!

%type near_expr {TermList *}
%destructor near_expr {$$->destroy();}

near_expr(P) ::= TERM(T) NEAR(N) TERM(U). {
    P = new TermList;
    P->add_unstemmed_term(T);
    P->add_unstemmed_term(U);
    if (N) {
	P->adjust_window(N->get_termpos());
	delete N;
    }
}

near_expr(P) ::= near_expr(Q) NEAR(N) TERM(T). {
    P = Q;
    P->add_unstemmed_term(T);
    if (N) {
	P->adjust_window(N->get_termpos());
	delete N;
    }
}

// adj_expr - 2 or more terms with ADJ in between.  There must be at least 2
// terms in order for there to be any ADJ operators!

%type adj_expr {TermList *}
%destructor adj_expr {$$->destroy();}

adj_expr(P) ::= TERM(T) ADJ(N) TERM(U). {
    P = new TermList;
    P->add_unstemmed_term(T);
    P->add_unstemmed_term(U);
    if (N) {
	P->adjust_window(N->get_termpos());
	delete N;
    }
}

adj_expr(P) ::= adj_expr(Q) ADJ(N) TERM(T). {
    P = Q;
    P->add_unstemmed_term(T);
    if (N) {
	P->adjust_window(N->get_termpos());
	delete N;
    }
}

// Select yacc syntax highlighting in vim editor: vim: syntax=yacc
// (lemon syntax colouring isn't supplied by default; yacc does an OK job).
