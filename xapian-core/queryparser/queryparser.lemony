%include {
/* queryparser.lemony: build a Xapian::Query object from a user query string.
 *
 * Copyright (C) 2004,2005 Olly Betts
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */

#include <config.h>

#include "accentnormalisingitor.h"
#include "queryparser_internal.h"
#include "utils.h"

// Include the list of token values lemon generates.
#include "queryparser_token.h"

#include <algorithm>
#include <list>
#include <string>

using namespace std;

using namespace Xapian;

// Disable debug code lemon adds.
#define NDEBUG

/// Class used to pass information about a term from lexer to parser.
class Term {
    // So State can read our name.
    friend class ::State;

    string name;
    termpos pos;

  public:
    Term(const string &name_, termpos pos_) : name(name_), pos(pos_) { }

    Query * as_query() const { return new Query(name, 1, pos); }

    Query as_query_object() const { return Query(name, 1, pos); }
};

/// Parser State shared between the lexer and the parser.
class State {
  private:
    QueryParser::Internal * qpi;
    list<string> prefix_stack;

  public:
    Query query;
    const char * error;

    State(QueryParser::Internal * qpi_) : qpi(qpi_), error(NULL) { }

    void add_to_stoplist(const Term * term) {
	qpi->stoplist.push_back(term->name);
    }

    Query::op default_op() const { return qpi->default_op; }

    bool is_stopword(const Term *term) const {
	return qpi->stopper && (*qpi->stopper)(term->name);
    }

    void push_prefix(const string & prefix) {
	prefix_stack.push_back(prefix);
    }

    void pop_prefix() {
	prefix_stack.pop_back();
    }

    string get_current_prefix() const {
	return prefix_stack.empty() ? "" : prefix_stack.back();
    }
};

static inline string
downcase_term(const string &term)
{
    string t;
    t.reserve(term.size());
    AccentNormalisingItor i(term.begin());
    const AccentNormalisingItor end(term.end());
    while (i != end) t += C_tolower(*i++);
    return t;
}

static inline bool
is_phrase_generator(unsigned char ch)
{
    // These characters generate a phrase search.
    // Ordered mostly by frequency of calls to this function done when
    // running queryparsertest.
    return (ch && strchr(".-/':\\_@", ch) != NULL);
}

static inline bool
prefix_needs_colon(const string & prefix, unsigned char ch)
{
    if (!C_isupper(ch)) return false;
    string::size_type len = prefix.length();
    return (len > 1 && prefix[len - 1] != ':');
}

// Prototype the functions lemon generates.
static void *ParseAlloc(void *(*mallocProc)(size_t));
static void ParseFree(void *, void (*freeProc)(void*));
static void Parse(void *, int, Term *, State *);

Query
QueryParser::Internal::parse_query(const string &qs, unsigned int flags)
{
#ifndef NDEBUG
    // Set the prefix added to Lemon's debug output, if it's enabled.
    // FIXME: arrange to send this to the Xapian debug log, and turn
    // on Lemon's debugging when --enable-debug is on.
    ParseTrace(stdout, "LEMON: ");
#endif

    void * pParser = ParseAlloc(malloc);

    termpos term_pos = 1;
    AccentNormalisingItor it(qs.begin()), end(qs.end());

    State state(this);

    enum { DEFAULT, IN_QUOTES, IN_PHRASED_TERM } mode = DEFAULT;
    unsigned char newprev = ' ';
    while (it != end) {
	if (mode == IN_PHRASED_TERM) mode = DEFAULT;
	if (C_isspace(*it)) {
	    newprev = ' ';
	    ++it;
	    it = find_if(it, end, C_isnotspace);
	    if (it == end) break;
	}

	if (!C_isalnum(*it)) {
	    unsigned char prev = newprev;
	    unsigned char ch = *it++;
	    if (it != end) newprev = *it;
	    switch (ch) {
	      case '"':
		// Skip whitespace.
		it = find_if(it, end, C_isnotspace);
		if (mode != IN_QUOTES) {
		    if (it == end) {
			// Ignore an unmatched " at the end of the query to
			// avoid generating an empty set of QUOTE which will
			// cause a parse error.
			goto done;
		    }
		    if (*it == '"') {
			// Ignore empty "" (but only if we're not already
			// IN_QUOTES as we don't merge two adjacent quoted
			// phrases!)
			newprev = *it++;
			continue;
		    }
		}
		if (flags & FLAG_PHRASE) {
		    Parse(pParser, QUOTE, NULL, &state);
		    if (mode == IN_QUOTES) {
			mode = DEFAULT;
		    } else {
			mode = IN_QUOTES;
		    }
		}
		continue;

	      case '+': case '-':
		// Ignore + or - at end of query.
		if (it == end) goto done;
		if (prev > ' ' && prev != '(') {
		    // Or if not after whitespace or an open bracket.
		    continue;
		}
		if (C_isspace(*it) || *it == '+' || *it == '-') {
		    // Ignore + or - followed by a space, or further + or -.
		    // Postfix + (such as in C++ and H+) is handled as part of
		    // the term lexing code below.
		    newprev = *it++;
		    continue;
		}
		if (mode == DEFAULT && (flags & FLAG_LOVEHATE))
		    Parse(pParser, (ch == '+' ? LOVE : HATE), NULL, &state);
		continue;

	      case '(':
		// Skip whitespace.
		it = find_if(it, end, C_isnotspace);
		// Ignore ( at end of query.
		if (it == end) goto done;
		if (prev > ' ' && prev != '(' && prev != ')') {
		    // Or if not after whitespace or a bracket.
		    continue;
		}
		if (*it == ')') {
		    // Ignore empty ().
		    newprev = *it++;
		    continue;
		}
		if (mode == DEFAULT && (flags & FLAG_BOOLEAN))
		    Parse(pParser, BRA, NULL, &state);
		continue;

	      case ')':
		if (term_pos == 1) {
		    // Ignore ) at start of query.
		    continue;
		}
		if (mode == DEFAULT && (flags & FLAG_BOOLEAN))
		    Parse(pParser, KET, NULL, &state);
		continue;
	    }
	    // Skip any other characters.
	    continue;
	}

	newprev = 'A'; // Any letter will do...

	// A term, a prefix, or a boolean operator.
	string prefix;
	if (mode == DEFAULT && !prefixes.empty()) {
	    // Check for fieldname prefixes (e.g. title:historical).
	    AccentNormalisingItor p = find_if(it, end, C_isnotalnum);
	    if (p != end && *p == ':' && ++p != end) {
		unsigned char ch = *p;
		if (C_isalnum(ch) ||
		    ((flags & FLAG_PHRASE) && ch == '"') || 
		    ((flags & FLAG_BOOLEAN) && ch == '(')) {
		    string field;
		    p = it;
		    while (*p != ':') field += *p++;
		    map<string, pair<bool, string> >::const_iterator f;
		    f = prefixes.find(field);
		    if (f != prefixes.end()) {
			// Can't boolean prefix a subexpression or phrase.
			bool boolean_filter = f->second.first;
			if (!boolean_filter || C_isalnum(ch)) {
			    it = p;
			    ++it;
			    if (!C_isalnum(ch)) {
				newprev = ch;
				++it;
				state.push_prefix(f->second.second);
				// Prefixed sub-expr: title:(fast NEAR food)
				if (ch == '(') {
				    Parse(pParser, PREFIX_BRA, NULL, &state);
				    continue;
				}
				// Prefixed phrase: subject:"space flight"
				Parse(pParser, PREFIX_QUOTE, NULL, &state);
				mode = IN_QUOTES;
				continue;
			    }
			    prefix = f->second.second;
			    if (boolean_filter) {
				if (prefix_needs_colon(prefix, *it))
				    prefix += ':';
				while (it != end && *it > ' ' && *it != ')')
				    prefix += *it++;
				Parse(pParser, BOOLEAN_FILTER,
				      new Term(prefix, 0), &state);
				continue;
			    }
			}
		    }
		}
	    }
	}

phrased_term:
	string term;
	size_t transliterations = it.transliterations();
	// Look for initials separated by '.' (e.g. P.T.O., U.N.C.L.E).
	// Don't worry if there's a trailing '.' or not.
	if (C_isupper(*it)) {
	    string t;
	    AccentNormalisingItor p = it;
	    do {
		t += *p++;
	    } while (p != end && *p == '.' && ++p != end && C_isupper(*p));
	    // One letter does not make an acronym!  If we handled a single
	    // uppercase letter here, we wouldn't catch M&S below.
	    if (t.length() > 1) {
		// Check there's not a (lower case) letter or digit
		// immediately after it.
		if (p == end || !C_isalnum(*p)) {
		    it = p;
		    swap(term, t);
		}
	    }
	}
	bool was_acronym = !term.empty();

	if (term.empty()) {
	    while (it != end) {
		if (!C_isalnum(*it)) {
		    // Treat a single embedded '&' as a word character
		    // (e.g. AT&T).
		    if (*it != '&') break;
		    AccentNormalisingItor p = it;
		    ++p;
		    if (p == end || !C_isalnum(*p)) break;
		}
		term += *it++;
	    }
	    if (it != end && (*it == '#' || C_issign(*it))) {
		string suff_term = term;
		AccentNormalisingItor p = it;
		if (*p == '#') {
		    // Keep trailing # (e.g. C#).
		    suff_term += '#';
		    while (++p != end && *p == '#') { }
		} else {
		    // Keep trailing +, and - (e.g. C++, Na+, Cl-).
		    // FIXME: keeping trailing "-" is of dubious utility and
		    // there's the risk of hyphens getting stuck onto the end of
		    // terms...
		    // FIXME: generating a term like foo+---+++ doesn't make
		    // much sense - we should probably be more conservative as
		    // to what combinations are allowed.
		    do {
			suff_term += *p++;
		    } while (p != end && C_issign(*p));
		}
		if (p == end || !C_isalnum(*p)) {
		    // If the suffixed term doesn't exist, check that the
		    // non-suffixed term does.  This also takes care of
		    // the case when QueryParser::set_database() hasn't
		    // been called.
		    if (db.term_exists(suff_term) || !db.term_exists(term)) {
			term = suff_term;
			it = p;
		    }
		}
	    }
	}

	// Boolean operators.
	if (mode == DEFAULT && (flags & FLAG_BOOLEAN)) {
	    // Don't want to interpret A.N.D. or ÁND as an AND operator.
	    if (!was_acronym && transliterations == it.transliterations()) {
		if (prefix.empty() && !term.empty() && C_isupper(term[0])) {
		    if (term == "AND") {
			Parse(pParser, AND, NULL, &state);
			continue;
		    } else if (term == "OR") {
			Parse(pParser, OR, NULL, &state);
			continue;
		    } else if (term == "NOT") {
			Parse(pParser, NOT, NULL, &state);
			continue;
		    } else if (term == "NEAR") {
			Parse(pParser, NEAR, NULL, &state);
			continue;
		    } else if (term == "XOR") {
			Parse(pParser, XOR, NULL, &state);
			continue;
		    }
		}
	    }
	}

	bool need_to_stem = (stem_action != STEM_NONE);
	string unstemmed_term;
	if (stem_action == STEM_SOME && it != end && *it == '.') {
	    AccentNormalisingItor p = it;
	    ++p;
	    // TopTerms won't generate an embedded '.', and we want to
	    // stem terms in a phrased term with '.' phrase generators -
	    // e.g. "example.com" should give a phrase search for "exampl"
	    // and "com", not "example" and "com".
	    if (p == end || C_isspace(*p)) {
		it = p;
		// If topterms added a term with a trailing '.', it will be
		// lower case.  So if it has an initial capital it must be an
		// initial in someone's name, a full stop in pasted text or
		// something like that.
		if (!C_isupper(term[0])) {
		    unstemmed_term = term + '.';
		    need_to_stem = false;
		}
	    }
	}

	if (unstemmed_term.empty()) unstemmed_term = term;
	term = downcase_term(term);
	if (need_to_stem) {
	    if (stem_action == STEM_SOME && C_isupper(unstemmed_term[0]))
		term = 'R' + term;
	    else 
		term = stemmer.stem_word(term);
	}

	if (prefix.empty()) prefix = state.get_current_prefix();
	if (!prefix.empty()) {
	    if (prefix_needs_colon(prefix, term[0])) prefix += ':';
	    term = prefix + term;
	}

#ifndef __SUNPRO_CC
	unstem.insert(make_pair(term, unstemmed_term));
#else
	unstem.insert(make_pair<const string, string>(term, unstemmed_term));
#endif

	if (mode == IN_PHRASED_TERM) {
	    Parse(pParser, PHR_TERM, new Term(term, term_pos++), &state);
	} else {
	    Parse(pParser, TERM, new Term(term, term_pos++), &state);
	    if (mode == IN_QUOTES) continue;
	}

	if (it != end && is_phrase_generator(*it)) {
	    // Skip multiple phrase generaters.
	    do {
		++it;
	    } while (it != end && is_phrase_generator(*it));
	    // Don't generate a phrase unless the phrase generators are
	    // immediately followed by another term.
	    if (it != end && C_isalnum(*it)) {
		mode = IN_PHRASED_TERM;
		goto phrased_term;
	    }
	}
    }
done:
    // Implicitly close any unclosed quotes...
    if (mode == IN_QUOTES) Parse(pParser, QUOTE, NULL, &state);
    Parse(pParser, 0, NULL, &state);
    ParseFree(pParser, free);

    errmsg = state.error;
    return state.query;
}

struct ProbQuery {
    Query query;
    Query love;
    Query hate;
    Query filter;
};

class TermList {
    list<Query> terms;

  public:
    /// Add a Term object to this TermList object.
    void add_term(Term * term) {
	terms.push_back(term->as_query_object());
	delete term;
    }

    /// Convert to a Xapian::Query * using OP_PHRASE.
    Query * as_phrase_query() const {
	Query * term;
	term = new Query(Query::OP_PHRASE, terms.begin(), terms.end(),
			 terms.size());
	delete this;
	return term;
    }

    /// Convert to a Xapian::Query * using OP_NEAR.
    Query * as_near_query() const {
	Query * term;
	// The common meaning of 'a NEAR b' is "a within 10 terms of b", which
	// means a window size of 11.  For more than 2 terms, we just add one
	// to the window size for each extra term.
	term = new Query(Query::OP_NEAR, terms.begin(), terms.end(),
			 terms.size() + 9);
	delete this;
	return term;
    }

    /** Provide a way to explicitly delete an object of this class.  The
     *  destructor is protected to prevent auto-variables of this type.
     */
    void destroy() { delete this; }

  protected:
    /** Protected destructor, so an auto-variable of this type is a
     *  compile-time error - you must allocate this object with new.
     */
    ~TermList() { }
};

// Helper macro for converting a boolean operation into a Xapian::Query.
#define BOOL_OP_TO_QUERY(E, A, OP, B, OP_TXT) \
    do {\
	if (!A || !B) {\
	    state->error = "Syntax: <expression> "OP_TXT" <expression>";\
	    yy_parse_failed(yypParser);\
	    return;\
	}\
	E = new Query(OP, *A, *B);\
	delete A;\
	delete B;\
    } while (0)

}

%token_type {Term *}
%token_destructor {delete $$;}

%extra_argument {State * state}

%parse_failure {
    // If we've not already set an error message, set a default one.
    if (!state->error) state->error = "parse error";
}

// Operators, grouped in order of increasing precedence:
%left NOT OR XOR.
%left AND.
%left NEAR.
%left LOVE HATE.

// Destructors for terminal symbols:

// TERM is a query term, including prefix (if any).
%destructor TERM {delete $$;}

// PHR_TERM is a query term which follows a TERM or another PHR_TERM and is
// separated only by one or more phrase generator characters (hyphen and
// apostrophe are common examples - see is_phrase_generator() for the list
// of all punctuation which does this).
%destructor PHR_TERM {delete $$;}

// BOOLEAN_FILTER is a query term with a prefix registered using
// add_bool_prefix().  It's added to the query using a FILTER operator,
// e.g. site:xapian.org (or using AND_NOT if it's negated).
%destructor BOOLEAN_FILTER {delete $$;}

// Grammar rules:

// query - The whole query - just an expr or nothing.

// query non-terminal doesn't need a type, so just give a dummy one.
%type query {int}

query ::= expr(E). {
    // Save the parsed query in the State structure so we can return it.
    state->query = *E;
    delete E;
}

query ::= . {
    // Handle a query string with no terms in.
    state->query = Query();
}

// expr - A query expression.

%type expr {Query *}
%destructor expr {delete $$;}

expr(E) ::= prob(P). {
    E = new Query(P->query);
    // Handle any "+ terms".
    if (!P->love.empty()) {
	if (E->empty()) {
	    *E = P->love;
	} else {
	    *E = Query(Query::OP_AND_MAYBE, P->love, *E);
	}
    }
    // Handle any "- terms".
    if (!P->hate.empty()) {
	if (E->empty()) {
	    delete E;
	    // Can't just hate!
	    yy_parse_failed(yypParser);
	    return;
	}
	*E = Query(Query::OP_AND_NOT, *E, P->hate);
    }
    // Handle any boolean filters.
    if (!P->filter.empty()) {
	if (E->empty()) {
	    *E = P->filter;
	    // FIXME and make the query boolean somehow...
	} else {
	    *E = Query(Query::OP_FILTER, *E, P->filter);
	}
    }
    // FIXME what if E->empty() (only one term, which is a stopword)?
    delete P;
}

expr(E) ::= bool_arg(A) AND bool_arg(B).
	{ BOOL_OP_TO_QUERY(E, A, Query::OP_AND, B, "AND"); }

expr(E) ::= bool_arg(A) NOT bool_arg(B).
	{ BOOL_OP_TO_QUERY(E, A, Query::OP_AND_NOT, B, "NOT"); }

expr(E) ::= bool_arg(A) OR bool_arg(B).
	{ BOOL_OP_TO_QUERY(E, A, Query::OP_OR, B, "OR"); }

expr(E) ::= bool_arg(A) XOR bool_arg(B).
	{ BOOL_OP_TO_QUERY(E, A, Query::OP_XOR, B, "XOR"); }

// bool_arg - an argument to a boolean operator such as AND or OR.

%type bool_arg {Query *}
%destructor bool_arg {delete $$;}

bool_arg(A) ::= expr(E). { A = E; }

bool_arg(A) ::= . {
    // Set the argument to NULL, which enables the bool_arg-using rules in
    // expr above to report uses of AND, OR, etc which don't have two
    // arguments.
    A = NULL;
}

// prob - a probabilistic sub-expression consisting of stop_terms, "+" terms,
// and/or "-" terms.
//
// Note: stop_term can also be several other things other than a simple term!

%type prob {ProbQuery *}
%destructor prob {delete $$;}

prob(P) ::= stop_term(T). {
    P = new ProbQuery;
    P->query = *T;
    delete T;
}

prob(P) ::= prob(Q) stop_term(T). {
    P = Q;
    // If T is a stopword, there's nothing to do here.
    if (!T->empty()) {
	if (P->query.empty()) {
	    P->query = *T;
	} else {
	    P->query = Query(state->default_op(), P->query, *T);
	}
    }
    delete T;
}

prob(P) ::= LOVE term(T). {
    P = new ProbQuery;
    P->love = *T;
    delete T;
}

prob(P) ::= prob(Q) LOVE term(T). {
    P = Q;
    if (P->love.empty()) {
	P->love = *T;
    } else {
	P->love = Query(Query::OP_AND, P->love, *T);
    }
    delete T;
}

prob(P) ::= HATE term(T). {
    P = new ProbQuery;
    P->hate = *T;
    delete T;
}

prob(P) ::= prob(Q) HATE term(T). {
    P = Q;
    if (P->hate.empty()) {
	P->hate = *T;
    } else {
	P->hate = Query(Query::OP_OR, P->hate, *T);
    }
    delete T;
}

prob(P) ::= HATE BOOLEAN_FILTER(T). {
    P = new ProbQuery;
    P->hate = T->as_query_object();
    delete T;
}

prob(P) ::= prob(Q) HATE BOOLEAN_FILTER(T). {
    P = Q;
    if (P->hate.empty()) {
	P->hate = T->as_query_object();
    } else {
	P->hate = Query(Query::OP_OR, P->hate, T->as_query_object());
    }
    delete T;
}

prob(P) ::= BOOLEAN_FILTER(T). {
    P = new ProbQuery;
    P->filter = T->as_query_object();
    delete T;
}

prob(P) ::= prob(Q) BOOLEAN_FILTER(T). {
    P = Q;
    if (P->filter.empty()) {
	P->filter = T->as_query_object();
    } else {
	// FIXME we should OR filters with the same prefix...
	P->filter = Query(Query::OP_AND, P->filter, T->as_query_object());
    }
    delete T;
}

// stop_term - A term which should be checked against the stopword list,
// or a quoted phrase (with or without prefix) or a phrased_term or a near_expr
// or a bracketed subexpression (with or without prefix).
//
// If a term is loved, hated, or in a phrase, we don't want to consult the
// stopword list, so stop_term isn't used there.

%type stop_term {Query *}
%destructor stop_term {delete $$;}

stop_term(T) ::= TERM(U). {
    if (state->is_stopword(U)) {
	T = new Query;
	state->add_to_stoplist(U);
    } else {
	T = U->as_query();
    }
    delete U;
}

stop_term(T) ::= PREFIX_QUOTE phrase(P) QUOTE. {
    // Remove the prefix which the lexer pushed as it generated PREFIX_QUOTE.
    state->pop_prefix();
    T = P->as_phrase_query();
}

stop_term(T) ::= QUOTE phrase(P) QUOTE.
	{ T = P->as_phrase_query(); }

stop_term(T) ::= phrased_term(P).
	{ T = P->as_phrase_query(); }

stop_term(T) ::= near_expr(P).
	{ T = P->as_near_query(); }

stop_term(T) ::= BRA expr(E) KET.
	{ T = E; }

stop_term(T) ::= PREFIX_BRA expr(E) KET. {
    // Remove the prefix which the lexer pushed as it generated PREFIX_BRA.
    state->pop_prefix();
    T = E;
}

// term - A term, or a phrase (quoted, hyphenated, or NEARed), or a general
// expression in brackets.

%type term {Query *}
%destructor term {delete $$;}

term(T) ::= TERM(U). {
    T = U->as_query();
    delete U;
}

term(T) ::= QUOTE phrase(P) QUOTE.
	{ T = P->as_phrase_query(); }

term(T) ::= phrased_term(P).
	{ T = P->as_phrase_query(); }

term(T) ::= near_expr(P).
	{ T = P->as_near_query(); }

term(T) ::= BRA expr(E) KET.
	{ T = E; }

// phrase - The "inside the quotes" part of a double-quoted phrase.

%type phrase {TermList *}

%destructor phrase {$$->destroy();}

phrase(P) ::= TERM(T). {
    P = new TermList;
    P->add_term(T);
}

phrase(P) ::= phrase(Q) TERM(T). {
    P = Q;
    P->add_term(T);
}

// phrased_term - A phrased term works like a single term, but is actually
// 2 or more terms linked together into a phrase by punctuation.  There must be
// at least 2 terms in order to be able to have punctuation between the terms!

%type phrased_term {TermList *}
%destructor phrased_term {$$->destroy();}

phrased_term(P) ::= TERM(T) PHR_TERM(U). {
    P = new TermList;
    P->add_term(T);
    P->add_term(U);
}

phrased_term(P) ::= phrased_term(Q) PHR_TERM(T). {
    P = Q;
    P->add_term(T);
}

// near_expr - 2 or more terms with NEAR in between.  There must be at least 2
// terms in order to be able to have punctuation between the terms!

%type near_expr {TermList *}
%destructor near_expr {$$->destroy();}

near_expr(P) ::= TERM(T) NEAR TERM(U). {
    P = new TermList;
    P->add_term(T);
    P->add_term(U);
}

near_expr(P) ::= near_expr(Q) NEAR TERM(T). {
    P = Q;
    P->add_term(T);
}

// Select appropriate syntax highlighting in vim editor: vim: syntax=lemon
// (lemon syntax colouring isn't supplied by default though).
